/*! For license information please see 769.72e1b628.iframe.bundle.js.LICENSE.txt */
(self.webpackChunk_tsparticles_storybook=self.webpackChunk_tsparticles_storybook||[]).push([[769],{"./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg),value=info.value}catch(error){return void reject(error)}info.done?resolve(value):Promise.resolve(value).then(_next,_throw)}function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise((function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value)}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err)}_next(void 0)}))}}__webpack_require__.d(__webpack_exports__,{Z:()=>_asyncToGenerator})},"./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Z:()=>_objectSpread2});var esm_typeof=__webpack_require__("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof.js");function _toPropertyKey(arg){var key=function _toPrimitive(input,hint){if("object"!==(0,esm_typeof.Z)(input)||null===input)return input;var prim=input[Symbol.toPrimitive];if(void 0!==prim){var res=prim.call(input,hint||"default");if("object"!==(0,esm_typeof.Z)(res))return res;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===hint?String:Number)(input)}(arg,"string");return"symbol"===(0,esm_typeof.Z)(key)?key:String(key)}function _defineProperty(obj,key,value){return(key=_toPropertyKey(key))in obj?Object.defineProperty(obj,key,{value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){_defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}},"./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Z:()=>_regeneratorRuntime});var _typeof_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof.js");function _regeneratorRuntime(){_regeneratorRuntime=function _regeneratorRuntime(){return exports};var exports={},Op=Object.prototype,hasOwn=Op.hasOwnProperty,defineProperty=Object.defineProperty||function(obj,key,desc){obj[key]=desc.value},$Symbol="function"==typeof Symbol?Symbol:{},iteratorSymbol=$Symbol.iterator||"@@iterator",asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator",toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";function define(obj,key,value){return Object.defineProperty(obj,key,{value,enumerable:!0,configurable:!0,writable:!0}),obj[key]}try{define({},"")}catch(err){define=function define(obj,key,value){return obj[key]=value}}function wrap(innerFn,outerFn,self,tryLocsList){var protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator,generator=Object.create(protoGenerator.prototype),context=new Context(tryLocsList||[]);return defineProperty(generator,"_invoke",{value:makeInvokeMethod(innerFn,self,context)}),generator}function tryCatch(fn,obj,arg){try{return{type:"normal",arg:fn.call(obj,arg)}}catch(err){return{type:"throw",arg:err}}}exports.wrap=wrap;var ContinueSentinel={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var IteratorPrototype={};define(IteratorPrototype,iteratorSymbol,(function(){return this}));var getProto=Object.getPrototypeOf,NativeIteratorPrototype=getProto&&getProto(getProto(values([])));NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)&&(IteratorPrototype=NativeIteratorPrototype);var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);function defineIteratorMethods(prototype){["next","throw","return"].forEach((function(method){define(prototype,method,(function(arg){return this._invoke(method,arg)}))}))}function AsyncIterator(generator,PromiseImpl){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if("throw"!==record.type){var result=record.arg,value=result.value;return value&&"object"==(0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__.Z)(value)&&hasOwn.call(value,"__await")?PromiseImpl.resolve(value.__await).then((function(value){invoke("next",value,resolve,reject)}),(function(err){invoke("throw",err,resolve,reject)})):PromiseImpl.resolve(value).then((function(unwrapped){result.value=unwrapped,resolve(result)}),(function(error){return invoke("throw",error,resolve,reject)}))}reject(record.arg)}var previousPromise;defineProperty(this,"_invoke",{value:function value(method,arg){function callInvokeWithMethodAndArg(){return new PromiseImpl((function(resolve,reject){invoke(method,arg,resolve,reject)}))}return previousPromise=previousPromise?previousPromise.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(innerFn,self,context){var state="suspendedStart";return function(method,arg){if("executing"===state)throw new Error("Generator is already running");if("completed"===state){if("throw"===method)throw arg;return doneResult()}for(context.method=method,context.arg=arg;;){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult}}if("next"===context.method)context.sent=context._sent=context.arg;else if("throw"===context.method){if("suspendedStart"===state)throw state="completed",context.arg;context.dispatchException(context.arg)}else"return"===context.method&&context.abrupt("return",context.arg);state="executing";var record=tryCatch(innerFn,self,context);if("normal"===record.type){if(state=context.done?"completed":"suspendedYield",record.arg===ContinueSentinel)continue;return{value:record.arg,done:context.done}}"throw"===record.type&&(state="completed",context.method="throw",context.arg=record.arg)}}}function maybeInvokeDelegate(delegate,context){var methodName=context.method,method=delegate.iterator[methodName];if(void 0===method)return context.delegate=null,"throw"===methodName&&delegate.iterator.return&&(context.method="return",context.arg=void 0,maybeInvokeDelegate(delegate,context),"throw"===context.method)||"return"!==methodName&&(context.method="throw",context.arg=new TypeError("The iterator does not provide a '"+methodName+"' method")),ContinueSentinel;var record=tryCatch(method,delegate.iterator,context.arg);if("throw"===record.type)return context.method="throw",context.arg=record.arg,context.delegate=null,ContinueSentinel;var info=record.arg;return info?info.done?(context[delegate.resultName]=info.value,context.next=delegate.nextLoc,"return"!==context.method&&(context.method="next",context.arg=void 0),context.delegate=null,ContinueSentinel):info:(context.method="throw",context.arg=new TypeError("iterator result is not an object"),context.delegate=null,ContinueSentinel)}function pushTryEntry(locs){var entry={tryLoc:locs[0]};1 in locs&&(entry.catchLoc=locs[1]),2 in locs&&(entry.finallyLoc=locs[2],entry.afterLoc=locs[3]),this.tryEntries.push(entry)}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal",delete record.arg,entry.completion=record}function Context(tryLocsList){this.tryEntries=[{tryLoc:"root"}],tryLocsList.forEach(pushTryEntry,this),this.reset(!0)}function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod)return iteratorMethod.call(iterable);if("function"==typeof iterable.next)return iterable;if(!isNaN(iterable.length)){var i=-1,next=function next(){for(;++i<iterable.length;)if(hasOwn.call(iterable,i))return next.value=iterable[i],next.done=!1,next;return next.value=void 0,next.done=!0,next};return next.next=next}}return{next:doneResult}}function doneResult(){return{value:void 0,done:!0}}return GeneratorFunction.prototype=GeneratorFunctionPrototype,defineProperty(Gp,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),defineProperty(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,toStringTagSymbol,"GeneratorFunction"),exports.isGeneratorFunction=function(genFun){var ctor="function"==typeof genFun&&genFun.constructor;return!!ctor&&(ctor===GeneratorFunction||"GeneratorFunction"===(ctor.displayName||ctor.name))},exports.mark=function(genFun){return Object.setPrototypeOf?Object.setPrototypeOf(genFun,GeneratorFunctionPrototype):(genFun.__proto__=GeneratorFunctionPrototype,define(genFun,toStringTagSymbol,"GeneratorFunction")),genFun.prototype=Object.create(Gp),genFun},exports.awrap=function(arg){return{__await:arg}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,asyncIteratorSymbol,(function(){return this})),exports.AsyncIterator=AsyncIterator,exports.async=function(innerFn,outerFn,self,tryLocsList,PromiseImpl){void 0===PromiseImpl&&(PromiseImpl=Promise);var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList),PromiseImpl);return exports.isGeneratorFunction(outerFn)?iter:iter.next().then((function(result){return result.done?result.value:iter.next()}))},defineIteratorMethods(Gp),define(Gp,toStringTagSymbol,"Generator"),define(Gp,iteratorSymbol,(function(){return this})),define(Gp,"toString",(function(){return"[object Generator]"})),exports.keys=function(val){var object=Object(val),keys=[];for(var key in object)keys.push(key);return keys.reverse(),function next(){for(;keys.length;){var key=keys.pop();if(key in object)return next.value=key,next.done=!1,next}return next.done=!0,next}},exports.values=values,Context.prototype={constructor:Context,reset:function reset(skipTempReset){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(resetTryEntry),!skipTempReset)for(var name in this)"t"===name.charAt(0)&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))&&(this[name]=void 0)},stop:function stop(){this.done=!0;var rootRecord=this.tryEntries[0].completion;if("throw"===rootRecord.type)throw rootRecord.arg;return this.rval},dispatchException:function dispatchException(exception){if(this.done)throw exception;var context=this;function handle(loc,caught){return record.type="throw",record.arg=exception,context.next=loc,caught&&(context.method="next",context.arg=void 0),!!caught}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i],record=entry.completion;if("root"===entry.tryLoc)return handle("end");if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc"),hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0);if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}else if(hasCatch){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0)}else{if(!hasFinally)throw new Error("try statement without catch or finally");if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}}}},abrupt:function abrupt(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break}}finallyEntry&&("break"===type||"continue"===type)&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc&&(finallyEntry=null);var record=finallyEntry?finallyEntry.completion:{};return record.type=type,record.arg=arg,finallyEntry?(this.method="next",this.next=finallyEntry.finallyLoc,ContinueSentinel):this.complete(record)},complete:function complete(record,afterLoc){if("throw"===record.type)throw record.arg;return"break"===record.type||"continue"===record.type?this.next=record.arg:"return"===record.type?(this.rval=this.arg=record.arg,this.method="return",this.next="end"):"normal"===record.type&&afterLoc&&(this.next=afterLoc),ContinueSentinel},finish:function finish(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc)return this.complete(entry.completion,entry.afterLoc),resetTryEntry(entry),ContinueSentinel}},catch:function _catch(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if("throw"===record.type){var thrown=record.arg;resetTryEntry(entry)}return thrown}}throw new Error("illegal catch attempt")},delegateYield:function delegateYield(iterable,resultName,nextLoc){return this.delegate={iterator:values(iterable),resultName,nextLoc},"next"===this.method&&(this.arg=void 0),ContinueSentinel}},exports}},"./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";function _typeof(obj){return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof(obj)}__webpack_require__.d(__webpack_exports__,{Z:()=>_typeof})},"./node_modules/deep-eql/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";var type=__webpack_require__("./node_modules/type-detect/type-detect.js");function FakeMap(){this._key="chai/deep-eql__"+Math.random()+Date.now()}FakeMap.prototype={get:function get(key){return key[this._key]},set:function set(key,value){Object.isExtensible(key)&&Object.defineProperty(key,this._key,{value,configurable:!0})}};var MemoizeMap="function"==typeof WeakMap?WeakMap:FakeMap;function memoizeCompare(leftHandOperand,rightHandOperand,memoizeMap){if(!memoizeMap||isPrimitive(leftHandOperand)||isPrimitive(rightHandOperand))return null;var leftHandMap=memoizeMap.get(leftHandOperand);if(leftHandMap){var result=leftHandMap.get(rightHandOperand);if("boolean"==typeof result)return result}return null}function memoizeSet(leftHandOperand,rightHandOperand,memoizeMap,result){if(memoizeMap&&!isPrimitive(leftHandOperand)&&!isPrimitive(rightHandOperand)){var leftHandMap=memoizeMap.get(leftHandOperand);leftHandMap?leftHandMap.set(rightHandOperand,result):((leftHandMap=new MemoizeMap).set(rightHandOperand,result),memoizeMap.set(leftHandOperand,leftHandMap))}}function deepEqual(leftHandOperand,rightHandOperand,options){if(options&&options.comparator)return extensiveDeepEqual(leftHandOperand,rightHandOperand,options);var simpleResult=simpleEqual(leftHandOperand,rightHandOperand);return null!==simpleResult?simpleResult:extensiveDeepEqual(leftHandOperand,rightHandOperand,options)}function simpleEqual(leftHandOperand,rightHandOperand){return leftHandOperand===rightHandOperand?0!==leftHandOperand||1/leftHandOperand==1/rightHandOperand:leftHandOperand!=leftHandOperand&&rightHandOperand!=rightHandOperand||!isPrimitive(leftHandOperand)&&!isPrimitive(rightHandOperand)&&null}function extensiveDeepEqual(leftHandOperand,rightHandOperand,options){(options=options||{}).memoize=!1!==options.memoize&&(options.memoize||new MemoizeMap);var comparator=options&&options.comparator,memoizeResultLeft=memoizeCompare(leftHandOperand,rightHandOperand,options.memoize);if(null!==memoizeResultLeft)return memoizeResultLeft;var memoizeResultRight=memoizeCompare(rightHandOperand,leftHandOperand,options.memoize);if(null!==memoizeResultRight)return memoizeResultRight;if(comparator){var comparatorResult=comparator(leftHandOperand,rightHandOperand);if(!1===comparatorResult||!0===comparatorResult)return memoizeSet(leftHandOperand,rightHandOperand,options.memoize,comparatorResult),comparatorResult;var simpleResult=simpleEqual(leftHandOperand,rightHandOperand);if(null!==simpleResult)return simpleResult}var leftHandType=type(leftHandOperand);if(leftHandType!==type(rightHandOperand))return memoizeSet(leftHandOperand,rightHandOperand,options.memoize,!1),!1;memoizeSet(leftHandOperand,rightHandOperand,options.memoize,!0);var result=function extensiveDeepEqualByType(leftHandOperand,rightHandOperand,leftHandType,options){switch(leftHandType){case"String":case"Number":case"Boolean":case"Date":return deepEqual(leftHandOperand.valueOf(),rightHandOperand.valueOf());case"Promise":case"Symbol":case"function":case"WeakMap":case"WeakSet":return leftHandOperand===rightHandOperand;case"Error":return keysEqual(leftHandOperand,rightHandOperand,["name","message","code"],options);case"Arguments":case"Int8Array":case"Uint8Array":case"Uint8ClampedArray":case"Int16Array":case"Uint16Array":case"Int32Array":case"Uint32Array":case"Float32Array":case"Float64Array":case"Array":return iterableEqual(leftHandOperand,rightHandOperand,options);case"RegExp":return function regexpEqual(leftHandOperand,rightHandOperand){return leftHandOperand.toString()===rightHandOperand.toString()}(leftHandOperand,rightHandOperand);case"Generator":return function generatorEqual(leftHandOperand,rightHandOperand,options){return iterableEqual(getGeneratorEntries(leftHandOperand),getGeneratorEntries(rightHandOperand),options)}(leftHandOperand,rightHandOperand,options);case"DataView":return iterableEqual(new Uint8Array(leftHandOperand.buffer),new Uint8Array(rightHandOperand.buffer),options);case"ArrayBuffer":return iterableEqual(new Uint8Array(leftHandOperand),new Uint8Array(rightHandOperand),options);case"Set":case"Map":return entriesEqual(leftHandOperand,rightHandOperand,options);case"Temporal.PlainDate":case"Temporal.PlainTime":case"Temporal.PlainDateTime":case"Temporal.Instant":case"Temporal.ZonedDateTime":case"Temporal.PlainYearMonth":case"Temporal.PlainMonthDay":return leftHandOperand.equals(rightHandOperand);case"Temporal.Duration":return leftHandOperand.total("nanoseconds")===rightHandOperand.total("nanoseconds");case"Temporal.TimeZone":case"Temporal.Calendar":return leftHandOperand.toString()===rightHandOperand.toString();default:return function objectEqual(leftHandOperand,rightHandOperand,options){var leftHandKeys=getEnumerableKeys(leftHandOperand),rightHandKeys=getEnumerableKeys(rightHandOperand),leftHandSymbols=getEnumerableSymbols(leftHandOperand),rightHandSymbols=getEnumerableSymbols(rightHandOperand);if(leftHandKeys=leftHandKeys.concat(leftHandSymbols),rightHandKeys=rightHandKeys.concat(rightHandSymbols),leftHandKeys.length&&leftHandKeys.length===rightHandKeys.length)return!1!==iterableEqual(mapSymbols(leftHandKeys).sort(),mapSymbols(rightHandKeys).sort())&&keysEqual(leftHandOperand,rightHandOperand,leftHandKeys,options);var leftHandEntries=getIteratorEntries(leftHandOperand),rightHandEntries=getIteratorEntries(rightHandOperand);if(leftHandEntries.length&&leftHandEntries.length===rightHandEntries.length)return leftHandEntries.sort(),rightHandEntries.sort(),iterableEqual(leftHandEntries,rightHandEntries,options);if(0===leftHandKeys.length&&0===leftHandEntries.length&&0===rightHandKeys.length&&0===rightHandEntries.length)return!0;return!1}(leftHandOperand,rightHandOperand,options)}}(leftHandOperand,rightHandOperand,leftHandType,options);return memoizeSet(leftHandOperand,rightHandOperand,options.memoize,result),result}function entriesEqual(leftHandOperand,rightHandOperand,options){if(leftHandOperand.size!==rightHandOperand.size)return!1;if(0===leftHandOperand.size)return!0;var leftHandItems=[],rightHandItems=[];return leftHandOperand.forEach((function gatherEntries(key,value){leftHandItems.push([key,value])})),rightHandOperand.forEach((function gatherEntries(key,value){rightHandItems.push([key,value])})),iterableEqual(leftHandItems.sort(),rightHandItems.sort(),options)}function iterableEqual(leftHandOperand,rightHandOperand,options){var length=leftHandOperand.length;if(length!==rightHandOperand.length)return!1;if(0===length)return!0;for(var index=-1;++index<length;)if(!1===deepEqual(leftHandOperand[index],rightHandOperand[index],options))return!1;return!0}function getIteratorEntries(target){if(function hasIteratorFunction(target){return"undefined"!=typeof Symbol&&"object"==typeof target&&void 0!==Symbol.iterator&&"function"==typeof target[Symbol.iterator]}(target))try{return getGeneratorEntries(target[Symbol.iterator]())}catch(iteratorError){return[]}return[]}function getGeneratorEntries(generator){for(var generatorResult=generator.next(),accumulator=[generatorResult.value];!1===generatorResult.done;)generatorResult=generator.next(),accumulator.push(generatorResult.value);return accumulator}function getEnumerableKeys(target){var keys=[];for(var key in target)keys.push(key);return keys}function getEnumerableSymbols(target){for(var keys=[],allKeys=Object.getOwnPropertySymbols(target),i=0;i<allKeys.length;i+=1){var key=allKeys[i];Object.getOwnPropertyDescriptor(target,key).enumerable&&keys.push(key)}return keys}function keysEqual(leftHandOperand,rightHandOperand,keys,options){var length=keys.length;if(0===length)return!0;for(var i=0;i<length;i+=1)if(!1===deepEqual(leftHandOperand[keys[i]],rightHandOperand[keys[i]],options))return!1;return!0}function isPrimitive(value){return null===value||"object"!=typeof value}function mapSymbols(arr){return arr.map((function mapSymbol(entry){return"symbol"==typeof entry?entry.toString():entry}))}module.exports=deepEqual,module.exports.MemoizeMap=MemoizeMap},"./node_modules/react-particles/esm/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Z:()=>esm});var react=__webpack_require__("./node_modules/react/index.js"),Constants=__webpack_require__("./node_modules/tsparticles-engine/esm/Core/Utils/Constants.js"),Utils=__webpack_require__("./node_modules/tsparticles-engine/esm/Utils/Utils.js"),NumberUtils=__webpack_require__("./node_modules/tsparticles-engine/esm/Utils/NumberUtils.js");const randomColorValue="random",colorManagers=new Map;function addColorManager(manager){colorManagers.set(manager.key,manager)}function hue2rgb(p,q,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?p+6*(q-p)*t:t<.5?q:t<2/3?p+(q-p)*(2/3-t)*6:p}function stringToRgba(input){for(const[,manager]of colorManagers)if(input.startsWith(manager.stringPrefix))return manager.parseString(input);const hexFixed=input.replace(/^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i,((_,r,g,b,a)=>r+r+g+g+b+b+(void 0!==a?a+a:""))),result=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(hexFixed);return result?{a:void 0!==result[4]?parseInt(result[4],16)/255:1,b:parseInt(result[3],16),g:parseInt(result[2],16),r:parseInt(result[1],16)}:void 0}function rangeColorToRgb(input,index,useIndex=!0){if(!input)return;const color=(0,Utils.HD)(input)?{value:input}:input;if((0,Utils.HD)(color.value))return colorToRgb(color.value,index,useIndex);if((0,Utils.kJ)(color.value))return rangeColorToRgb({value:(0,Utils.c8)(color.value,index,useIndex)});for(const[,manager]of colorManagers){const res=manager.handleRangeColor(color);if(res)return res}}function colorToRgb(input,index,useIndex=!0){if(!input)return;const color=(0,Utils.HD)(input)?{value:input}:input;if((0,Utils.HD)(color.value))return color.value===randomColorValue?getRandomRgbColor():function stringToRgb(input){return stringToRgba(input)}(color.value);if((0,Utils.kJ)(color.value))return colorToRgb({value:(0,Utils.c8)(color.value,index,useIndex)});for(const[,manager]of colorManagers){const res=manager.handleColor(color);if(res)return res}}function rangeColorToHsl(color,index,useIndex=!0){const rgb=rangeColorToRgb(color,index,useIndex);return rgb?rgbToHsl(rgb):void 0}function rgbToHsl(color){const r1=color.r/255,g1=color.g/255,b1=color.b/255,max=Math.max(r1,g1,b1),min=Math.min(r1,g1,b1),res={h:0,l:(max+min)/2,s:0};return max!==min&&(res.s=res.l<.5?(max-min)/(max+min):(max-min)/(2-max-min),res.h=r1===max?(g1-b1)/(max-min):res.h=g1===max?2+(b1-r1)/(max-min):4+(r1-g1)/(max-min)),res.l*=100,res.s*=100,res.h*=60,res.h<0&&(res.h+=360),res.h>=360&&(res.h-=360),res}function hslToRgb(hsl){const result={b:0,g:0,r:0},hslPercent={h:hsl.h/360,l:hsl.l/100,s:hsl.s/100};if(hslPercent.s){const q=hslPercent.l<.5?hslPercent.l*(1+hslPercent.s):hslPercent.l+hslPercent.s-hslPercent.l*hslPercent.s,p=2*hslPercent.l-q;result.r=hue2rgb(p,q,hslPercent.h+1/3),result.g=hue2rgb(p,q,hslPercent.h),result.b=hue2rgb(p,q,hslPercent.h-1/3)}else result.r=result.g=result.b=hslPercent.l;return result.r=Math.floor(255*result.r),result.g=Math.floor(255*result.g),result.b=Math.floor(255*result.b),result}function getRandomRgbColor(min){const fixedMin=min??0;return{b:Math.floor((0,NumberUtils.vd)((0,NumberUtils.Cs)(fixedMin,256))),g:Math.floor((0,NumberUtils.vd)((0,NumberUtils.Cs)(fixedMin,256))),r:Math.floor((0,NumberUtils.vd)((0,NumberUtils.Cs)(fixedMin,256)))}}function getStyleFromRgb(color,opacity){return`rgba(${color.r}, ${color.g}, ${color.b}, ${opacity??1})`}function getStyleFromHsl(color,opacity){return`hsla(${color.h}, ${color.s}%, ${color.l}%, ${opacity??1})`}function getHslFromAnimation(animation){return void 0!==animation?{h:animation.h.value,s:animation.s.value,l:animation.l.value}:void 0}function clear(context,dimension){context.clearRect(0,0,dimension.width,dimension.height)}function setTransformValue(factor,newFactor,key){const newValue=newFactor[key];void 0!==newValue&&(factor[key]=(factor[key]??1)*newValue)}class Canvas{constructor(container){this.container=container,this._applyPostDrawUpdaters=particle=>{for(const updater of this._postDrawUpdaters)updater.afterDraw&&updater.afterDraw(particle)},this._applyPreDrawUpdaters=(ctx,particle,radius,zOpacity,colorStyles,transform)=>{for(const updater of this._preDrawUpdaters){if(updater.getColorStyles){const{fill,stroke}=updater.getColorStyles(particle,ctx,radius,zOpacity);fill&&(colorStyles.fill=fill),stroke&&(colorStyles.stroke=stroke)}if(updater.getTransformValues){const updaterTransform=updater.getTransformValues(particle);for(const key in updaterTransform)setTransformValue(transform,updaterTransform,key)}updater.beforeDraw&&updater.beforeDraw(particle)}},this._applyResizePlugins=()=>{for(const plugin of this._resizePlugins)plugin.resize&&plugin.resize()},this._getPluginParticleColors=particle=>{let fColor,sColor;for(const plugin of this._colorPlugins)if(!fColor&&plugin.particleFillColor&&(fColor=rangeColorToHsl(plugin.particleFillColor(particle))),!sColor&&plugin.particleStrokeColor&&(sColor=rangeColorToHsl(plugin.particleStrokeColor(particle))),fColor&&sColor)break;return[fColor,sColor]},this._initCover=()=>{const cover=this.container.actualOptions.backgroundMask.cover,coverRgb=rangeColorToRgb(cover.color);if(coverRgb){const coverColor={...coverRgb,a:cover.opacity};this._coverColorStyle=getStyleFromRgb(coverColor,coverColor.a)}},this._initStyle=()=>{const element=this.element,options=this.container.actualOptions;if(element){this._fullScreen?(this._originalStyle=(0,Utils.ZB)({},element.style),this._setFullScreenStyle()):this._resetOriginalStyle();for(const key in options.style){if(!key||!options.style)continue;const value=options.style[key];value&&element.style.setProperty(key,value,"important")}}},this._initTrail=async()=>{const options=this.container.actualOptions,trail=options.particles.move.trail,trailFill=trail.fill;if(trail.enable)if(trailFill.color){const fillColor=rangeColorToRgb(trailFill.color);if(!fillColor)return;const trail=options.particles.move.trail;this._trailFill={color:{...fillColor},opacity:1/trail.length}}else await new Promise(((resolve,reject)=>{if(!trailFill.image)return;const img=document.createElement("img");img.addEventListener("load",(()=>{this._trailFill={image:img,opacity:1/trail.length},resolve()})),img.addEventListener("error",(evt=>{reject(evt.error)})),img.src=trailFill.image}))},this._paintBase=baseColor=>{this.draw((ctx=>function paintBase(context,dimension,baseColor){context.fillStyle=baseColor??"rgba(0,0,0,0)",context.fillRect(0,0,dimension.width,dimension.height)}(ctx,this.size,baseColor)))},this._paintImage=(image,opacity)=>{this.draw((ctx=>function paintImage(context,dimension,image,opacity){image&&(context.globalAlpha=opacity,context.drawImage(image,0,0,dimension.width,dimension.height),context.globalAlpha=1)}(ctx,this.size,image,opacity)))},this._repairStyle=()=>{const element=this.element;element&&(this._safeMutationObserver((observer=>observer.disconnect())),this._initStyle(),this.initBackground(),this._safeMutationObserver((observer=>observer.observe(element,{attributes:!0}))))},this._resetOriginalStyle=()=>{const element=this.element,originalStyle=this._originalStyle;if(!element||!originalStyle)return;const style=element.style;style.position=originalStyle.position,style.zIndex=originalStyle.zIndex,style.top=originalStyle.top,style.left=originalStyle.left,style.width=originalStyle.width,style.height=originalStyle.height},this._safeMutationObserver=callback=>{this._mutationObserver&&callback(this._mutationObserver)},this._setFullScreenStyle=()=>{const element=this.element;if(!element)return;const style=element.style;style.setProperty("position","fixed","important"),style.setProperty("z-index",this.container.actualOptions.fullScreen.zIndex.toString(10),"important"),style.setProperty("top","0","important"),style.setProperty("left","0","important"),style.setProperty("width","100%","important"),style.setProperty("height","100%","important")},this.size={height:0,width:0},this._context=null,this._generated=!1,this._preDrawUpdaters=[],this._postDrawUpdaters=[],this._resizePlugins=[],this._colorPlugins=[]}get _fullScreen(){return this.container.actualOptions.fullScreen.enable}clear(){const options=this.container.actualOptions,trail=options.particles.move.trail,trailFill=this._trailFill;options.backgroundMask.enable?this.paint():trail.enable&&trail.length>0&&trailFill?trailFill.color?this._paintBase(getStyleFromRgb(trailFill.color,trailFill.opacity)):trailFill.image&&this._paintImage(trailFill.image,trailFill.opacity):this.draw((ctx=>{clear(ctx,this.size)}))}destroy(){if(this.stop(),this._generated){const element=this.element;element&&element.remove()}else this._resetOriginalStyle();this._preDrawUpdaters=[],this._postDrawUpdaters=[],this._resizePlugins=[],this._colorPlugins=[]}draw(cb){const ctx=this._context;if(ctx)return cb(ctx)}drawParticle(particle,delta){if(particle.spawning||particle.destroyed)return;const radius=particle.getRadius();if(radius<=0)return;const pfColor=particle.getFillColor(),psColor=particle.getStrokeColor()??pfColor;let[fColor,sColor]=this._getPluginParticleColors(particle);fColor||(fColor=pfColor),sColor||(sColor=psColor),(fColor||sColor)&&this.draw((ctx=>{const container=this.container,options=container.actualOptions,zIndexOptions=particle.options.zIndex,zOpacityFactor=(1-particle.zIndexFactor)**zIndexOptions.opacityRate,opacity=particle.bubble.opacity??particle.opacity?.value??1,zOpacity=opacity*zOpacityFactor,zStrokeOpacity=(particle.strokeOpacity??opacity)*zOpacityFactor,transform={},colorStyles={fill:fColor?getStyleFromHsl(fColor,zOpacity):void 0};colorStyles.stroke=sColor?getStyleFromHsl(sColor,zStrokeOpacity):colorStyles.fill,this._applyPreDrawUpdaters(ctx,particle,radius,zOpacity,colorStyles,transform),function drawParticle(data){const{container,context,particle,delta,colorStyles,backgroundMask,composite,radius,opacity,shadow,transform}=data,pos=particle.getPosition(),angle=particle.rotation+(particle.pathRotation?particle.velocity.angle:0),rotateData_sin=Math.sin(angle),rotateData_cos=Math.cos(angle),transformData={a:rotateData_cos*(transform.a??1),b:rotateData_sin*(transform.b??1),c:-rotateData_sin*(transform.c??1),d:rotateData_cos*(transform.d??1)};context.setTransform(transformData.a,transformData.b,transformData.c,transformData.d,pos.x,pos.y),context.beginPath(),backgroundMask&&(context.globalCompositeOperation=composite);const shadowColor=particle.shadowColor;shadow.enable&&shadowColor&&(context.shadowBlur=shadow.blur,context.shadowColor=getStyleFromRgb(shadowColor),context.shadowOffsetX=shadow.offset.x,context.shadowOffsetY=shadow.offset.y),colorStyles.fill&&(context.fillStyle=colorStyles.fill);const strokeWidth=particle.strokeWidth??0;context.lineWidth=strokeWidth,colorStyles.stroke&&(context.strokeStyle=colorStyles.stroke),function drawShape(container,context,particle,radius,opacity,delta){if(!particle.shape)return;const drawer=container.drawers.get(particle.shape);drawer&&drawer.draw(context,particle,radius,opacity,delta,container.retina.pixelRatio)}(container,context,particle,radius,opacity,delta),strokeWidth>0&&context.stroke(),particle.close&&context.closePath(),particle.fill&&context.fill(),function drawShapeAfterEffect(container,context,particle,radius,opacity,delta){if(!particle.shape)return;const drawer=container.drawers.get(particle.shape);drawer&&drawer.afterEffect&&drawer.afterEffect(context,particle,radius,opacity,delta,container.retina.pixelRatio)}(container,context,particle,radius,opacity,delta),context.globalCompositeOperation="source-over",context.setTransform(1,0,0,1,0,0)}({container,context:ctx,particle,delta,colorStyles,backgroundMask:options.backgroundMask.enable,composite:options.backgroundMask.composite,radius:radius*(1-particle.zIndexFactor)**zIndexOptions.sizeRate,opacity:zOpacity,shadow:particle.options.shadow,transform}),this._applyPostDrawUpdaters(particle)}))}drawParticlePlugin(plugin,particle,delta){this.draw((ctx=>function drawParticlePlugin(context,plugin,particle,delta){plugin.drawParticle&&plugin.drawParticle(context,particle,delta)}(ctx,plugin,particle,delta)))}drawPlugin(plugin,delta){this.draw((ctx=>function drawPlugin(context,plugin,delta){plugin.draw&&plugin.draw(context,delta)}(ctx,plugin,delta)))}async init(){this._safeMutationObserver((obs=>obs.disconnect())),this._mutationObserver=(0,Utils.yf)((records=>{for(const record of records)"attributes"===record.type&&"style"===record.attributeName&&this._repairStyle()})),this.resize(),this._initStyle(),this._initCover();try{await this._initTrail()}catch(e){(0,Utils.jl)().error(e)}this.initBackground(),this._safeMutationObserver((obs=>{this.element&&obs.observe(this.element,{attributes:!0})})),this.initUpdaters(),this.initPlugins(),this.paint()}initBackground(){const background=this.container.actualOptions.background,element=this.element;if(!element)return;const elementStyle=element.style;if(elementStyle){if(background.color){const color=rangeColorToRgb(background.color);elementStyle.backgroundColor=color?getStyleFromRgb(color,background.opacity):""}else elementStyle.backgroundColor="";elementStyle.backgroundImage=background.image||"",elementStyle.backgroundPosition=background.position||"",elementStyle.backgroundRepeat=background.repeat||"",elementStyle.backgroundSize=background.size||""}}initPlugins(){this._resizePlugins=[];for(const[,plugin]of this.container.plugins)plugin.resize&&this._resizePlugins.push(plugin),(plugin.particleFillColor||plugin.particleStrokeColor)&&this._colorPlugins.push(plugin)}initUpdaters(){this._preDrawUpdaters=[],this._postDrawUpdaters=[];for(const updater of this.container.particles.updaters)updater.afterDraw&&this._postDrawUpdaters.push(updater),(updater.getColorStyles||updater.getTransformValues||updater.beforeDraw)&&this._preDrawUpdaters.push(updater)}loadCanvas(canvas){this._generated&&this.element&&this.element.remove(),this._generated=canvas.dataset&&Constants.YU in canvas.dataset?"true"===canvas.dataset[Constants.YU]:this._generated,this.element=canvas,this.element.ariaHidden="true",this._originalStyle=(0,Utils.ZB)({},this.element.style),this.size.height=canvas.offsetHeight,this.size.width=canvas.offsetWidth,this._context=this.element.getContext("2d"),this._safeMutationObserver((obs=>{this.element&&obs.observe(this.element,{attributes:!0})})),this.container.retina.init(),this.initBackground()}paint(){const options=this.container.actualOptions;this.draw((ctx=>{options.backgroundMask.enable&&options.backgroundMask.cover?(clear(ctx,this.size),this._paintBase(this._coverColorStyle)):this._paintBase()}))}resize(){if(!this.element)return!1;const container=this.container,pxRatio=container.retina.pixelRatio,size=container.canvas.size,newSize_width=this.element.offsetWidth*pxRatio,newSize_height=this.element.offsetHeight*pxRatio;if(newSize_height===size.height&&newSize_width===size.width&&newSize_height===this.element.height&&newSize_width===this.element.width)return!1;const oldSize={...size};return this.element.width=size.width=this.element.offsetWidth*pxRatio,this.element.height=size.height=this.element.offsetHeight*pxRatio,this.container.started&&(this.resizeFactor={width:size.width/oldSize.width,height:size.height/oldSize.height}),!0}stop(){this._safeMutationObserver((obs=>obs.disconnect())),this._mutationObserver=void 0,this.draw((ctx=>clear(ctx,this.size)))}async windowResize(){if(!this.element||!this.resize())return;const container=this.container,needsRefresh=container.updateActualOptions();container.particles.setDensity(),this._applyResizePlugins(),needsRefresh&&await container.refresh()}}function manageListener(element,event,handler,add,options){if(add){let addOptions={passive:!0};(0,Utils.jn)(options)?addOptions.capture=options:void 0!==options&&(addOptions=options),element.addEventListener(event,handler,addOptions)}else{const removeOptions=options;element.removeEventListener(event,handler,removeOptions)}}class EventListeners{constructor(container){this.container=container,this._doMouseTouchClick=e=>{const container=this.container,options=container.actualOptions;if(this._canPush){const mouseInteractivity=container.interactivity.mouse,mousePos=mouseInteractivity.position;if(!mousePos)return;mouseInteractivity.clickPosition={...mousePos},mouseInteractivity.clickTime=(new Date).getTime();const onClick=options.interactivity.events.onClick;(0,Utils.KH)(onClick.mode,(mode=>this.container.handleClickMode(mode)))}"touchend"===e.type&&setTimeout((()=>this._mouseTouchFinish()),500)},this._handleThemeChange=e=>{const mediaEvent=e,container=this.container,options=container.options,defaultThemes=options.defaultThemes,themeName=mediaEvent.matches?defaultThemes.dark:defaultThemes.light,theme=options.themes.find((theme=>theme.name===themeName));theme&&theme.default.auto&&container.loadTheme(themeName)},this._handleVisibilityChange=()=>{const container=this.container,options=container.actualOptions;this._mouseTouchFinish(),options.pauseOnBlur&&(document&&document.hidden?(container.pageHidden=!0,container.pause()):(container.pageHidden=!1,container.getAnimationStatus()?container.play(!0):container.draw(!0)))},this._handleWindowResize=async()=>{this._resizeTimeout&&(clearTimeout(this._resizeTimeout),delete this._resizeTimeout),this._resizeTimeout=setTimeout((async()=>{const canvas=this.container.canvas;canvas&&await canvas.windowResize()}),1e3*this.container.actualOptions.interactivity.events.resize.delay)},this._manageInteractivityListeners=(mouseLeaveTmpEvent,add)=>{const handlers=this._handlers,container=this.container,options=container.actualOptions,interactivityEl=container.interactivity.element;if(!interactivityEl)return;const html=interactivityEl,canvasEl=container.canvas.element;canvasEl&&(canvasEl.style.pointerEvents=html===canvasEl?"initial":"none"),(options.interactivity.events.onHover.enable||options.interactivity.events.onClick.enable)&&(manageListener(interactivityEl,Constants.Wt,handlers.mouseMove,add),manageListener(interactivityEl,Constants.Re,handlers.touchStart,add),manageListener(interactivityEl,Constants.zX,handlers.touchMove,add),options.interactivity.events.onClick.enable?(manageListener(interactivityEl,Constants.$o,handlers.touchEndClick,add),manageListener(interactivityEl,Constants.zw,handlers.mouseUp,add),manageListener(interactivityEl,Constants.ZL,handlers.mouseDown,add)):manageListener(interactivityEl,Constants.$o,handlers.touchEnd,add),manageListener(interactivityEl,mouseLeaveTmpEvent,handlers.mouseLeave,add),manageListener(interactivityEl,Constants.VH,handlers.touchCancel,add))},this._manageListeners=add=>{const handlers=this._handlers,container=this.container,detectType=container.actualOptions.interactivity.detectsOn,canvasEl=container.canvas.element;let mouseLeaveTmpEvent=Constants.aM;"window"===detectType?(container.interactivity.element=window,mouseLeaveTmpEvent=Constants.G1):container.interactivity.element="parent"===detectType&&canvasEl?canvasEl.parentElement??canvasEl.parentNode:canvasEl,this._manageMediaMatch(add),this._manageResize(add),this._manageInteractivityListeners(mouseLeaveTmpEvent,add),document&&manageListener(document,Constants.QL,handlers.visibilityChange,add,!1)},this._manageMediaMatch=add=>{const handlers=this._handlers,mediaMatch=(0,Utils.HY)("(prefers-color-scheme: dark)");mediaMatch&&(void 0===mediaMatch.addEventListener?void 0!==mediaMatch.addListener&&(add?mediaMatch.addListener(handlers.oldThemeChange):mediaMatch.removeListener(handlers.oldThemeChange)):manageListener(mediaMatch,"change",handlers.themeChange,add))},this._manageResize=add=>{const handlers=this._handlers,container=this.container;if(!container.actualOptions.interactivity.events.resize)return;if("undefined"==typeof ResizeObserver)return void manageListener(window,Constants.rR,handlers.resize,add);const canvasEl=container.canvas.element;this._resizeObserver&&!add?(canvasEl&&this._resizeObserver.unobserve(canvasEl),this._resizeObserver.disconnect(),delete this._resizeObserver):!this._resizeObserver&&add&&canvasEl&&(this._resizeObserver=new ResizeObserver((async entries=>{entries.find((e=>e.target===canvasEl))&&await this._handleWindowResize()})),this._resizeObserver.observe(canvasEl))},this._mouseDown=()=>{const{interactivity}=this.container;if(!interactivity)return;const{mouse}=interactivity;mouse.clicking=!0,mouse.downPosition=mouse.position},this._mouseTouchClick=e=>{const container=this.container,options=container.actualOptions,{mouse}=container.interactivity;mouse.inside=!0;let handled=!1;const mousePosition=mouse.position;if(mousePosition&&options.interactivity.events.onClick.enable){for(const[,plugin]of container.plugins)if(plugin.clickPositionValid&&(handled=plugin.clickPositionValid(mousePosition),handled))break;handled||this._doMouseTouchClick(e),mouse.clicking=!1}},this._mouseTouchFinish=()=>{const interactivity=this.container.interactivity;if(!interactivity)return;const mouse=interactivity.mouse;delete mouse.position,delete mouse.clickPosition,delete mouse.downPosition,interactivity.status=Constants.aM,mouse.inside=!1,mouse.clicking=!1},this._mouseTouchMove=e=>{const container=this.container,options=container.actualOptions,interactivity=container.interactivity,canvasEl=container.canvas.element;if(!interactivity||!interactivity.element)return;let pos;if(interactivity.mouse.inside=!0,e.type.startsWith("pointer")){this._canPush=!0;const mouseEvent=e;if(interactivity.element===window){if(canvasEl){const clientRect=canvasEl.getBoundingClientRect();pos={x:mouseEvent.clientX-clientRect.left,y:mouseEvent.clientY-clientRect.top}}}else if("parent"===options.interactivity.detectsOn){const source=mouseEvent.target,target=mouseEvent.currentTarget;if(source&&target&&canvasEl){const sourceRect=source.getBoundingClientRect(),targetRect=target.getBoundingClientRect(),canvasRect=canvasEl.getBoundingClientRect();pos={x:mouseEvent.offsetX+2*sourceRect.left-(targetRect.left+canvasRect.left),y:mouseEvent.offsetY+2*sourceRect.top-(targetRect.top+canvasRect.top)}}else pos={x:mouseEvent.offsetX??mouseEvent.clientX,y:mouseEvent.offsetY??mouseEvent.clientY}}else mouseEvent.target===canvasEl&&(pos={x:mouseEvent.offsetX??mouseEvent.clientX,y:mouseEvent.offsetY??mouseEvent.clientY})}else if(this._canPush="touchmove"!==e.type,canvasEl){const touchEvent=e,lastTouch=touchEvent.touches[touchEvent.touches.length-1],canvasRect=canvasEl.getBoundingClientRect();pos={x:lastTouch.clientX-(canvasRect.left??0),y:lastTouch.clientY-(canvasRect.top??0)}}const pxRatio=container.retina.pixelRatio;pos&&(pos.x*=pxRatio,pos.y*=pxRatio),interactivity.mouse.position=pos,interactivity.status=Constants.Wt},this._touchEnd=e=>{const evt=e,touches=Array.from(evt.changedTouches);for(const touch of touches)this._touches.delete(touch.identifier);this._mouseTouchFinish()},this._touchEndClick=e=>{const evt=e,touches=Array.from(evt.changedTouches);for(const touch of touches)this._touches.delete(touch.identifier);this._mouseTouchClick(e)},this._touchStart=e=>{const evt=e,touches=Array.from(evt.changedTouches);for(const touch of touches)this._touches.set(touch.identifier,performance.now());this._mouseTouchMove(e)},this._canPush=!0,this._touches=new Map,this._handlers={mouseDown:()=>this._mouseDown(),mouseLeave:()=>this._mouseTouchFinish(),mouseMove:e=>this._mouseTouchMove(e),mouseUp:e=>this._mouseTouchClick(e),touchStart:e=>this._touchStart(e),touchMove:e=>this._mouseTouchMove(e),touchEnd:e=>this._touchEnd(e),touchCancel:e=>this._touchEnd(e),touchEndClick:e=>this._touchEndClick(e),visibilityChange:()=>this._handleVisibilityChange(),themeChange:e=>this._handleThemeChange(e),oldThemeChange:e=>this._handleThemeChange(e),resize:()=>{this._handleWindowResize()}}}addListeners(){this._manageListeners(!0)}removeListeners(){this._manageListeners(!1)}}class OptionsColor{constructor(){this.value=""}static create(source,data){const color=new OptionsColor;return color.load(source),void 0!==data&&((0,Utils.HD)(data)||(0,Utils.kJ)(data)?color.load({value:data}):color.load(data)),color}load(data){void 0!==data?.value&&(this.value=data.value)}}class Background{constructor(){this.color=new OptionsColor,this.color.value="",this.image="",this.position="",this.repeat="",this.size="",this.opacity=1}load(data){data&&(void 0!==data.color&&(this.color=OptionsColor.create(this.color,data.color)),void 0!==data.image&&(this.image=data.image),void 0!==data.position&&(this.position=data.position),void 0!==data.repeat&&(this.repeat=data.repeat),void 0!==data.size&&(this.size=data.size),void 0!==data.opacity&&(this.opacity=data.opacity))}}class BackgroundMaskCover{constructor(){this.color=new OptionsColor,this.color.value="#fff",this.opacity=1}load(data){data&&(void 0!==data.color&&(this.color=OptionsColor.create(this.color,data.color)),void 0!==data.opacity&&(this.opacity=data.opacity))}}class BackgroundMask{constructor(){this.composite="destination-out",this.cover=new BackgroundMaskCover,this.enable=!1}load(data){if(data){if(void 0!==data.composite&&(this.composite=data.composite),void 0!==data.cover){const cover=data.cover,color=(0,Utils.HD)(data.cover)?{color:data.cover}:data.cover;this.cover.load(void 0!==cover.color?cover:{color})}void 0!==data.enable&&(this.enable=data.enable)}}}class FullScreen{constructor(){this.enable=!0,this.zIndex=0}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.zIndex&&(this.zIndex=data.zIndex))}}class ClickEvent{constructor(){this.enable=!1,this.mode=[]}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.mode&&(this.mode=data.mode))}}class DivEvent{constructor(){this.selectors=[],this.enable=!1,this.mode=[],this.type="circle"}get el(){return this.elementId}set el(value){this.elementId=value}get elementId(){return this.ids}set elementId(value){this.ids=value}get ids(){return(0,Utils.KH)(this.selectors,(t=>t.replace("#","")))}set ids(value){this.selectors=(0,Utils.KH)(value,(t=>`#${t}`))}load(data){if(!data)return;const ids=data.ids??data.elementId??data.el;void 0!==ids&&(this.ids=ids),void 0!==data.selectors&&(this.selectors=data.selectors),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.mode&&(this.mode=data.mode),void 0!==data.type&&(this.type=data.type)}}class Parallax{constructor(){this.enable=!1,this.force=2,this.smooth=10}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.force&&(this.force=data.force),void 0!==data.smooth&&(this.smooth=data.smooth))}}class HoverEvent{constructor(){this.enable=!1,this.mode=[],this.parallax=new Parallax}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.mode&&(this.mode=data.mode),this.parallax.load(data.parallax))}}class ResizeEvent{constructor(){this.delay=.5,this.enable=!0}load(data){void 0!==data&&(void 0!==data.delay&&(this.delay=data.delay),void 0!==data.enable&&(this.enable=data.enable))}}class Events{constructor(){this.onClick=new ClickEvent,this.onDiv=new DivEvent,this.onHover=new HoverEvent,this.resize=new ResizeEvent}get onclick(){return this.onClick}set onclick(value){this.onClick=value}get ondiv(){return this.onDiv}set ondiv(value){this.onDiv=value}get onhover(){return this.onHover}set onhover(value){this.onHover=value}load(data){if(!data)return;this.onClick.load(data.onClick??data.onclick);const onDiv=data.onDiv??data.ondiv;void 0!==onDiv&&(this.onDiv=(0,Utils.KH)(onDiv,(t=>{const tmp=new DivEvent;return tmp.load(t),tmp}))),this.onHover.load(data.onHover??data.onhover),(0,Utils.jn)(data.resize)?this.resize.enable=data.resize:this.resize.load(data.resize)}}class Modes{constructor(engine,container){this._engine=engine,this._container=container}load(data){if(!data)return;if(!this._container)return;const interactors=this._engine.plugins.interactors.get(this._container);if(interactors)for(const interactor of interactors)interactor.loadModeOptions&&interactor.loadModeOptions(this,data)}}class Interactivity{constructor(engine,container){this.detectsOn="window",this.events=new Events,this.modes=new Modes(engine,container)}get detect_on(){return this.detectsOn}set detect_on(value){this.detectsOn=value}load(data){if(!data)return;const detectsOn=data.detectsOn??data.detect_on;void 0!==detectsOn&&(this.detectsOn=detectsOn),this.events.load(data.events),this.modes.load(data.modes)}}class ManualParticle{load(data){data&&(data.position&&(this.position={x:data.position.x??50,y:data.position.y??50,mode:data.position.mode??"percent"}),data.options&&(this.options=(0,Utils.ZB)({},data.options)))}}class Responsive{constructor(){this.maxWidth=1/0,this.options={},this.mode="canvas"}load(data){data&&(void 0!==data.maxWidth&&(this.maxWidth=data.maxWidth),void 0!==data.mode&&("screen"===data.mode?this.mode="screen":this.mode="canvas"),void 0!==data.options&&(this.options=(0,Utils.ZB)({},data.options)))}}class ThemeDefault{constructor(){this.auto=!1,this.mode="any",this.value=!1}load(data){data&&(void 0!==data.auto&&(this.auto=data.auto),void 0!==data.mode&&(this.mode=data.mode),void 0!==data.value&&(this.value=data.value))}}class Theme{constructor(){this.name="",this.default=new ThemeDefault}load(data){data&&(void 0!==data.name&&(this.name=data.name),this.default.load(data.default),void 0!==data.options&&(this.options=(0,Utils.ZB)({},data.options)))}}class ColorAnimation{constructor(){this.count=0,this.enable=!1,this.offset=0,this.speed=1,this.delay=0,this.decay=0,this.sync=!0}load(data){data&&(void 0!==data.count&&(this.count=(0,NumberUtils.Cs)(data.count)),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.offset&&(this.offset=(0,NumberUtils.Cs)(data.offset)),void 0!==data.speed&&(this.speed=(0,NumberUtils.Cs)(data.speed)),void 0!==data.decay&&(this.decay=(0,NumberUtils.Cs)(data.decay)),void 0!==data.delay&&(this.delay=(0,NumberUtils.Cs)(data.delay)),void 0!==data.sync&&(this.sync=data.sync))}}class HslAnimation{constructor(){this.h=new ColorAnimation,this.s=new ColorAnimation,this.l=new ColorAnimation}load(data){data&&(this.h.load(data.h),this.s.load(data.s),this.l.load(data.l))}}class AnimatableColor extends OptionsColor{constructor(){super(),this.animation=new HslAnimation}static create(source,data){const color=new AnimatableColor;return color.load(source),void 0!==data&&((0,Utils.HD)(data)||(0,Utils.kJ)(data)?color.load({value:data}):color.load(data)),color}load(data){if(super.load(data),!data)return;const colorAnimation=data.animation;void 0!==colorAnimation&&(void 0!==colorAnimation.enable?this.animation.h.load(colorAnimation):this.animation.load(data.animation))}}class CollisionsAbsorb{constructor(){this.speed=2}load(data){data&&void 0!==data.speed&&(this.speed=data.speed)}}class CollisionsOverlap{constructor(){this.enable=!0,this.retries=0}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.retries&&(this.retries=data.retries))}}class Random{constructor(){this.enable=!1,this.minimumValue=0}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.minimumValue&&(this.minimumValue=data.minimumValue))}}class ValueWithRandom{constructor(){this.random=new Random,this.value=0}load(data){data&&((0,Utils.jn)(data.random)?this.random.enable=data.random:this.random.load(data.random),void 0!==data.value&&(this.value=(0,NumberUtils.Cs)(data.value,this.random.enable?this.random.minimumValue:void 0)))}}class ParticlesBounceFactor extends ValueWithRandom{constructor(){super(),this.random.minimumValue=.1,this.value=1}}class ParticlesBounce{constructor(){this.horizontal=new ParticlesBounceFactor,this.vertical=new ParticlesBounceFactor}load(data){data&&(this.horizontal.load(data.horizontal),this.vertical.load(data.vertical))}}class Collisions{constructor(){this.absorb=new CollisionsAbsorb,this.bounce=new ParticlesBounce,this.enable=!1,this.maxSpeed=50,this.mode="bounce",this.overlap=new CollisionsOverlap}load(data){data&&(this.absorb.load(data.absorb),this.bounce.load(data.bounce),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.maxSpeed&&(this.maxSpeed=(0,NumberUtils.Cs)(data.maxSpeed)),void 0!==data.mode&&(this.mode=data.mode),this.overlap.load(data.overlap))}}class MoveAngle{constructor(){this.offset=0,this.value=90}load(data){data&&(void 0!==data.offset&&(this.offset=(0,NumberUtils.Cs)(data.offset)),void 0!==data.value&&(this.value=(0,NumberUtils.Cs)(data.value)))}}class MoveAttract{constructor(){this.distance=200,this.enable=!1,this.rotate={x:3e3,y:3e3}}get rotateX(){return this.rotate.x}set rotateX(value){this.rotate.x=value}get rotateY(){return this.rotate.y}set rotateY(value){this.rotate.y=value}load(data){if(!data)return;void 0!==data.distance&&(this.distance=(0,NumberUtils.Cs)(data.distance)),void 0!==data.enable&&(this.enable=data.enable);const rotateX=data.rotate?.x??data.rotateX;void 0!==rotateX&&(this.rotate.x=rotateX);const rotateY=data.rotate?.y??data.rotateY;void 0!==rotateY&&(this.rotate.y=rotateY)}}class MoveCenter{constructor(){this.x=50,this.y=50,this.mode="percent",this.radius=0}load(data){data&&(void 0!==data.x&&(this.x=data.x),void 0!==data.y&&(this.y=data.y),void 0!==data.mode&&(this.mode=data.mode),void 0!==data.radius&&(this.radius=data.radius))}}class MoveGravity{constructor(){this.acceleration=9.81,this.enable=!1,this.inverse=!1,this.maxSpeed=50}load(data){data&&(void 0!==data.acceleration&&(this.acceleration=(0,NumberUtils.Cs)(data.acceleration)),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.inverse&&(this.inverse=data.inverse),void 0!==data.maxSpeed&&(this.maxSpeed=(0,NumberUtils.Cs)(data.maxSpeed)))}}class MovePath{constructor(){this.clamp=!0,this.delay=new ValueWithRandom,this.enable=!1,this.options={}}load(data){data&&(void 0!==data.clamp&&(this.clamp=data.clamp),this.delay.load(data.delay),void 0!==data.enable&&(this.enable=data.enable),this.generator=data.generator,data.options&&(this.options=(0,Utils.ZB)(this.options,data.options)))}}class MoveTrailFill{load(data){data&&(void 0!==data.color&&(this.color=OptionsColor.create(this.color,data.color)),void 0!==data.image&&(this.image=data.image))}}class MoveTrail{constructor(){this.enable=!1,this.length=10,this.fill=new MoveTrailFill}get fillColor(){return this.fill.color}set fillColor(value){this.fill.load({color:value})}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0===data.fill&&void 0===data.fillColor||this.fill.load(data.fill||{color:data.fillColor}),void 0!==data.length&&(this.length=data.length))}}class OutModes{constructor(){this.default="out"}load(data){data&&(void 0!==data.default&&(this.default=data.default),this.bottom=data.bottom??data.default,this.left=data.left??data.default,this.right=data.right??data.default,this.top=data.top??data.default)}}class Spin{constructor(){this.acceleration=0,this.enable=!1}load(data){data&&(void 0!==data.acceleration&&(this.acceleration=(0,NumberUtils.Cs)(data.acceleration)),void 0!==data.enable&&(this.enable=data.enable),data.position&&(this.position=(0,Utils.ZB)({},data.position)))}}class Move{constructor(){this.angle=new MoveAngle,this.attract=new MoveAttract,this.center=new MoveCenter,this.decay=0,this.distance={},this.direction="none",this.drift=0,this.enable=!1,this.gravity=new MoveGravity,this.path=new MovePath,this.outModes=new OutModes,this.random=!1,this.size=!1,this.speed=2,this.spin=new Spin,this.straight=!1,this.trail=new MoveTrail,this.vibrate=!1,this.warp=!1}get bounce(){return this.collisions}set bounce(value){this.collisions=value}get collisions(){return!1}set collisions(_){}get noise(){return this.path}set noise(value){this.path=value}get outMode(){return this.outModes.default}set outMode(value){this.outModes.default=value}get out_mode(){return this.outMode}set out_mode(value){this.outMode=value}load(data){if(!data)return;this.angle.load((0,Utils.hj)(data.angle)?{value:data.angle}:data.angle),this.attract.load(data.attract),this.center.load(data.center),void 0!==data.decay&&(this.decay=(0,NumberUtils.Cs)(data.decay)),void 0!==data.direction&&(this.direction=data.direction),void 0!==data.distance&&(this.distance=(0,Utils.hj)(data.distance)?{horizontal:data.distance,vertical:data.distance}:{...data.distance}),void 0!==data.drift&&(this.drift=(0,NumberUtils.Cs)(data.drift)),void 0!==data.enable&&(this.enable=data.enable),this.gravity.load(data.gravity);const outModes=data.outModes??data.outMode??data.out_mode;void 0!==outModes&&((0,Utils.Kn)(outModes)?this.outModes.load(outModes):this.outModes.load({default:outModes})),this.path.load(data.path??data.noise),void 0!==data.random&&(this.random=data.random),void 0!==data.size&&(this.size=data.size),void 0!==data.speed&&(this.speed=(0,NumberUtils.Cs)(data.speed)),this.spin.load(data.spin),void 0!==data.straight&&(this.straight=data.straight),this.trail.load(data.trail),void 0!==data.vibrate&&(this.vibrate=data.vibrate),void 0!==data.warp&&(this.warp=data.warp)}}class AnimationOptions_AnimationOptions{constructor(){this.count=0,this.enable=!1,this.speed=1,this.decay=0,this.delay=0,this.sync=!1}load(data){data&&(void 0!==data.count&&(this.count=(0,NumberUtils.Cs)(data.count)),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.speed&&(this.speed=(0,NumberUtils.Cs)(data.speed)),void 0!==data.decay&&(this.decay=(0,NumberUtils.Cs)(data.decay)),void 0!==data.delay&&(this.delay=(0,NumberUtils.Cs)(data.delay)),void 0!==data.sync&&(this.sync=data.sync))}}class AnimationOptions_RangedAnimationOptions extends AnimationOptions_AnimationOptions{constructor(){super(),this.mode="auto",this.startValue="random"}load(data){super.load(data),data&&(void 0!==data.minimumValue&&(this.minimumValue=data.minimumValue),void 0!==data.mode&&(this.mode=data.mode),void 0!==data.startValue&&(this.startValue=data.startValue))}}class OpacityAnimation extends AnimationOptions_RangedAnimationOptions{constructor(){super(),this.destroy="none",this.speed=2}get opacity_min(){return this.minimumValue}set opacity_min(value){this.minimumValue=value}load(data){void 0!==data?.opacity_min&&void 0===data.minimumValue&&(data.minimumValue=data.opacity_min),super.load(data),data&&void 0!==data.destroy&&(this.destroy=data.destroy)}}class Opacity extends ValueWithRandom{constructor(){super(),this.animation=new OpacityAnimation,this.random.minimumValue=.1,this.value=1}get anim(){return this.animation}set anim(value){this.animation=value}load(data){if(!data)return;super.load(data);const animation=data.animation??data.anim;void 0!==animation&&(this.animation.load(animation),this.value=(0,NumberUtils.Cs)(this.value,this.animation.enable?this.animation.minimumValue:void 0))}}class ParticlesDensity{constructor(){this.enable=!1,this.width=1920,this.height=1080}get area(){return this.width}set area(value){this.width=value}get factor(){return this.height}set factor(value){this.height=value}get value_area(){return this.area}set value_area(value){this.area=value}load(data){if(!data)return;void 0!==data.enable&&(this.enable=data.enable);const width=data.width??data.area??data.value_area;void 0!==width&&(this.width=width);const height=data.height??data.factor;void 0!==height&&(this.height=height)}}class ParticlesNumber{constructor(){this.density=new ParticlesDensity,this.limit=0,this.value=0}get max(){return this.limit}set max(value){this.limit=value}load(data){if(!data)return;this.density.load(data.density);const limit=data.limit??data.max;void 0!==limit&&(this.limit=limit),void 0!==data.value&&(this.value=data.value)}}class Shadow{constructor(){this.blur=0,this.color=new OptionsColor,this.enable=!1,this.offset={x:0,y:0},this.color.value="#000"}load(data){data&&(void 0!==data.blur&&(this.blur=data.blur),this.color=OptionsColor.create(this.color,data.color),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.offset&&(void 0!==data.offset.x&&(this.offset.x=data.offset.x),void 0!==data.offset.y&&(this.offset.y=data.offset.y)))}}class Shape{constructor(){this.loadShape=(item,mainKey,altKey,altOverride)=>{if(!item)return;const itemIsArray=(0,Utils.kJ)(item),emptyValue=itemIsArray?[]:{},mainDifferentValues=itemIsArray!==(0,Utils.kJ)(this.options[mainKey]),altDifferentValues=itemIsArray!==(0,Utils.kJ)(this.options[altKey]);mainDifferentValues&&(this.options[mainKey]=emptyValue),altDifferentValues&&altOverride&&(this.options[altKey]=emptyValue),this.options[mainKey]=(0,Utils.ZB)(this.options[mainKey]??emptyValue,item),this.options[altKey]&&!altOverride||(this.options[altKey]=(0,Utils.ZB)(this.options[altKey]??emptyValue,item))},this.close=!0,this.fill=!0,this.options={},this.type="circle"}get character(){return this.options.character??this.options.char}set character(value){this.options.char=this.options.character=value}get custom(){return this.options}set custom(value){this.options=value}get image(){return this.options.image??this.options.images}set image(value){this.options.images=this.options.image=value}get images(){return this.image}set images(value){this.image=value}get polygon(){return this.options.polygon??this.options.star}set polygon(value){this.options.star=this.options.polygon=value}get stroke(){return[]}set stroke(_value){}load(data){if(!data)return;const options=data.options??data.custom;if(void 0!==options)for(const shape in options){const item=options[shape];item&&(this.options[shape]=(0,Utils.ZB)(this.options[shape]??{},item))}this.loadShape(data.character,"character","char",!0),this.loadShape(data.polygon,"polygon","star",!1),this.loadShape(data.image??data.images,"image","images",!0),void 0!==data.close&&(this.close=data.close),void 0!==data.fill&&(this.fill=data.fill),void 0!==data.type&&(this.type=data.type)}}class SizeAnimation extends AnimationOptions_RangedAnimationOptions{constructor(){super(),this.destroy="none",this.speed=5}get size_min(){return this.minimumValue}set size_min(value){this.minimumValue=value}load(data){void 0!==data?.size_min&&void 0===data.minimumValue&&(data.minimumValue=data.size_min),super.load(data),data&&void 0!==data.destroy&&(this.destroy=data.destroy)}}class Size extends ValueWithRandom{constructor(){super(),this.animation=new SizeAnimation,this.random.minimumValue=1,this.value=3}get anim(){return this.animation}set anim(value){this.animation=value}load(data){if(super.load(data),!data)return;const animation=data.animation??data.anim;void 0!==animation&&(this.animation.load(animation),this.value=(0,NumberUtils.Cs)(this.value,this.animation.enable?this.animation.minimumValue:void 0))}}class Stroke{constructor(){this.width=0}load(data){data&&(void 0!==data.color&&(this.color=AnimatableColor.create(this.color,data.color)),void 0!==data.width&&(this.width=(0,NumberUtils.Cs)(data.width)),void 0!==data.opacity&&(this.opacity=(0,NumberUtils.Cs)(data.opacity)))}}class ZIndex extends ValueWithRandom{constructor(){super(),this.opacityRate=1,this.sizeRate=1,this.velocityRate=1}load(data){super.load(data),data&&(void 0!==data.opacityRate&&(this.opacityRate=data.opacityRate),void 0!==data.sizeRate&&(this.sizeRate=data.sizeRate),void 0!==data.velocityRate&&(this.velocityRate=data.velocityRate))}}class ParticlesOptions{constructor(engine,container){this._engine=engine,this._container=container,this.bounce=new ParticlesBounce,this.collisions=new Collisions,this.color=new AnimatableColor,this.color.value="#fff",this.groups={},this.move=new Move,this.number=new ParticlesNumber,this.opacity=new Opacity,this.reduceDuplicates=!1,this.shadow=new Shadow,this.shape=new Shape,this.size=new Size,this.stroke=new Stroke,this.zIndex=new ZIndex}load(data){if(!data)return;if(this.bounce.load(data.bounce),this.color.load(AnimatableColor.create(this.color,data.color)),void 0!==data.groups)for(const group in data.groups){const item=data.groups[group];void 0!==item&&(this.groups[group]=(0,Utils.ZB)(this.groups[group]??{},item))}this.move.load(data.move),this.number.load(data.number),this.opacity.load(data.opacity),void 0!==data.reduceDuplicates&&(this.reduceDuplicates=data.reduceDuplicates),this.shape.load(data.shape),this.size.load(data.size),this.shadow.load(data.shadow),this.zIndex.load(data.zIndex);const collisions=data.move?.collisions??data.move?.bounce;void 0!==collisions&&(this.collisions.enable=collisions),this.collisions.load(data.collisions),void 0!==data.interactivity&&(this.interactivity=(0,Utils.ZB)({},data.interactivity));const strokeToLoad=data.stroke??data.shape?.stroke;if(strokeToLoad&&(this.stroke=(0,Utils.KH)(strokeToLoad,(t=>{const tmp=new Stroke;return tmp.load(t),tmp}))),this._container){const updaters=this._engine.plugins.updaters.get(this._container);if(updaters)for(const updater of updaters)updater.loadOptions&&updater.loadOptions(this,data);const interactors=this._engine.plugins.interactors.get(this._container);if(interactors)for(const interactor of interactors)interactor.loadParticlesOptions&&interactor.loadParticlesOptions(this,data)}}}function loadOptions(options,...sourceOptionsArr){for(const sourceOptions of sourceOptionsArr)options.load(sourceOptions)}function loadParticlesOptions(engine,container,...sourceOptionsArr){const options=new ParticlesOptions(engine,container);return loadOptions(options,...sourceOptionsArr),options}class Options{constructor(engine,container){this._findDefaultTheme=mode=>this.themes.find((theme=>theme.default.value&&theme.default.mode===mode))??this.themes.find((theme=>theme.default.value&&"any"===theme.default.mode)),this._importPreset=preset=>{this.load(this._engine.plugins.getPreset(preset))},this._engine=engine,this._container=container,this.autoPlay=!0,this.background=new Background,this.backgroundMask=new BackgroundMask,this.defaultThemes={},this.delay=0,this.fullScreen=new FullScreen,this.detectRetina=!0,this.duration=0,this.fpsLimit=120,this.interactivity=new Interactivity(engine,container),this.manualParticles=[],this.particles=loadParticlesOptions(this._engine,this._container),this.pauseOnBlur=!0,this.pauseOnOutsideViewport=!0,this.responsive=[],this.smooth=!1,this.style={},this.themes=[],this.zLayers=100}get backgroundMode(){return this.fullScreen}set backgroundMode(value){this.fullScreen.load(value)}get fps_limit(){return this.fpsLimit}set fps_limit(value){this.fpsLimit=value}get retina_detect(){return this.detectRetina}set retina_detect(value){this.detectRetina=value}load(data){if(!data)return;void 0!==data.preset&&(0,Utils.KH)(data.preset,(preset=>this._importPreset(preset))),void 0!==data.autoPlay&&(this.autoPlay=data.autoPlay),void 0!==data.delay&&(this.delay=(0,NumberUtils.Cs)(data.delay));const detectRetina=data.detectRetina??data.retina_detect;void 0!==detectRetina&&(this.detectRetina=detectRetina),void 0!==data.duration&&(this.duration=(0,NumberUtils.Cs)(data.duration));const fpsLimit=data.fpsLimit??data.fps_limit;void 0!==fpsLimit&&(this.fpsLimit=fpsLimit),void 0!==data.pauseOnBlur&&(this.pauseOnBlur=data.pauseOnBlur),void 0!==data.pauseOnOutsideViewport&&(this.pauseOnOutsideViewport=data.pauseOnOutsideViewport),void 0!==data.zLayers&&(this.zLayers=data.zLayers),this.background.load(data.background);const fullScreen=data.fullScreen??data.backgroundMode;(0,Utils.jn)(fullScreen)?this.fullScreen.enable=fullScreen:this.fullScreen.load(fullScreen),this.backgroundMask.load(data.backgroundMask),this.interactivity.load(data.interactivity),data.manualParticles&&(this.manualParticles=data.manualParticles.map((t=>{const tmp=new ManualParticle;return tmp.load(t),tmp}))),this.particles.load(data.particles),this.style=(0,Utils.ZB)(this.style,data.style),this._engine.plugins.loadOptions(this,data),void 0!==data.smooth&&(this.smooth=data.smooth);const interactors=this._engine.plugins.interactors.get(this._container);if(interactors)for(const interactor of interactors)interactor.loadOptions&&interactor.loadOptions(this,data);if(void 0!==data.responsive)for(const responsive of data.responsive){const optResponsive=new Responsive;optResponsive.load(responsive),this.responsive.push(optResponsive)}if(this.responsive.sort(((a,b)=>a.maxWidth-b.maxWidth)),void 0!==data.themes)for(const theme of data.themes){const existingTheme=this.themes.find((t=>t.name===theme.name));if(existingTheme)existingTheme.load(theme);else{const optTheme=new Theme;optTheme.load(theme),this.themes.push(optTheme)}}this.defaultThemes.dark=this._findDefaultTheme("dark")?.name,this.defaultThemes.light=this._findDefaultTheme("light")?.name}setResponsive(width,pxRatio,defaultOptions){this.load(defaultOptions);const responsiveOptions=this.responsive.find((t=>"screen"===t.mode&&screen?t.maxWidth>screen.availWidth:t.maxWidth*pxRatio>width));return this.load(responsiveOptions?.options),responsiveOptions?.maxWidth}setTheme(name){if(name){const chosenTheme=this.themes.find((theme=>theme.name===name));chosenTheme&&this.load(chosenTheme.options)}else{const mediaMatch=(0,Utils.HY)("(prefers-color-scheme: dark)"),clientDarkMode=mediaMatch&&mediaMatch.matches,defaultTheme=this._findDefaultTheme(clientDarkMode?"dark":"light");defaultTheme&&this.load(defaultTheme.options)}}}class InteractionManager{constructor(engine,container){this.container=container,this._engine=engine,this._interactors=engine.plugins.getInteractors(this.container,!0),this._externalInteractors=[],this._particleInteractors=[]}async externalInteract(delta){for(const interactor of this._externalInteractors)interactor.isEnabled()&&await interactor.interact(delta)}handleClickMode(mode){for(const interactor of this._externalInteractors)interactor.handleClickMode&&interactor.handleClickMode(mode)}init(){this._externalInteractors=[],this._particleInteractors=[];for(const interactor of this._interactors){switch(interactor.type){case"external":this._externalInteractors.push(interactor);break;case"particles":this._particleInteractors.push(interactor)}interactor.init()}}async particlesInteract(particle,delta){for(const interactor of this._externalInteractors)interactor.clear(particle,delta);for(const interactor of this._particleInteractors)interactor.isEnabled(particle)&&await interactor.interact(particle,delta)}async reset(particle){for(const interactor of this._externalInteractors)interactor.isEnabled()&&interactor.reset(particle);for(const interactor of this._particleInteractors)interactor.isEnabled(particle)&&interactor.reset(particle)}}var Vector=__webpack_require__("./node_modules/tsparticles-engine/esm/Core/Utils/Vector.js"),Vector3d=__webpack_require__("./node_modules/tsparticles-engine/esm/Core/Utils/Vector3d.js");const fixOutMode=data=>{if(!(0,Utils.dB)(data.outMode,data.checkModes))return;const diameter=2*data.radius;data.coord>data.maxCoord-diameter?data.setCb(-data.radius):data.coord<diameter&&data.setCb(data.radius)};class Particle{constructor(engine,id,container,position,overrideOptions,group){this.container=container,this._calcPosition=(container,position,zIndex,tryCount=0)=>{for(const[,plugin]of container.plugins){const pluginPos=void 0!==plugin.particlePosition?plugin.particlePosition(position,this):void 0;if(pluginPos)return Vector3d.U.create(pluginPos.x,pluginPos.y,zIndex)}const canvasSize=container.canvas.size,exactPosition=(0,NumberUtils.mC)({size:canvasSize,position}),pos=Vector3d.U.create(exactPosition.x,exactPosition.y,zIndex),radius=this.getRadius(),outModes=this.options.move.outModes,fixHorizontal=outMode=>{fixOutMode({outMode,checkModes:["bounce","bounce-horizontal"],coord:pos.x,maxCoord:container.canvas.size.width,setCb:value=>pos.x+=value,radius})},fixVertical=outMode=>{fixOutMode({outMode,checkModes:["bounce","bounce-vertical"],coord:pos.y,maxCoord:container.canvas.size.height,setCb:value=>pos.y+=value,radius})};return fixHorizontal(outModes.left??outModes.default),fixHorizontal(outModes.right??outModes.default),fixVertical(outModes.top??outModes.default),fixVertical(outModes.bottom??outModes.default),this._checkOverlap(pos,tryCount)?this._calcPosition(container,void 0,zIndex,tryCount+1):pos},this._calculateVelocity=()=>{const res=(0,NumberUtils.lQ)(this.direction).copy(),moveOptions=this.options.move;if("inside"===moveOptions.direction||"outside"===moveOptions.direction)return res;const rad=Math.PI/180*(0,NumberUtils.Gu)(moveOptions.angle.value),radOffset=Math.PI/180*(0,NumberUtils.Gu)(moveOptions.angle.offset),range={left:radOffset-rad/2,right:radOffset+rad/2};return moveOptions.straight||(res.angle+=(0,NumberUtils.vd)((0,NumberUtils.Cs)(range.left,range.right))),moveOptions.random&&"number"==typeof moveOptions.speed&&(res.length*=(0,NumberUtils.sZ)()),res},this._checkOverlap=(pos,tryCount=0)=>{const collisionsOptions=this.options.collisions,radius=this.getRadius();if(!collisionsOptions.enable)return!1;const overlapOptions=collisionsOptions.overlap;if(overlapOptions.enable)return!1;const retries=overlapOptions.retries;if(retries>=0&&tryCount>retries)throw new Error(`${Constants.gK} particle is overlapping and can't be placed`);return!!this.container.particles.find((particle=>(0,NumberUtils.Sp)(pos,particle.position)<radius+particle.getRadius()))},this._getRollColor=color=>{if(!color||!this.roll||!this.backColor&&!this.roll.alter)return color;const backFactor=this.roll.horizontal&&this.roll.vertical?2:1,backSum=this.roll.horizontal?Math.PI/2:0;return Math.floor(((this.roll.angle??0)+backSum)/(Math.PI/backFactor))%2?this.backColor?this.backColor:this.roll.alter?function alterHsl(color,type,value){return{h:color.h,s:color.s,l:color.l+("darken"===type?-1:1)*value}}(color,this.roll.alter.type,this.roll.alter.value):color:color},this._initPosition=position=>{const container=this.container,zIndexValue=(0,NumberUtils.Gu)(this.options.zIndex.value);this.position=this._calcPosition(container,position,(0,NumberUtils.uZ)(zIndexValue,0,container.zLayers)),this.initialPosition=this.position.copy();const canvasSize=container.canvas.size;switch(this.moveCenter={...(0,Utils.bt)(this.options.move.center,canvasSize),radius:this.options.move.center.radius??0,mode:this.options.move.center.mode??"percent"},this.direction=(0,NumberUtils.Gk)(this.options.move.direction,this.position,this.moveCenter),this.options.move.direction){case"inside":this.outType="inside";break;case"outside":this.outType="outside"}this.offset=Vector.O.origin},this._loadShapeData=(shapeOptions,reduceDuplicates)=>{const shapeData=shapeOptions.options[this.shape];if(shapeData)return(0,Utils.ZB)({close:shapeOptions.close,fill:shapeOptions.fill},(0,Utils.wA)(shapeData,this.id,reduceDuplicates))},this._engine=engine,this.init(id,position,overrideOptions,group)}destroy(override){if(this.unbreakable||this.destroyed)return;this.destroyed=!0,this.bubble.inRange=!1,this.slow.inRange=!1;const container=this.container,pathGenerator=this.pathGenerator;for(const[,plugin]of container.plugins)plugin.particleDestroyed&&plugin.particleDestroyed(this,override);for(const updater of container.particles.updaters)updater.particleDestroyed&&updater.particleDestroyed(this,override);pathGenerator&&pathGenerator.reset(this)}draw(delta){const container=this.container;for(const[,plugin]of container.plugins)container.canvas.drawParticlePlugin(plugin,this,delta);container.canvas.drawParticle(this,delta)}getFillColor(){return this._getRollColor(this.bubble.color??getHslFromAnimation(this.color))}getMass(){return this.getRadius()**2*Math.PI/2}getPosition(){return{x:this.position.x+this.offset.x,y:this.position.y+this.offset.y,z:this.position.z}}getRadius(){return this.bubble.radius??this.size.value}getStrokeColor(){return this._getRollColor(this.bubble.color??getHslFromAnimation(this.strokeColor))}init(id,position,overrideOptions,group){const container=this.container,engine=this._engine;this.id=id,this.group=group,this.fill=!0,this.pathRotation=!1,this.close=!0,this.lastPathTime=0,this.destroyed=!1,this.unbreakable=!1,this.rotation=0,this.misplaced=!1,this.retina={maxDistance:{}},this.outType="normal",this.ignoresResizeRatio=!0;const pxRatio=container.retina.pixelRatio,mainOptions=container.actualOptions,particlesOptions=loadParticlesOptions(this._engine,container,mainOptions.particles),shapeType=particlesOptions.shape.type,{reduceDuplicates}=particlesOptions;this.shape=(0,Utils.wA)(shapeType,this.id,reduceDuplicates);const shapeOptions=particlesOptions.shape;if(overrideOptions&&overrideOptions.shape&&overrideOptions.shape.type){const overrideShapeType=overrideOptions.shape.type,shape=(0,Utils.wA)(overrideShapeType,this.id,reduceDuplicates);shape&&(this.shape=shape,shapeOptions.load(overrideOptions.shape))}this.shapeData=this._loadShapeData(shapeOptions,reduceDuplicates),particlesOptions.load(overrideOptions);const shapeData=this.shapeData;shapeData&&particlesOptions.load(shapeData.particles);const interactivity=new Interactivity(engine,container);interactivity.load(container.actualOptions.interactivity),interactivity.load(particlesOptions.interactivity),this.interactivity=interactivity,this.fill=shapeData?.fill??particlesOptions.shape.fill,this.close=shapeData?.close??particlesOptions.shape.close,this.options=particlesOptions;const pathOptions=this.options.move.path;this.pathDelay=1e3*(0,NumberUtils.NA)(pathOptions.delay),pathOptions.generator&&(this.pathGenerator=this._engine.plugins.getPathGenerator(pathOptions.generator),this.pathGenerator&&container.addPath(pathOptions.generator,this.pathGenerator)&&this.pathGenerator.init(container)),container.retina.initParticle(this),this.size=(0,Utils.V0)(this.options.size,pxRatio),this.bubble={inRange:!1},this.slow={inRange:!1,factor:1},this._initPosition(position),this.initialVelocity=this._calculateVelocity(),this.velocity=this.initialVelocity.copy(),this.moveDecay=1-(0,NumberUtils.Gu)(this.options.move.decay);const particles=container.particles;particles.needsSort=particles.needsSort||particles.lastZIndex<this.position.z,particles.lastZIndex=this.position.z,this.zIndexFactor=this.position.z/container.zLayers,this.sides=24;let drawer=container.drawers.get(this.shape);drawer||(drawer=this._engine.plugins.getShapeDrawer(this.shape),drawer&&container.drawers.set(this.shape,drawer)),drawer&&drawer.loadShape&&drawer.loadShape(this);const sideCountFunc=drawer?.getSidesCount;sideCountFunc&&(this.sides=sideCountFunc(this)),this.spawning=!1,this.shadowColor=rangeColorToRgb(this.options.shadow.color);for(const updater of container.particles.updaters)updater.init(this);for(const mover of container.particles.movers)mover.init&&mover.init(this);drawer&&drawer.particleInit&&drawer.particleInit(container,this);for(const[,plugin]of container.plugins)plugin.particleCreated&&plugin.particleCreated(this)}isInsideCanvas(){const radius=this.getRadius(),canvasSize=this.container.canvas.size,position=this.position;return position.x>=-radius&&position.y>=-radius&&position.y<=canvasSize.height+radius&&position.x<=canvasSize.width+radius}isVisible(){return!this.destroyed&&!this.spawning&&this.isInsideCanvas()}reset(){for(const updater of this.container.particles.updaters)updater.reset&&updater.reset(this)}}class Point{constructor(position,particle){this.position=position,this.particle=particle}}class Range{constructor(x,y){this.position={x,y}}}class Rectangle extends Range{constructor(x,y,width,height){super(x,y),this.size={height,width}}contains(point){const w=this.size.width,h=this.size.height,pos=this.position;return point.x>=pos.x&&point.x<=pos.x+w&&point.y>=pos.y&&point.y<=pos.y+h}intersects(range){range instanceof Circle&&range.intersects(this);const w=this.size.width,h=this.size.height,pos1=this.position,pos2=range.position,size2=range instanceof Rectangle?range.size:{width:0,height:0},w2=size2.width,h2=size2.height;return pos2.x<pos1.x+w&&pos2.x+w2>pos1.x&&pos2.y<pos1.y+h&&pos2.y+h2>pos1.y}}class Circle extends Range{constructor(x,y,radius){super(x,y),this.radius=radius}contains(point){return(0,NumberUtils.Sp)(point,this.position)<=this.radius}intersects(range){const pos1=this.position,pos2=range.position,distPos_x=Math.abs(pos2.x-pos1.x),distPos_y=Math.abs(pos2.y-pos1.y),r=this.radius;if(range instanceof Circle){return r+range.radius>Math.sqrt(distPos_x**2+distPos_y**2)}if(range instanceof Rectangle){const{width,height}=range.size;return Math.pow(distPos_x-width,2)+Math.pow(distPos_y-height,2)<=r**2||distPos_x<=r+width&&distPos_y<=r+height||distPos_x<=width||distPos_y<=height}return!1}}class QuadTree{constructor(rectangle,capacity){this.rectangle=rectangle,this.capacity=capacity,this._subdivide=()=>{const{x,y}=this.rectangle.position,{width,height}=this.rectangle.size,{capacity}=this;for(let i=0;i<4;i++)this._subs.push(new QuadTree(new Rectangle(x+width/2*(i%2),y+height/2*(Math.round(i/2)-i%2),width/2,height/2),capacity));this._divided=!0},this._points=[],this._divided=!1,this._subs=[]}insert(point){return!!this.rectangle.contains(point.position)&&(this._points.length<this.capacity?(this._points.push(point),!0):(this._divided||this._subdivide(),this._subs.some((sub=>sub.insert(point)))))}query(range,check,found){const res=found||[];if(!range.intersects(this.rectangle))return[];for(const p of this._points)!range.contains(p.position)&&(0,NumberUtils.Sp)(range.position,p.position)>p.particle.getRadius()&&(!check||check(p.particle))||res.push(p.particle);if(this._divided)for(const sub of this._subs)sub.query(range,check,res);return res}queryCircle(position,radius,check){return this.query(new Circle(position.x,position.y,radius),check)}queryRectangle(position,size,check){return this.query(new Rectangle(position.x,position.y,size.width,size.height),check)}}const qTreeRectangle=canvasSize=>new Rectangle(-canvasSize.width/4,-canvasSize.height/4,3*canvasSize.width/2,3*canvasSize.height/2);class Particles{constructor(engine,container){this._applyDensity=(options,manualCount,group)=>{if(!options.number.density?.enable)return;const numberOptions=options.number,densityFactor=this._initDensityFactor(numberOptions.density),optParticlesNumber=numberOptions.value,optParticlesLimit=numberOptions.limit>0?numberOptions.limit:optParticlesNumber,particlesNumber=Math.min(optParticlesNumber,optParticlesLimit)*densityFactor+manualCount,particlesCount=Math.min(this.count,this.filter((t=>t.group===group)).length);this.limit=numberOptions.limit*densityFactor,particlesCount<particlesNumber?this.push(Math.abs(particlesNumber-particlesCount),void 0,options,group):particlesCount>particlesNumber&&this.removeQuantity(particlesCount-particlesNumber,group)},this._initDensityFactor=densityOptions=>{const container=this._container;if(!container.canvas.element||!densityOptions.enable)return 1;const canvas=container.canvas.element,pxRatio=container.retina.pixelRatio;return canvas.width*canvas.height/(densityOptions.factor*pxRatio**2*densityOptions.area)},this._pushParticle=(position,overrideOptions,group,initializer)=>{try{let particle=this.pool.pop();particle?particle.init(this._nextId,position,overrideOptions,group):particle=new Particle(this._engine,this._nextId,this._container,position,overrideOptions,group);let canAdd=!0;if(initializer&&(canAdd=initializer(particle)),!canAdd)return;return this._array.push(particle),this._zArray.push(particle),this._nextId++,this._engine.dispatchEvent("particleAdded",{container:this._container,data:{particle}}),particle}catch(e){return void(0,Utils.jl)().warning(`${Constants.gK} adding particle: ${e}`)}},this._removeParticle=(index,group,override)=>{const particle=this._array[index];if(!particle||particle.group!==group)return!1;particle.destroy(override);const zIdx=this._zArray.indexOf(particle);return this._array.splice(index,1),this._zArray.splice(zIdx,1),this.pool.push(particle),this._engine.dispatchEvent("particleRemoved",{container:this._container,data:{particle}}),!0},this._engine=engine,this._container=container,this._nextId=0,this._array=[],this._zArray=[],this.pool=[],this.limit=0,this.needsSort=!1,this.lastZIndex=0,this._interactionManager=new InteractionManager(engine,container);const canvasSize=container.canvas.size;this.quadTree=new QuadTree(qTreeRectangle(canvasSize),4),this.movers=this._engine.plugins.getMovers(container,!0),this.updaters=this._engine.plugins.getUpdaters(container,!0)}get count(){return this._array.length}addManualParticles(){const container=this._container,options=container.actualOptions;for(const particle of options.manualParticles)this.addParticle(particle.position?(0,Utils.bt)(particle.position,container.canvas.size):void 0,particle.options)}addParticle(position,overrideOptions,group,initializer){const limit=this._container.actualOptions.particles.number.limit;if(limit>0){const countToRemove=this.count+1-limit;countToRemove>0&&this.removeQuantity(countToRemove)}return this._pushParticle(position,overrideOptions,group,initializer)}clear(){this._array=[],this._zArray=[]}destroy(){this._array=[],this._zArray=[],this.movers=[],this.updaters=[]}async draw(delta){const container=this._container;container.canvas.clear(),await this.update(delta);for(const[,plugin]of container.plugins)container.canvas.drawPlugin(plugin,delta);for(const p of this._zArray)p.draw(delta)}filter(condition){return this._array.filter(condition)}find(condition){return this._array.find(condition)}handleClickMode(mode){this._interactionManager.handleClickMode(mode)}init(){const container=this._container,options=container.actualOptions;this.lastZIndex=0,this.needsSort=!1;let handled=!1;this.updaters=this._engine.plugins.getUpdaters(container,!0),this._interactionManager.init();for(const[,plugin]of container.plugins)if(void 0!==plugin.particlesInitialization&&(handled=plugin.particlesInitialization()),handled)break;this._interactionManager.init();for(const[,pathGenerator]of container.pathGenerators)pathGenerator.init(container);if(this.addManualParticles(),!handled){for(const group in options.particles.groups){const groupOptions=options.particles.groups[group];for(let i=this.count,j=0;j<groupOptions.number?.value&&i<options.particles.number.value;i++,j++)this.addParticle(void 0,groupOptions,group)}for(let i=this.count;i<options.particles.number.value;i++)this.addParticle()}}push(nb,mouse,overrideOptions,group){this.pushing=!0;for(let i=0;i<nb;i++)this.addParticle(mouse?.position,overrideOptions,group);this.pushing=!1}async redraw(){this.clear(),this.init(),await this.draw({value:0,factor:0})}remove(particle,group,override){this.removeAt(this._array.indexOf(particle),void 0,group,override)}removeAt(index,quantity=1,group,override){if(index<0||index>this.count)return;let deleted=0;for(let i=index;deleted<quantity&&i<this.count;i++)this._removeParticle(i--,group,override)&&deleted++}removeQuantity(quantity,group){this.removeAt(0,quantity,group)}setDensity(){const options=this._container.actualOptions,groups=options.particles.groups;for(const group in groups)this._applyDensity(groups[group],0,group);this._applyDensity(options.particles,options.manualParticles.length)}async update(delta){const container=this._container,particlesToDelete=new Set;this.quadTree=new QuadTree(qTreeRectangle(container.canvas.size),4);for(const[,pathGenerator]of container.pathGenerators)pathGenerator.update();for(const[,plugin]of container.plugins)plugin.update&&plugin.update(delta);for(const particle of this._array){const resizeFactor=container.canvas.resizeFactor;resizeFactor&&!particle.ignoresResizeRatio&&(particle.position.x*=resizeFactor.width,particle.position.y*=resizeFactor.height,particle.initialPosition.x*=resizeFactor.width,particle.initialPosition.y*=resizeFactor.height),particle.ignoresResizeRatio=!1,await this._interactionManager.reset(particle);for(const[,plugin]of this._container.plugins){if(particle.destroyed)break;plugin.particleUpdate&&plugin.particleUpdate(particle,delta)}for(const mover of this.movers)mover.isEnabled(particle)&&mover.move(particle,delta);particle.destroyed?particlesToDelete.add(particle):this.quadTree.insert(new Point(particle.getPosition(),particle))}if(particlesToDelete.size){const checkDelete=p=>!particlesToDelete.has(p);this._array=this.filter(checkDelete),this._zArray=this._zArray.filter(checkDelete),this.pool.push(...particlesToDelete)}await this._interactionManager.externalInteract(delta);for(const particle of this._array){for(const updater of this.updaters)updater.update(particle,delta);particle.destroyed||particle.spawning||await this._interactionManager.particlesInteract(particle,delta)}if(delete container.canvas.resizeFactor,this.needsSort){const zArray=this._zArray;zArray.sort(((a,b)=>b.position.z-a.position.z||a.id-b.id)),this.lastZIndex=zArray[zArray.length-1].position.z,this.needsSort=!1}}}class Retina{constructor(container){this.container=container,this.pixelRatio=1,this.reduceFactor=1}init(){const container=this.container,options=container.actualOptions;this.pixelRatio=!options.detectRetina||(0,Utils.Kr)()?1:window.devicePixelRatio,this.reduceFactor=1;const ratio=this.pixelRatio;if(container.canvas.element){const element=container.canvas.element;container.canvas.size.width=element.offsetWidth*ratio,container.canvas.size.height=element.offsetHeight*ratio}const particles=options.particles,moveOptions=particles.move;this.attractDistance=(0,NumberUtils.Gu)(moveOptions.attract.distance)*ratio,this.maxSpeed=(0,NumberUtils.Gu)(moveOptions.gravity.maxSpeed)*ratio,this.sizeAnimationSpeed=(0,NumberUtils.Gu)(particles.size.animation.speed)*ratio}initParticle(particle){const options=particle.options,ratio=this.pixelRatio,moveOptions=options.move,moveDistance=moveOptions.distance,props=particle.retina;props.attractDistance=(0,NumberUtils.Gu)(moveOptions.attract.distance)*ratio,props.moveDrift=(0,NumberUtils.Gu)(moveOptions.drift)*ratio,props.moveSpeed=(0,NumberUtils.Gu)(moveOptions.speed)*ratio,props.sizeAnimationSpeed=(0,NumberUtils.Gu)(options.size.animation.speed)*ratio;const maxDistance=props.maxDistance;maxDistance.horizontal=void 0!==moveDistance.horizontal?moveDistance.horizontal*ratio:void 0,maxDistance.vertical=void 0!==moveDistance.vertical?moveDistance.vertical*ratio:void 0,props.maxSpeed=(0,NumberUtils.Gu)(moveOptions.gravity.maxSpeed)*ratio}}function guardCheck(container){return container&&!container.destroyed}function loadContainerOptions(engine,container,...sourceOptionsArr){const options=new Options(engine,container);return loadOptions(options,...sourceOptionsArr),options}const defaultPathGenerator={generate:p=>p.velocity,init:()=>{},update:()=>{},reset:()=>{}};class Container{constructor(engine,id,sourceOptions){this.id=id,this._intersectionManager=entries=>{if(guardCheck(this)&&this.actualOptions.pauseOnOutsideViewport)for(const entry of entries)entry.target===this.interactivity.element&&(entry.isIntersecting?this.play:this.pause)()},this._nextFrame=async timestamp=>{try{if(!this.smooth&&void 0!==this.lastFrameTime&&timestamp<this.lastFrameTime+1e3/this.fpsLimit)return void this.draw(!1);this.lastFrameTime??=timestamp;const delta=function initDelta(value,fpsLimit=60,smooth=!1){return{value,factor:smooth?60/fpsLimit:60*value/1e3}}(timestamp-this.lastFrameTime,this.fpsLimit,this.smooth);if(this.addLifeTime(delta.value),this.lastFrameTime=timestamp,delta.value>1e3)return void this.draw(!1);if(await this.particles.draw(delta),!this.alive())return void this.destroy();this.getAnimationStatus()&&this.draw(!1)}catch(e){(0,Utils.jl)().error(`${Constants.gK} in animation loop`,e)}},this._engine=engine,this.fpsLimit=120,this.smooth=!1,this._delay=0,this._duration=0,this._lifeTime=0,this._firstStart=!0,this.started=!1,this.destroyed=!1,this._paused=!0,this.lastFrameTime=0,this.zLayers=100,this.pageHidden=!1,this._sourceOptions=sourceOptions,this._initialSourceOptions=sourceOptions,this.retina=new Retina(this),this.canvas=new Canvas(this),this.particles=new Particles(this._engine,this),this.pathGenerators=new Map,this.interactivity={mouse:{clicking:!1,inside:!1}},this.plugins=new Map,this.drawers=new Map,this._options=loadContainerOptions(this._engine,this),this.actualOptions=loadContainerOptions(this._engine,this),this._eventListeners=new EventListeners(this),"undefined"!=typeof IntersectionObserver&&IntersectionObserver&&(this._intersectionObserver=new IntersectionObserver((entries=>this._intersectionManager(entries)))),this._engine.dispatchEvent("containerBuilt",{container:this})}get options(){return this._options}get sourceOptions(){return this._sourceOptions}addClickHandler(callback){if(!guardCheck(this))return;const el=this.interactivity.element;if(!el)return;const clickOrTouchHandler=(e,pos,radius)=>{if(!guardCheck(this))return;const pxRatio=this.retina.pixelRatio,posRetina={x:pos.x*pxRatio,y:pos.y*pxRatio},particles=this.particles.quadTree.queryCircle(posRetina,radius*pxRatio);callback(e,particles)};let touched=!1,touchMoved=!1;el.addEventListener("click",(e=>{if(!guardCheck(this))return;const mouseEvent=e,pos={x:mouseEvent.offsetX||mouseEvent.clientX,y:mouseEvent.offsetY||mouseEvent.clientY};clickOrTouchHandler(e,pos,1)})),el.addEventListener("touchstart",(()=>{guardCheck(this)&&(touched=!0,touchMoved=!1)})),el.addEventListener("touchmove",(()=>{guardCheck(this)&&(touchMoved=!0)})),el.addEventListener("touchend",(e=>{if(guardCheck(this)){if(touched&&!touchMoved){const touchEvent=e;let lastTouch=touchEvent.touches[touchEvent.touches.length-1];if(!lastTouch&&(lastTouch=touchEvent.changedTouches[touchEvent.changedTouches.length-1],!lastTouch))return;const element=this.canvas.element,canvasRect=element?element.getBoundingClientRect():void 0,pos={x:lastTouch.clientX-(canvasRect?canvasRect.left:0),y:lastTouch.clientY-(canvasRect?canvasRect.top:0)};clickOrTouchHandler(e,pos,Math.max(lastTouch.radiusX,lastTouch.radiusY))}touched=!1,touchMoved=!1}})),el.addEventListener("touchcancel",(()=>{guardCheck(this)&&(touched=!1,touchMoved=!1)}))}addLifeTime(value){this._lifeTime+=value}addPath(key,generator,override=!1){return!(!guardCheck(this)||!override&&this.pathGenerators.has(key))&&(this.pathGenerators.set(key,generator??defaultPathGenerator),!0)}alive(){return!this._duration||this._lifeTime<=this._duration}destroy(){if(!guardCheck(this))return;this.stop(),this.particles.destroy(),this.canvas.destroy();for(const[,drawer]of this.drawers)drawer.destroy&&drawer.destroy(this);for(const key of this.drawers.keys())this.drawers.delete(key);this._engine.plugins.destroy(this),this.destroyed=!0;const mainArr=this._engine.dom(),idx=mainArr.findIndex((t=>t===this));idx>=0&&mainArr.splice(idx,1),this._engine.dispatchEvent("containerDestroyed",{container:this})}draw(force){if(!guardCheck(this))return;let refreshTime=force;this._drawAnimationFrame=requestAnimationFrame((async timestamp=>{refreshTime&&(this.lastFrameTime=void 0,refreshTime=!1),await this._nextFrame(timestamp)}))}async export(type,options={}){for(const[,plugin]of this.plugins){if(!plugin.export)continue;const res=await plugin.export(type,options);if(res.supported)return res.blob}(0,Utils.jl)().error(`${Constants.gK} - Export plugin with type ${type} not found`)}getAnimationStatus(){return!this._paused&&!this.pageHidden&&guardCheck(this)}handleClickMode(mode){if(guardCheck(this)){this.particles.handleClickMode(mode);for(const[,plugin]of this.plugins)plugin.handleClickMode&&plugin.handleClickMode(mode)}}async init(){if(!guardCheck(this))return;const shapes=this._engine.plugins.getSupportedShapes();for(const type of shapes){const drawer=this._engine.plugins.getShapeDrawer(type);drawer&&this.drawers.set(type,drawer)}this._options=loadContainerOptions(this._engine,this,this._initialSourceOptions,this.sourceOptions),this.actualOptions=loadContainerOptions(this._engine,this,this._options);const availablePlugins=this._engine.plugins.getAvailablePlugins(this);for(const[id,plugin]of availablePlugins)this.plugins.set(id,plugin);this.retina.init(),await this.canvas.init(),this.updateActualOptions(),this.canvas.initBackground(),this.canvas.resize(),this.zLayers=this.actualOptions.zLayers,this._duration=1e3*(0,NumberUtils.Gu)(this.actualOptions.duration),this._delay=1e3*(0,NumberUtils.Gu)(this.actualOptions.delay),this._lifeTime=0,this.fpsLimit=this.actualOptions.fpsLimit>0?this.actualOptions.fpsLimit:120,this.smooth=this.actualOptions.smooth;for(const[,drawer]of this.drawers)drawer.init&&await drawer.init(this);for(const[,plugin]of this.plugins)plugin.init&&await plugin.init();this._engine.dispatchEvent("containerInit",{container:this}),this.particles.init(),this.particles.setDensity();for(const[,plugin]of this.plugins)plugin.particlesSetup&&plugin.particlesSetup();this._engine.dispatchEvent("particlesSetup",{container:this})}async loadTheme(name){guardCheck(this)&&(this._currentTheme=name,await this.refresh())}pause(){if(guardCheck(this)&&(void 0!==this._drawAnimationFrame&&(cancelAnimationFrame(this._drawAnimationFrame),delete this._drawAnimationFrame),!this._paused)){for(const[,plugin]of this.plugins)plugin.pause&&plugin.pause();this.pageHidden||(this._paused=!0),this._engine.dispatchEvent("containerPaused",{container:this})}}play(force){if(!guardCheck(this))return;const needsUpdate=this._paused||force;if(!this._firstStart||this.actualOptions.autoPlay){if(this._paused&&(this._paused=!1),needsUpdate)for(const[,plugin]of this.plugins)plugin.play&&plugin.play();this._engine.dispatchEvent("containerPlay",{container:this}),this.draw(needsUpdate||!1)}else this._firstStart=!1}async refresh(){if(guardCheck(this))return this.stop(),this.start()}async reset(){if(guardCheck(this))return this._initialSourceOptions=void 0,this._options=loadContainerOptions(this._engine,this),this.actualOptions=loadContainerOptions(this._engine,this,this._options),this.refresh()}setNoise(noiseOrGenerator,init,update){guardCheck(this)&&this.setPath(noiseOrGenerator,init,update)}setPath(pathOrGenerator,init,update){if(!pathOrGenerator||!guardCheck(this))return;const pathGenerator={...defaultPathGenerator};if((0,Utils.mf)(pathOrGenerator))pathGenerator.generate=pathOrGenerator,init&&(pathGenerator.init=init),update&&(pathGenerator.update=update);else{const oldGenerator=pathGenerator;pathGenerator.generate=pathOrGenerator.generate||oldGenerator.generate,pathGenerator.init=pathOrGenerator.init||oldGenerator.init,pathGenerator.update=pathOrGenerator.update||oldGenerator.update}this.addPath("default",pathGenerator,!0)}async start(){guardCheck(this)&&!this.started&&(await this.init(),this.started=!0,await new Promise((resolve=>{this._delayTimeout=setTimeout((async()=>{this._eventListeners.addListeners(),this.interactivity.element instanceof HTMLElement&&this._intersectionObserver&&this._intersectionObserver.observe(this.interactivity.element);for(const[,plugin]of this.plugins)plugin.start&&await plugin.start();this._engine.dispatchEvent("containerStarted",{container:this}),this.play(),resolve()}),this._delay)})))}stop(){if(guardCheck(this)&&this.started){this._delayTimeout&&(clearTimeout(this._delayTimeout),delete this._delayTimeout),this._firstStart=!0,this.started=!1,this._eventListeners.removeListeners(),this.pause(),this.particles.clear(),this.canvas.stop(),this.interactivity.element instanceof HTMLElement&&this._intersectionObserver&&this._intersectionObserver.unobserve(this.interactivity.element);for(const[,plugin]of this.plugins)plugin.stop&&plugin.stop();for(const key of this.plugins.keys())this.plugins.delete(key);this._sourceOptions=this._options,this._engine.dispatchEvent("containerStopped",{container:this})}}updateActualOptions(){this.actualOptions.responsive=[];const newMaxWidth=this.actualOptions.setResponsive(this.canvas.size.width,this.retina.pixelRatio,this._options);return this.actualOptions.setTheme(this._currentTheme),this.responsiveMaxWidth!==newMaxWidth&&(this.responsiveMaxWidth=newMaxWidth,!0)}}class EventDispatcher{constructor(){this._listeners=new Map}addEventListener(type,listener){this.removeEventListener(type,listener);let arr=this._listeners.get(type);arr||(arr=[],this._listeners.set(type,arr)),arr.push(listener)}dispatchEvent(type,args){const listeners=this._listeners.get(type);listeners&&listeners.forEach((handler=>handler(args)))}hasEventListener(type){return!!this._listeners.get(type)}removeAllEventListeners(type){type?this._listeners.delete(type):this._listeners=new Map}removeEventListener(type,listener){const arr=this._listeners.get(type);if(!arr)return;const length=arr.length,idx=arr.indexOf(listener);idx<0||(1===length?this._listeners.delete(type):arr.splice(idx,1))}}function getItemsFromInitializer(container,map,initializers,force=!1){let res=map.get(container);return res&&!force||(res=[...initializers.values()].map((t=>t(container))),map.set(container,res)),res}class Plugins{constructor(engine){this._engine=engine,this.plugins=[],this._initializers={interactors:new Map,movers:new Map,updaters:new Map},this.interactors=new Map,this.movers=new Map,this.updaters=new Map,this.presets=new Map,this.drawers=new Map,this.pathGenerators=new Map}addInteractor(name,initInteractor){this._initializers.interactors.set(name,initInteractor)}addParticleMover(name,initMover){this._initializers.movers.set(name,initMover)}addParticleUpdater(name,initUpdater){this._initializers.updaters.set(name,initUpdater)}addPathGenerator(type,pathGenerator){!this.getPathGenerator(type)&&this.pathGenerators.set(type,pathGenerator)}addPlugin(plugin){!this.getPlugin(plugin.id)&&this.plugins.push(plugin)}addPreset(presetKey,options,override=!1){(override||!this.getPreset(presetKey))&&this.presets.set(presetKey,options)}addShapeDrawer(types,drawer){(0,Utils.KH)(types,(type=>{!this.getShapeDrawer(type)&&this.drawers.set(type,drawer)}))}destroy(container){this.updaters.delete(container),this.movers.delete(container),this.interactors.delete(container)}getAvailablePlugins(container){const res=new Map;for(const plugin of this.plugins)plugin.needsPlugin(container.actualOptions)&&res.set(plugin.id,plugin.getPlugin(container));return res}getInteractors(container,force=!1){return getItemsFromInitializer(container,this.interactors,this._initializers.interactors,force)}getMovers(container,force=!1){return getItemsFromInitializer(container,this.movers,this._initializers.movers,force)}getPathGenerator(type){return this.pathGenerators.get(type)}getPlugin(plugin){return this.plugins.find((t=>t.id===plugin))}getPreset(preset){return this.presets.get(preset)}getShapeDrawer(type){return this.drawers.get(type)}getSupportedShapes(){return this.drawers.keys()}getUpdaters(container,force=!1){return getItemsFromInitializer(container,this.updaters,this._initializers.updaters,force)}loadOptions(options,sourceOptions){for(const plugin of this.plugins)plugin.loadOptions(options,sourceOptions)}loadParticlesOptions(container,options,...sourceOptions){const updaters=this.updaters.get(container);if(updaters)for(const updater of updaters)updater.loadOptions&&updater.loadOptions(options,...sourceOptions)}}class Engine{constructor(){this._configs=new Map,this._domArray=[],this._eventDispatcher=new EventDispatcher,this._initialized=!1,this.plugins=new Plugins(this)}get configs(){const res={};for(const[name,config]of this._configs)res[name]=config;return res}get version(){return"2.12.0"}addConfig(nameOrConfig,config){(0,Utils.HD)(nameOrConfig)?config&&(config.name=nameOrConfig,this._configs.set(nameOrConfig,config)):this._configs.set(nameOrConfig.name??"default",nameOrConfig)}addEventListener(type,listener){this._eventDispatcher.addEventListener(type,listener)}async addInteractor(name,interactorInitializer,refresh=!0){this.plugins.addInteractor(name,interactorInitializer),await this.refresh(refresh)}async addMover(name,moverInitializer,refresh=!0){this.plugins.addParticleMover(name,moverInitializer),await this.refresh(refresh)}async addParticleUpdater(name,updaterInitializer,refresh=!0){this.plugins.addParticleUpdater(name,updaterInitializer),await this.refresh(refresh)}async addPathGenerator(name,generator,refresh=!0){this.plugins.addPathGenerator(name,generator),await this.refresh(refresh)}async addPlugin(plugin,refresh=!0){this.plugins.addPlugin(plugin),await this.refresh(refresh)}async addPreset(preset,options,override=!1,refresh=!0){this.plugins.addPreset(preset,options,override),await this.refresh(refresh)}async addShape(shape,drawer,initOrRefresh,afterEffectOrRefresh,destroyOrRefresh,refresh=!0){let customDrawer,realInit,realAfterEffect,realDestroy,realRefresh=refresh;(0,Utils.jn)(initOrRefresh)?(realRefresh=initOrRefresh,realInit=void 0):realInit=initOrRefresh,(0,Utils.jn)(afterEffectOrRefresh)?(realRefresh=afterEffectOrRefresh,realAfterEffect=void 0):realAfterEffect=afterEffectOrRefresh,(0,Utils.jn)(destroyOrRefresh)?(realRefresh=destroyOrRefresh,realDestroy=void 0):realDestroy=destroyOrRefresh,customDrawer=(0,Utils.mf)(drawer)?{afterEffect:realAfterEffect,destroy:realDestroy,draw:drawer,init:realInit}:drawer,this.plugins.addShapeDrawer(shape,customDrawer),await this.refresh(realRefresh)}dispatchEvent(type,args){this._eventDispatcher.dispatchEvent(type,args)}dom(){return this._domArray}domItem(index){const dom=this.dom(),item=dom[index];if(item&&!item.destroyed)return item;dom.splice(index,1)}init(){this._initialized||(this._initialized=!0)}async load(tagIdOrOptionsOrParams,options){return this.loadFromArray(tagIdOrOptionsOrParams,options)}async loadFromArray(tagIdOrOptionsOrParams,optionsOrIndex,index){let params;return!function isParams(obj){return!function isParamsEmpty(params){return!(params.id||params.element||params.url||params.options)}(obj)}(tagIdOrOptionsOrParams)?(params={},(0,Utils.HD)(tagIdOrOptionsOrParams)?params.id=tagIdOrOptionsOrParams:params.options=tagIdOrOptionsOrParams,(0,Utils.hj)(optionsOrIndex)?params.index=optionsOrIndex:params.options=optionsOrIndex??params.options,params.index=index??params.index):params=tagIdOrOptionsOrParams,this._loadParams(params)}async loadJSON(tagId,pathConfigJson,index){let url,id;return(0,Utils.hj)(pathConfigJson)||void 0===pathConfigJson?url=tagId:(id=tagId,url=pathConfigJson),this._loadParams({id,url,index})}async refresh(refresh=!0){refresh&&this.dom().forEach((t=>t.refresh()))}removeEventListener(type,listener){this._eventDispatcher.removeEventListener(type,listener)}async set(id,element,options,index){const params={index};return(0,Utils.HD)(id)?params.id=id:params.element=id,element instanceof HTMLElement?params.element=element:params.options=element,(0,Utils.hj)(options)?params.index=options:params.options=options??params.options,this._loadParams(params)}async setJSON(id,element,pathConfigJson,index){const params={};return id instanceof HTMLElement?(params.element=id,params.url=element,params.index=pathConfigJson):(params.id=id,params.element=element,params.url=pathConfigJson,params.index=index),this._loadParams(params)}setOnClickHandler(callback){const dom=this.dom();if(!dom.length)throw new Error(`${Constants.gK} can only set click handlers after calling tsParticles.load()`);for(const domItem of dom)domItem.addClickHandler(callback)}async _loadParams(params){const id=params.id??`tsparticles${Math.floor(1e4*(0,NumberUtils.sZ)())}`,{index,url}=params,options=url?await async function getDataFromUrl(data){const url=(0,Utils.wA)(data.url,data.index);if(!url)return data.fallback;const response=await fetch(url);return response.ok?response.json():((0,Utils.jl)().error(`${Constants.gK} ${response.status} while retrieving config file`),data.fallback)}({fallback:params.options,url,index}):params.options;let domContainer=params.element??document.getElementById(id);domContainer||(domContainer=document.createElement("div"),domContainer.id=id,document.body.append(domContainer));const currentOptions=(0,Utils.wA)(options,index),dom=this.dom(),oldIndex=dom.findIndex((v=>v.id===id));if(oldIndex>=0){const old=this.domItem(oldIndex);old&&!old.destroyed&&(old.destroy(),dom.splice(oldIndex,1))}let canvasEl;if("canvas"===domContainer.tagName.toLowerCase())canvasEl=domContainer,canvasEl.dataset[Constants.YU]="false";else{const existingCanvases=domContainer.getElementsByTagName("canvas");existingCanvases.length?(canvasEl=existingCanvases[0],canvasEl.dataset[Constants.YU]="false"):(canvasEl=document.createElement("canvas"),canvasEl.dataset[Constants.YU]="true",domContainer.appendChild(canvasEl))}canvasEl.style.width||(canvasEl.style.width="100%"),canvasEl.style.height||(canvasEl.style.height="100%");const newItem=new Container(this,id,currentOptions);return oldIndex>=0?dom.splice(oldIndex,0,newItem):dom.push(newItem),newItem.canvas.loadCanvas(canvasEl),await newItem.start(),newItem}}class HslColorManager{constructor(){this.key="hsl",this.stringPrefix="hsl"}handleColor(color){const hslColor=color.value.hsl??color.value;if(void 0!==hslColor.h&&void 0!==hslColor.s&&void 0!==hslColor.l)return hslToRgb(hslColor)}handleRangeColor(color){const hslColor=color.value.hsl??color.value;if(void 0!==hslColor.h&&void 0!==hslColor.l)return hslToRgb({h:(0,NumberUtils.Gu)(hslColor.h),l:(0,NumberUtils.Gu)(hslColor.l),s:(0,NumberUtils.Gu)(hslColor.s)})}parseString(input){if(!input.startsWith("hsl"))return;const result=/hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.%]+)\s*)?\)/i.exec(input);return result?function hslaToRgba(hsla){const rgbResult=hslToRgb(hsla);return{a:hsla.a,b:rgbResult.b,g:rgbResult.g,r:rgbResult.r}}({a:result.length>4?(0,NumberUtils.BV)(result[5]):1,h:parseInt(result[1],10),l:parseInt(result[3],10),s:parseInt(result[2],10)}):void 0}}class RgbColorManager{constructor(){this.key="rgb",this.stringPrefix="rgb"}handleColor(color){const rgbColor=color.value.rgb??color.value;if(void 0!==rgbColor.r)return rgbColor}handleRangeColor(color){const rgbColor=color.value.rgb??color.value;if(void 0!==rgbColor.r)return{r:(0,NumberUtils.Gu)(rgbColor.r),g:(0,NumberUtils.Gu)(rgbColor.g),b:(0,NumberUtils.Gu)(rgbColor.b)}}parseString(input){if(!input.startsWith(this.stringPrefix))return;const result=/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.%]+)\s*)?\)/i.exec(input);return result?{a:result.length>4?(0,NumberUtils.BV)(result[5]):1,b:parseInt(result[3],10),g:parseInt(result[2],10),r:parseInt(result[1],10)}:void 0}}const tsParticles=function init(){const rgbColorManager=new RgbColorManager,hslColorManager=new HslColorManager;addColorManager(rgbColorManager),addColorManager(hslColorManager);const engine=new Engine;return engine.init(),engine}();(0,Utils.Kr)()||(window.tsParticles=tsParticles);var deep_eql=__webpack_require__("./node_modules/deep-eql/index.js"),deep_eql_default=__webpack_require__.n(deep_eql);class Particles_Particles extends react.Component{constructor(props){super(props),this.state={init:!1,library:void 0}}destroy(){this.state.library&&(this.state.library.destroy(),this.setState({library:void 0}))}shouldComponentUpdate(nextProps){return console.dir({props:this.props,nextProps}),!deep_eql_default()(nextProps,this.props)}componentDidUpdate(){this.refresh()}forceUpdate(){this.refresh().then((()=>{super.forceUpdate()}))}componentDidMount(){(async()=>{this.props.init&&await this.props.init(tsParticles),this.setState({init:!0},(async()=>{await this.loadParticles()}))})()}componentWillUnmount(){this.destroy()}render(){const{width,height,className,canvasClassName,id}=this.props;return react.createElement("div",{className,id},react.createElement("canvas",{className:canvasClassName,style:{...this.props.style,width,height}}))}async refresh(){this.destroy(),await this.loadParticles()}async loadParticles(){if(!this.state.init)return;const id=this.props.id??Particles_Particles.defaultProps.id??"tsparticles",container=this.props.url?await tsParticles.loadJSON(id,this.props.url):await tsParticles.load(id,this.props.options??this.props.params);await(async container=>{this.props.container&&(this.props.container.current=container),this.setState({library:container}),this.props.loaded&&await this.props.loaded(container)})(container)}}Particles_Particles.defaultProps={width:"100%",height:"100%",options:{},style:{},url:void 0,id:"tsparticles"};const esm=Particles_Particles},"./node_modules/react/cjs/react-jsx-runtime.production.min.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";var f=__webpack_require__("./node_modules/react/index.js"),k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};function q(c,a,g){var b,d={},e=null,h=null;for(b in void 0!==g&&(e=""+g),void 0!==a.key&&(e=""+a.key),void 0!==a.ref&&(h=a.ref),a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.jsx=q},"./node_modules/react/jsx-runtime.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=__webpack_require__("./node_modules/react/cjs/react-jsx-runtime.production.min.js")},"./node_modules/tsparticles-engine/esm/Core/Utils/Constants.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{$o:()=>touchEndEvent,G1:()=>mouseOutEvent,QL:()=>visibilityChangeEvent,Re:()=>touchStartEvent,VH:()=>touchCancelEvent,Wt:()=>mouseMoveEvent,YU:()=>generatedAttribute,ZL:()=>mouseDownEvent,aM:()=>mouseLeaveEvent,gK:()=>errorPrefix,rR:()=>resizeEvent,zX:()=>touchMoveEvent,zw:()=>mouseUpEvent});const generatedAttribute="generated",mouseDownEvent="pointerdown",mouseUpEvent="pointerup",mouseLeaveEvent="pointerleave",mouseOutEvent="pointerout",mouseMoveEvent="pointermove",touchStartEvent="touchstart",touchEndEvent="touchend",touchMoveEvent="touchmove",touchCancelEvent="touchcancel",resizeEvent="resize",visibilityChangeEvent="visibilitychange",errorPrefix="tsParticles - Error"},"./node_modules/tsparticles-engine/esm/Core/Utils/Vector.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{O:()=>Vector});var _Vector3d__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/tsparticles-engine/esm/Core/Utils/Vector3d.js");class Vector extends _Vector3d__WEBPACK_IMPORTED_MODULE_0__.U{constructor(xOrCoords,y){super(xOrCoords,y,0)}static get origin(){return Vector.create(0,0)}static clone(source){return Vector.create(source.x,source.y)}static create(x,y){return new Vector(x,y)}}},"./node_modules/tsparticles-engine/esm/Core/Utils/Vector3d.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{U:()=>Vector3d});var _Constants__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/tsparticles-engine/esm/Core/Utils/Constants.js"),_Utils_Utils__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/tsparticles-engine/esm/Utils/Utils.js");class Vector3d{constructor(xOrCoords,y,z){if(this._updateFromAngle=(angle,length)=>{this.x=Math.cos(angle)*length,this.y=Math.sin(angle)*length},!(0,_Utils_Utils__WEBPACK_IMPORTED_MODULE_0__.hj)(xOrCoords)&&xOrCoords){this.x=xOrCoords.x,this.y=xOrCoords.y;const coords3d=xOrCoords;this.z=coords3d.z?coords3d.z:0}else{if(void 0===xOrCoords||void 0===y)throw new Error(`${_Constants__WEBPACK_IMPORTED_MODULE_1__.gK} Vector3d not initialized correctly`);this.x=xOrCoords,this.y=y,this.z=z??0}}static get origin(){return Vector3d.create(0,0,0)}get angle(){return Math.atan2(this.y,this.x)}set angle(angle){this._updateFromAngle(angle,this.length)}get length(){return Math.sqrt(this.getLengthSq())}set length(length){this._updateFromAngle(this.angle,length)}static clone(source){return Vector3d.create(source.x,source.y,source.z)}static create(x,y,z){return new Vector3d(x,y,z)}add(v){return Vector3d.create(this.x+v.x,this.y+v.y,this.z+v.z)}addTo(v){this.x+=v.x,this.y+=v.y,this.z+=v.z}copy(){return Vector3d.clone(this)}distanceTo(v){return this.sub(v).length}distanceToSq(v){return this.sub(v).getLengthSq()}div(n){return Vector3d.create(this.x/n,this.y/n,this.z/n)}divTo(n){this.x/=n,this.y/=n,this.z/=n}getLengthSq(){return this.x**2+this.y**2}mult(n){return Vector3d.create(this.x*n,this.y*n,this.z*n)}multTo(n){this.x*=n,this.y*=n,this.z*=n}normalize(){const length=this.length;0!=length&&this.multTo(1/length)}rotate(angle){return Vector3d.create(this.x*Math.cos(angle)-this.y*Math.sin(angle),this.x*Math.sin(angle)+this.y*Math.cos(angle),0)}setTo(c){this.x=c.x,this.y=c.y;const v3d=c;this.z=v3d.z?v3d.z:0}sub(v){return Vector3d.create(this.x-v.x,this.y-v.y,this.z-v.z)}subFrom(v){this.x-=v.x,this.y-=v.y,this.z-=v.z}}},"./node_modules/tsparticles-engine/esm/Utils/NumberUtils.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{BV:()=>parseAlpha,Cs:()=>setRangeValue,Gk:()=>getParticleDirectionAngle,Gu:()=>getRangeValue,KI:()=>getRangeMax,NA:()=>getValue,Sp:()=>getDistance,Uv:()=>getRangeMin,lQ:()=>getParticleBaseVelocity,mC:()=>calcExactPositionOrRandomFromSize,sZ:()=>getRandom,uZ:()=>clamp,vd:()=>randomInRange});var _Utils__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/tsparticles-engine/esm/Utils/Utils.js"),_Core_Utils_Vector__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/tsparticles-engine/esm/Core/Utils/Vector.js");let _random=Math.random;new Map;function getRandom(){return clamp(_random(),0,1-1e-16)}function clamp(num,min,max){return Math.min(Math.max(num,min),max)}function randomInRange(r){const max=getRangeMax(r);let min=getRangeMin(r);return max===min&&(min=0),getRandom()*(max-min)+min}function getRangeValue(value){return(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.hj)(value)?value:randomInRange(value)}function getRangeMin(value){return(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.hj)(value)?value:value.min}function getRangeMax(value){return(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.hj)(value)?value:value.max}function setRangeValue(source,value){if(source===value||void 0===value&&(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.hj)(source))return source;const min=getRangeMin(source),max=getRangeMax(source);return void 0!==value?{min:Math.min(min,value),max:Math.max(max,value)}:setRangeValue(min,max)}function getValue(options){const random=options.random,{enable,minimumValue}=(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.jn)(random)?{enable:random,minimumValue:0}:random;return getRangeValue(enable?setRangeValue(options.value,minimumValue):options.value)}function getDistance(pointA,pointB){return function getDistances(pointA,pointB){const dx=pointA.x-pointB.x,dy=pointA.y-pointB.y;return{dx,dy,distance:Math.sqrt(dx**2+dy**2)}}(pointA,pointB).distance}function getParticleDirectionAngle(direction,position,center){if((0,_Utils__WEBPACK_IMPORTED_MODULE_0__.hj)(direction))return direction*Math.PI/180;switch(direction){case"top":return-Math.PI/2;case"top-right":return-Math.PI/4;case"right":return 0;case"bottom-right":return Math.PI/4;case"bottom":return Math.PI/2;case"bottom-left":return 3*Math.PI/4;case"left":return Math.PI;case"top-left":return-3*Math.PI/4;case"inside":return Math.atan2(center.y-position.y,center.x-position.x);case"outside":return Math.atan2(position.y-center.y,position.x-center.x);default:return getRandom()*Math.PI*2}}function getParticleBaseVelocity(direction){const baseVelocity=_Core_Utils_Vector__WEBPACK_IMPORTED_MODULE_1__.O.origin;return baseVelocity.length=1,baseVelocity.angle=direction,baseVelocity}function calcExactPositionOrRandomFromSize(data){return{x:data.position?.x??getRandom()*data.size.width,y:data.position?.y??getRandom()*data.size.height}}function parseAlpha(input){return input?input.endsWith("%")?parseFloat(input)/100:parseFloat(input):1}},"./node_modules/tsparticles-engine/esm/Utils/Utils.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{HD:()=>isString,HY:()=>safeMatchMedia,KH:()=>executeOnSingleOrMultiple,Kn:()=>isObject,Kr:()=>isSsr,V0:()=>initParticleNumericAnimationValue,ZB:()=>deepExtend,bt:()=>getPosition,c8:()=>itemFromArray,dB:()=>isInArray,hj:()=>isNumber,jl:()=>getLogger,jn:()=>isBoolean,kJ:()=>isArray,mf:()=>isFunction,wA:()=>itemFromSingleOrMultiple,yf:()=>safeMutationObserver});var _NumberUtils__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/tsparticles-engine/esm/Utils/NumberUtils.js");const _logger={debug:console.debug,error:console.error,info:console.info,log:console.log,verbose:console.log,warning:console.warn};function getLogger(){return _logger}function isSsr(){return"undefined"==typeof window||!window||void 0===window.document||!window.document}function safeMatchMedia(query){if(function hasMatchMedia(){return!isSsr()&&"undefined"!=typeof matchMedia}())return matchMedia(query)}function safeMutationObserver(callback){if(!isSsr()&&"undefined"!=typeof MutationObserver)return new MutationObserver(callback)}function isInArray(value,array){return value===array||isArray(array)&&array.indexOf(value)>-1}function itemFromArray(array,index,useIndex=!0){return array[void 0!==index&&useIndex?index%array.length:function arrayRandomIndex(array){return Math.floor((0,_NumberUtils__WEBPACK_IMPORTED_MODULE_0__.sZ)()*array.length)}(array)]}function deepExtend(destination,...sources){for(const source of sources){if(null==source)continue;if(!isObject(source)){destination=source;continue}const sourceIsArray=Array.isArray(source);!sourceIsArray||!isObject(destination)&&destination&&Array.isArray(destination)?sourceIsArray||!isObject(destination)&&destination&&!Array.isArray(destination)||(destination={}):destination=[];for(const key in source){if("__proto__"===key)continue;const value=source[key],destDict=destination;destDict[key]=isObject(value)&&Array.isArray(value)?value.map((v=>deepExtend(destDict[key],v))):deepExtend(destDict[key],value)}}return destination}function executeOnSingleOrMultiple(obj,callback){return isArray(obj)?obj.map(((item,index)=>callback(item,index))):callback(obj,0)}function itemFromSingleOrMultiple(obj,index,useIndex){return isArray(obj)?itemFromArray(obj,index,useIndex):obj}function initParticleNumericAnimationValue(options,pxRatio){const valueRange=options.value,animationOptions=options.animation,res={delayTime:1e3*(0,_NumberUtils__WEBPACK_IMPORTED_MODULE_0__.Gu)(animationOptions.delay),enable:animationOptions.enable,value:(0,_NumberUtils__WEBPACK_IMPORTED_MODULE_0__.Gu)(options.value)*pxRatio,max:(0,_NumberUtils__WEBPACK_IMPORTED_MODULE_0__.KI)(valueRange)*pxRatio,min:(0,_NumberUtils__WEBPACK_IMPORTED_MODULE_0__.Uv)(valueRange)*pxRatio,loops:0,maxLoops:(0,_NumberUtils__WEBPACK_IMPORTED_MODULE_0__.Gu)(animationOptions.count),time:0};if(animationOptions.enable){switch(res.decay=1-(0,_NumberUtils__WEBPACK_IMPORTED_MODULE_0__.Gu)(animationOptions.decay),animationOptions.mode){case"increase":res.status="increasing";break;case"decrease":res.status="decreasing";break;case"random":res.status=(0,_NumberUtils__WEBPACK_IMPORTED_MODULE_0__.sZ)()>=.5?"increasing":"decreasing"}const autoStatus="auto"===animationOptions.mode;switch(animationOptions.startValue){case"min":res.value=res.min,autoStatus&&(res.status="increasing");break;case"max":res.value=res.max,autoStatus&&(res.status="decreasing");break;default:res.value=(0,_NumberUtils__WEBPACK_IMPORTED_MODULE_0__.vd)(res),autoStatus&&(res.status=(0,_NumberUtils__WEBPACK_IMPORTED_MODULE_0__.sZ)()>=.5?"increasing":"decreasing")}}return res.initialValue=res.value,res}function getPositionOrSize(positionOrSize,canvasSize){if(!("percent"===positionOrSize.mode)){const{mode:_,...rest}=positionOrSize;return rest}return"x"in positionOrSize?{x:positionOrSize.x/100*canvasSize.width,y:positionOrSize.y/100*canvasSize.height}:{width:positionOrSize.width/100*canvasSize.width,height:positionOrSize.height/100*canvasSize.height}}function getPosition(position,canvasSize){return getPositionOrSize(position,canvasSize)}function isBoolean(arg){return"boolean"==typeof arg}function isString(arg){return"string"==typeof arg}function isNumber(arg){return"number"==typeof arg}function isFunction(arg){return"function"==typeof arg}function isObject(arg){return"object"==typeof arg&&null!==arg}function isArray(arg){return Array.isArray(arg)}},"./node_modules/tsparticles/browser/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{R:()=>loadFull});const errorPrefix="tsParticles - Error";class Vector3d{constructor(xOrCoords,y,z){if(this._updateFromAngle=(angle,length)=>{this.x=Math.cos(angle)*length,this.y=Math.sin(angle)*length},!isNumber(xOrCoords)&&xOrCoords){this.x=xOrCoords.x,this.y=xOrCoords.y;const coords3d=xOrCoords;this.z=coords3d.z?coords3d.z:0}else{if(void 0===xOrCoords||void 0===y)throw new Error(`${errorPrefix} Vector3d not initialized correctly`);this.x=xOrCoords,this.y=y,this.z=z??0}}static get origin(){return Vector3d.create(0,0,0)}get angle(){return Math.atan2(this.y,this.x)}set angle(angle){this._updateFromAngle(angle,this.length)}get length(){return Math.sqrt(this.getLengthSq())}set length(length){this._updateFromAngle(this.angle,length)}static clone(source){return Vector3d.create(source.x,source.y,source.z)}static create(x,y,z){return new Vector3d(x,y,z)}add(v){return Vector3d.create(this.x+v.x,this.y+v.y,this.z+v.z)}addTo(v){this.x+=v.x,this.y+=v.y,this.z+=v.z}copy(){return Vector3d.clone(this)}distanceTo(v){return this.sub(v).length}distanceToSq(v){return this.sub(v).getLengthSq()}div(n){return Vector3d.create(this.x/n,this.y/n,this.z/n)}divTo(n){this.x/=n,this.y/=n,this.z/=n}getLengthSq(){return this.x**2+this.y**2}mult(n){return Vector3d.create(this.x*n,this.y*n,this.z*n)}multTo(n){this.x*=n,this.y*=n,this.z*=n}normalize(){const length=this.length;0!=length&&this.multTo(1/length)}rotate(angle){return Vector3d.create(this.x*Math.cos(angle)-this.y*Math.sin(angle),this.x*Math.sin(angle)+this.y*Math.cos(angle),0)}setTo(c){this.x=c.x,this.y=c.y;const v3d=c;this.z=v3d.z?v3d.z:0}sub(v){return Vector3d.create(this.x-v.x,this.y-v.y,this.z-v.z)}subFrom(v){this.x-=v.x,this.y-=v.y,this.z-=v.z}}class Vector extends Vector3d{constructor(xOrCoords,y){super(xOrCoords,y,0)}static get origin(){return Vector.create(0,0)}static clone(source){return Vector.create(source.x,source.y)}static create(x,y){return new Vector(x,y)}}let _random=Math.random;const easings=new Map;function addEasing(name,easing){easings.get(name)||easings.set(name,easing)}function getEasing(name){return easings.get(name)||(value=>value)}function getRandom(){return clamp(_random(),0,1-1e-16)}function clamp(num,min,max){return Math.min(Math.max(num,min),max)}function mix(comp1,comp2,weight1,weight2){return Math.floor((comp1*weight1+comp2*weight2)/(weight1+weight2))}function randomInRange(r){const max=getRangeMax(r);let min=getRangeMin(r);return max===min&&(min=0),getRandom()*(max-min)+min}function getRangeValue(value){return isNumber(value)?value:randomInRange(value)}function getRangeMin(value){return isNumber(value)?value:value.min}function getRangeMax(value){return isNumber(value)?value:value.max}function setRangeValue(source,value){if(source===value||void 0===value&&isNumber(source))return source;const min=getRangeMin(source),max=getRangeMax(source);return void 0!==value?{min:Math.min(min,value),max:Math.max(max,value)}:setRangeValue(min,max)}function getDistances(pointA,pointB){const dx=pointA.x-pointB.x,dy=pointA.y-pointB.y;return{dx,dy,distance:Math.sqrt(dx**2+dy**2)}}function getDistance(pointA,pointB){return getDistances(pointA,pointB).distance}function collisionVelocity(v1,v2,m1,m2){return Vector.create(v1.x*(m1-m2)/(m1+m2)+2*v2.x*m2/(m1+m2),v1.y)}function calcPositionOrRandomFromSize(data){return{x:(data.position?.x??100*getRandom())*data.size.width/100,y:(data.position?.y??100*getRandom())*data.size.height/100}}function calcPositionOrRandomFromSizeRanged(data){const position={x:void 0!==data.position?.x?getRangeValue(data.position.x):void 0,y:void 0!==data.position?.y?getRangeValue(data.position.y):void 0};return calcPositionOrRandomFromSize({size:data.size,position})}function calcExactPositionOrRandomFromSize(data){return{x:data.position?.x??getRandom()*data.size.width,y:data.position?.y??getRandom()*data.size.height}}function parseAlpha(input){return input?input.endsWith("%")?parseFloat(input)/100:parseFloat(input):1}const _logger={debug:console.debug,error:console.error,info:console.info,log:console.log,verbose:console.log,warning:console.warn};function getLogger(){return _logger}function rectSideBounce(data){const res={bounced:!1},{pSide,pOtherSide,rectSide,rectOtherSide,velocity,factor}=data;return pOtherSide.min<rectOtherSide.min||pOtherSide.min>rectOtherSide.max||pOtherSide.max<rectOtherSide.min||pOtherSide.max>rectOtherSide.max||(pSide.max>=rectSide.min&&pSide.max<=.5*(rectSide.max+rectSide.min)&&velocity>0||pSide.min<=rectSide.max&&pSide.min>.5*(rectSide.max+rectSide.min)&&velocity<0)&&(res.velocity=velocity*-factor,res.bounced=!0),res}function isSsr(){return"undefined"==typeof window||!window||void 0===window.document||!window.document}function safeMatchMedia(query){if(function hasMatchMedia(){return!isSsr()&&"undefined"!=typeof matchMedia}())return matchMedia(query)}function isInArray(value,array){return value===array||isArray(array)&&array.indexOf(value)>-1}async function loadFont(font,weight){try{await document.fonts.load(`${weight??"400"} 36px '${font??"Verdana"}'`)}catch{}}function arrayRandomIndex(array){return Math.floor(getRandom()*array.length)}function itemFromArray(array,index,useIndex=!0){return array[void 0!==index&&useIndex?index%array.length:arrayRandomIndex(array)]}function isPointInside(point,size,offset,radius,direction){return function areBoundsInside(bounds,size,offset,direction){let inside=!0;direction&&"bottom"!==direction||(inside=bounds.top<size.height+offset.x);!inside||direction&&"left"!==direction||(inside=bounds.right>offset.x);!inside||direction&&"right"!==direction||(inside=bounds.left<size.width+offset.y);!inside||direction&&"top"!==direction||(inside=bounds.bottom>offset.y);return inside}(calculateBounds(point,radius??0),size,offset,direction)}function calculateBounds(point,radius){return{bottom:point.y+radius,left:point.x-radius,right:point.x+radius,top:point.y-radius}}function deepExtend(destination,...sources){for(const source of sources){if(null==source)continue;if(!isObject(source)){destination=source;continue}const sourceIsArray=Array.isArray(source);!sourceIsArray||!isObject(destination)&&destination&&Array.isArray(destination)?sourceIsArray||!isObject(destination)&&destination&&!Array.isArray(destination)||(destination={}):destination=[];for(const key in source){if("__proto__"===key)continue;const value=source[key],destDict=destination;destDict[key]=isObject(value)&&Array.isArray(value)?value.map((v=>deepExtend(destDict[key],v))):deepExtend(destDict[key],value)}}return destination}function isDivModeEnabled(mode,divs){return!!findItemFromSingleOrMultiple(divs,(t=>t.enable&&isInArray(mode,t.mode)))}function divModeExecute(mode,divs,callback){executeOnSingleOrMultiple(divs,(div=>{const divMode=div.mode;div.enable&&isInArray(mode,divMode)&&function singleDivModeExecute(div,callback){const selectors=div.selectors;executeOnSingleOrMultiple(selectors,(selector=>{callback(selector,div)}))}(div,callback)}))}function divMode(divs,element){if(element&&divs)return findItemFromSingleOrMultiple(divs,(div=>function checkSelector(element,selectors){const res=executeOnSingleOrMultiple(selectors,(selector=>element.matches(selector)));return isArray(res)?res.some((t=>t)):res}(element,div.selectors)))}function circleBounceDataFromParticle(p){return{position:p.getPosition(),radius:p.getRadius(),mass:p.getMass(),velocity:p.velocity,factor:Vector.create(getRangeValue(p.options.bounce.horizontal.value),getRangeValue(p.options.bounce.vertical.value))}}function circleBounce(p1,p2){const{x:xVelocityDiff,y:yVelocityDiff}=p1.velocity.sub(p2.velocity),[pos1,pos2]=[p1.position,p2.position],{dx:xDist,dy:yDist}=getDistances(pos2,pos1);if(xVelocityDiff*xDist+yVelocityDiff*yDist<0)return;const angle=-Math.atan2(yDist,xDist),m1=p1.mass,m2=p2.mass,u1=p1.velocity.rotate(angle),u2=p2.velocity.rotate(angle),v1=collisionVelocity(u1,u2,m1,m2),v2=collisionVelocity(u2,u1,m1,m2),vFinal1=v1.rotate(-angle),vFinal2=v2.rotate(-angle);p1.velocity.x=vFinal1.x*p1.factor.x,p1.velocity.y=vFinal1.y*p1.factor.y,p2.velocity.x=vFinal2.x*p2.factor.x,p2.velocity.y=vFinal2.y*p2.factor.y}function rectBounce(particle,divBounds){const bounds=calculateBounds(particle.getPosition(),particle.getRadius()),bounceOptions=particle.options.bounce,resH=rectSideBounce({pSide:{min:bounds.left,max:bounds.right},pOtherSide:{min:bounds.top,max:bounds.bottom},rectSide:{min:divBounds.left,max:divBounds.right},rectOtherSide:{min:divBounds.top,max:divBounds.bottom},velocity:particle.velocity.x,factor:getRangeValue(bounceOptions.horizontal.value)});resH.bounced&&(void 0!==resH.velocity&&(particle.velocity.x=resH.velocity),void 0!==resH.position&&(particle.position.x=resH.position));const resV=rectSideBounce({pSide:{min:bounds.top,max:bounds.bottom},pOtherSide:{min:bounds.left,max:bounds.right},rectSide:{min:divBounds.top,max:divBounds.bottom},rectOtherSide:{min:divBounds.left,max:divBounds.right},velocity:particle.velocity.y,factor:getRangeValue(bounceOptions.vertical.value)});resV.bounced&&(void 0!==resV.velocity&&(particle.velocity.y=resV.velocity),void 0!==resV.position&&(particle.position.y=resV.position))}function executeOnSingleOrMultiple(obj,callback){return isArray(obj)?obj.map(((item,index)=>callback(item,index))):callback(obj,0)}function itemFromSingleOrMultiple(obj,index,useIndex){return isArray(obj)?itemFromArray(obj,index,useIndex):obj}function findItemFromSingleOrMultiple(obj,callback){return isArray(obj)?obj.find(((t,index)=>callback(t,index))):callback(obj,0)?obj:void 0}function initParticleNumericAnimationValue(options,pxRatio){const valueRange=options.value,animationOptions=options.animation,res={delayTime:1e3*getRangeValue(animationOptions.delay),enable:animationOptions.enable,value:getRangeValue(options.value)*pxRatio,max:getRangeMax(valueRange)*pxRatio,min:getRangeMin(valueRange)*pxRatio,loops:0,maxLoops:getRangeValue(animationOptions.count),time:0};if(animationOptions.enable){switch(res.decay=1-getRangeValue(animationOptions.decay),animationOptions.mode){case"increase":res.status="increasing";break;case"decrease":res.status="decreasing";break;case"random":res.status=getRandom()>=.5?"increasing":"decreasing"}const autoStatus="auto"===animationOptions.mode;switch(animationOptions.startValue){case"min":res.value=res.min,autoStatus&&(res.status="increasing");break;case"max":res.value=res.max,autoStatus&&(res.status="decreasing");break;default:res.value=randomInRange(res),autoStatus&&(res.status=getRandom()>=.5?"increasing":"decreasing")}}return res.initialValue=res.value,res}function getPositionOrSize(positionOrSize,canvasSize){if(!("percent"===positionOrSize.mode)){const{mode:_,...rest}=positionOrSize;return rest}return"x"in positionOrSize?{x:positionOrSize.x/100*canvasSize.width,y:positionOrSize.y/100*canvasSize.height}:{width:positionOrSize.width/100*canvasSize.width,height:positionOrSize.height/100*canvasSize.height}}function getPosition(position,canvasSize){return getPositionOrSize(position,canvasSize)}function getSize(size,canvasSize){return getPositionOrSize(size,canvasSize)}function isBoolean(arg){return"boolean"==typeof arg}function isString(arg){return"string"==typeof arg}function isNumber(arg){return"number"==typeof arg}function isObject(arg){return"object"==typeof arg&&null!==arg}function isArray(arg){return Array.isArray(arg)}const randomColorValue="random",colorManagers=new Map;function addColorManager(manager){colorManagers.set(manager.key,manager)}function stringToRgba(input){for(const[,manager]of colorManagers)if(input.startsWith(manager.stringPrefix))return manager.parseString(input);const hexFixed=input.replace(/^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i,((_,r,g,b,a)=>r+r+g+g+b+b+(void 0!==a?a+a:""))),result=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(hexFixed);return result?{a:void 0!==result[4]?parseInt(result[4],16)/255:1,b:parseInt(result[3],16),g:parseInt(result[2],16),r:parseInt(result[1],16)}:void 0}function rangeColorToRgb(input,index,useIndex=!0){if(!input)return;const color=isString(input)?{value:input}:input;if(isString(color.value))return colorToRgb(color.value,index,useIndex);if(isArray(color.value))return rangeColorToRgb({value:itemFromArray(color.value,index,useIndex)});for(const[,manager]of colorManagers){const res=manager.handleRangeColor(color);if(res)return res}}function colorToRgb(input,index,useIndex=!0){if(!input)return;const color=isString(input)?{value:input}:input;if(isString(color.value))return color.value===randomColorValue?getRandomRgbColor():function stringToRgb(input){return stringToRgba(input)}(color.value);if(isArray(color.value))return colorToRgb({value:itemFromArray(color.value,index,useIndex)});for(const[,manager]of colorManagers){const res=manager.handleColor(color);if(res)return res}}function rangeColorToHsl(color,index,useIndex=!0){const rgb=rangeColorToRgb(color,index,useIndex);return rgb?rgbToHsl(rgb):void 0}function rgbToHsl(color){const r1=color.r/255,g1=color.g/255,b1=color.b/255,max=Math.max(r1,g1,b1),min=Math.min(r1,g1,b1),res={h:0,l:.5*(max+min),s:0};return max!==min&&(res.s=res.l<.5?(max-min)/(max+min):(max-min)/(2-max-min),res.h=r1===max?(g1-b1)/(max-min):res.h=g1===max?2+(b1-r1)/(max-min):4+(r1-g1)/(max-min)),res.l*=100,res.s*=100,res.h*=60,res.h<0&&(res.h+=360),res.h>=360&&(res.h-=360),res}function hslToRgb(hsl){const h=(hsl.h%360+360)%360,s=Math.max(0,Math.min(100,hsl.s)),hNormalized=h/360,sNormalized=s/100,lNormalized=Math.max(0,Math.min(100,hsl.l))/100;if(0===s){const grayscaleValue=Math.round(255*lNormalized);return{r:grayscaleValue,g:grayscaleValue,b:grayscaleValue}}const channel=(temp1,temp2,temp3)=>(temp3<0&&(temp3+=1),temp3>1&&(temp3-=1),6*temp3<1?temp1+6*(temp2-temp1)*temp3:2*temp3<1?temp2:3*temp3<2?temp1+(temp2-temp1)*(2/3-temp3)*6:temp1),temp1=lNormalized<.5?lNormalized*(1+sNormalized):lNormalized+sNormalized-lNormalized*sNormalized,temp2=2*lNormalized-temp1,red=Math.min(255,255*channel(temp2,temp1,hNormalized+1/3)),green=Math.min(255,255*channel(temp2,temp1,hNormalized)),blue=Math.min(255,255*channel(temp2,temp1,hNormalized-1/3));return{r:Math.round(red),g:Math.round(green),b:Math.round(blue)}}function getRandomRgbColor(min){const fixedMin=min??0;return{b:Math.floor(randomInRange(setRangeValue(fixedMin,256))),g:Math.floor(randomInRange(setRangeValue(fixedMin,256))),r:Math.floor(randomInRange(setRangeValue(fixedMin,256)))}}function getStyleFromRgb(color,opacity){return`rgba(${color.r}, ${color.g}, ${color.b}, ${opacity??1})`}function getStyleFromHsl(color,opacity){return`hsla(${color.h}, ${color.s}%, ${color.l}%, ${opacity??1})`}function colorMix(color1,color2,size1,size2){let rgb1=color1,rgb2=color2;return void 0===rgb1.r&&(rgb1=hslToRgb(color1)),void 0===rgb2.r&&(rgb2=hslToRgb(color2)),{b:mix(rgb1.b,rgb2.b,size1,size2),g:mix(rgb1.g,rgb2.g,size1,size2),r:mix(rgb1.r,rgb2.r,size1,size2)}}function getLinkColor(p1,p2,linkColor){if(linkColor===randomColorValue)return getRandomRgbColor();if("mid"!==linkColor)return linkColor;{const sourceColor=p1.getFillColor()??p1.getStrokeColor(),destColor=p2?.getFillColor()??p2?.getStrokeColor();if(sourceColor&&destColor&&p2)return colorMix(sourceColor,destColor,p1.getRadius(),p2.getRadius());{const hslColor=sourceColor??destColor;if(hslColor)return hslToRgb(hslColor)}}}function getLinkRandomColor(optColor,blink,consent){const color=isString(optColor)?optColor:optColor.value;return color===randomColorValue?consent?rangeColorToRgb({value:color}):blink?randomColorValue:"mid":"mid"===color?"mid":rangeColorToRgb({value:color})}function getHslFromAnimation(animation){return void 0!==animation?{h:animation.h.value,s:animation.s.value,l:animation.l.value}:void 0}function getHslAnimationFromHsl(hsl,animationOptions,reduceFactor){const resColor={h:{enable:!1,value:hsl.h},s:{enable:!1,value:hsl.s},l:{enable:!1,value:hsl.l}};return animationOptions&&(setColorAnimation(resColor.h,animationOptions.h,reduceFactor),setColorAnimation(resColor.s,animationOptions.s,reduceFactor),setColorAnimation(resColor.l,animationOptions.l,reduceFactor)),resColor}function setColorAnimation(colorValue,colorAnimation,reduceFactor){colorValue.enable=colorAnimation.enable,colorValue.enable?(colorValue.velocity=getRangeValue(colorAnimation.speed)/100*reduceFactor,colorValue.decay=1-getRangeValue(colorAnimation.decay),colorValue.status="increasing",colorValue.loops=0,colorValue.maxLoops=getRangeValue(colorAnimation.count),colorValue.time=0,colorValue.delayTime=1e3*getRangeValue(colorAnimation.delay),colorAnimation.sync||(colorValue.velocity*=getRandom(),colorValue.value*=getRandom()),colorValue.initialValue=colorValue.value):colorValue.velocity=0}function drawLine(context,begin,end){context.beginPath(),context.moveTo(begin.x,begin.y),context.lineTo(end.x,end.y),context.closePath()}function clear(context,dimension){context.clearRect(0,0,dimension.width,dimension.height)}function setTransformValue(factor,newFactor,key){const newValue=newFactor[key];void 0!==newValue&&(factor[key]=(factor[key]??1)*newValue)}class Canvas{constructor(container){this.container=container,this._applyPostDrawUpdaters=particle=>{for(const updater of this._postDrawUpdaters)updater.afterDraw&&updater.afterDraw(particle)},this._applyPreDrawUpdaters=(ctx,particle,radius,zOpacity,colorStyles,transform)=>{for(const updater of this._preDrawUpdaters){if(updater.getColorStyles){const{fill,stroke}=updater.getColorStyles(particle,ctx,radius,zOpacity);fill&&(colorStyles.fill=fill),stroke&&(colorStyles.stroke=stroke)}if(updater.getTransformValues){const updaterTransform=updater.getTransformValues(particle);for(const key in updaterTransform)setTransformValue(transform,updaterTransform,key)}updater.beforeDraw&&updater.beforeDraw(particle)}},this._applyResizePlugins=()=>{for(const plugin of this._resizePlugins)plugin.resize&&plugin.resize()},this._getPluginParticleColors=particle=>{let fColor,sColor;for(const plugin of this._colorPlugins)if(!fColor&&plugin.particleFillColor&&(fColor=rangeColorToHsl(plugin.particleFillColor(particle))),!sColor&&plugin.particleStrokeColor&&(sColor=rangeColorToHsl(plugin.particleStrokeColor(particle))),fColor&&sColor)break;return[fColor,sColor]},this._initCover=()=>{const cover=this.container.actualOptions.backgroundMask.cover,coverRgb=rangeColorToRgb(cover.color);if(coverRgb){const coverColor={...coverRgb,a:cover.opacity};this._coverColorStyle=getStyleFromRgb(coverColor,coverColor.a)}},this._initStyle=()=>{const element=this.element,options=this.container.actualOptions;if(element){this._fullScreen?(this._originalStyle=deepExtend({},element.style),this._setFullScreenStyle()):this._resetOriginalStyle();for(const key in options.style){if(!key||!options.style)continue;const value=options.style[key];value&&element.style.setProperty(key,value,"important")}}},this._initTrail=async()=>{const options=this.container.actualOptions,trail=options.particles.move.trail,trailFill=trail.fill;if(trail.enable)if(trailFill.color){const fillColor=rangeColorToRgb(trailFill.color);if(!fillColor)return;const trail=options.particles.move.trail;this._trailFill={color:{...fillColor},opacity:1/trail.length}}else await new Promise(((resolve,reject)=>{if(!trailFill.image)return;const img=document.createElement("img");img.addEventListener("load",(()=>{this._trailFill={image:img,opacity:1/trail.length},resolve()})),img.addEventListener("error",(evt=>{reject(evt.error)})),img.src=trailFill.image}))},this._paintBase=baseColor=>{this.draw((ctx=>function paintBase(context,dimension,baseColor){context.fillStyle=baseColor??"rgba(0,0,0,0)",context.fillRect(0,0,dimension.width,dimension.height)}(ctx,this.size,baseColor)))},this._paintImage=(image,opacity)=>{this.draw((ctx=>function paintImage(context,dimension,image,opacity){image&&(context.globalAlpha=opacity,context.drawImage(image,0,0,dimension.width,dimension.height),context.globalAlpha=1)}(ctx,this.size,image,opacity)))},this._repairStyle=()=>{const element=this.element;element&&(this._safeMutationObserver((observer=>observer.disconnect())),this._initStyle(),this.initBackground(),this._safeMutationObserver((observer=>observer.observe(element,{attributes:!0}))))},this._resetOriginalStyle=()=>{const element=this.element,originalStyle=this._originalStyle;if(!element||!originalStyle)return;const style=element.style;style.position=originalStyle.position,style.zIndex=originalStyle.zIndex,style.top=originalStyle.top,style.left=originalStyle.left,style.width=originalStyle.width,style.height=originalStyle.height},this._safeMutationObserver=callback=>{this._mutationObserver&&callback(this._mutationObserver)},this._setFullScreenStyle=()=>{const element=this.element;if(!element)return;const style=element.style;style.setProperty("position","fixed","important"),style.setProperty("z-index",this.container.actualOptions.fullScreen.zIndex.toString(10),"important"),style.setProperty("top","0","important"),style.setProperty("left","0","important"),style.setProperty("width","100%","important"),style.setProperty("height","100%","important")},this.size={height:0,width:0},this._context=null,this._generated=!1,this._preDrawUpdaters=[],this._postDrawUpdaters=[],this._resizePlugins=[],this._colorPlugins=[]}get _fullScreen(){return this.container.actualOptions.fullScreen.enable}clear(){const options=this.container.actualOptions,trail=options.particles.move.trail,trailFill=this._trailFill;options.backgroundMask.enable?this.paint():trail.enable&&trail.length>0&&trailFill?trailFill.color?this._paintBase(getStyleFromRgb(trailFill.color,trailFill.opacity)):trailFill.image&&this._paintImage(trailFill.image,trailFill.opacity):options.clear&&this.draw((ctx=>{clear(ctx,this.size)}))}destroy(){if(this.stop(),this._generated){const element=this.element;element&&element.remove()}else this._resetOriginalStyle();this._preDrawUpdaters=[],this._postDrawUpdaters=[],this._resizePlugins=[],this._colorPlugins=[]}draw(cb){const ctx=this._context;if(ctx)return cb(ctx)}drawParticle(particle,delta){if(particle.spawning||particle.destroyed)return;const radius=particle.getRadius();if(radius<=0)return;const pfColor=particle.getFillColor(),psColor=particle.getStrokeColor()??pfColor;let[fColor,sColor]=this._getPluginParticleColors(particle);fColor||(fColor=pfColor),sColor||(sColor=psColor),(fColor||sColor)&&this.draw((ctx=>{const container=this.container,options=container.actualOptions,zIndexOptions=particle.options.zIndex,zOpacityFactor=(1-particle.zIndexFactor)**zIndexOptions.opacityRate,opacity=particle.bubble.opacity??particle.opacity?.value??1,zOpacity=opacity*zOpacityFactor,zStrokeOpacity=(particle.strokeOpacity??opacity)*zOpacityFactor,transform={},colorStyles={fill:fColor?getStyleFromHsl(fColor,zOpacity):void 0};colorStyles.stroke=sColor?getStyleFromHsl(sColor,zStrokeOpacity):colorStyles.fill,this._applyPreDrawUpdaters(ctx,particle,radius,zOpacity,colorStyles,transform),function drawParticle(data){const{container,context,particle,delta,colorStyles,backgroundMask,composite,radius,opacity,shadow,transform}=data,pos=particle.getPosition(),angle=particle.rotation+(particle.pathRotation?particle.velocity.angle:0),rotateData_sin=Math.sin(angle),rotateData_cos=Math.cos(angle),transformData={a:rotateData_cos*(transform.a??1),b:rotateData_sin*(transform.b??1),c:-rotateData_sin*(transform.c??1),d:rotateData_cos*(transform.d??1)};context.setTransform(transformData.a,transformData.b,transformData.c,transformData.d,pos.x,pos.y),backgroundMask&&(context.globalCompositeOperation=composite);const shadowColor=particle.shadowColor;shadow.enable&&shadowColor&&(context.shadowBlur=shadow.blur,context.shadowColor=getStyleFromRgb(shadowColor),context.shadowOffsetX=shadow.offset.x,context.shadowOffsetY=shadow.offset.y),colorStyles.fill&&(context.fillStyle=colorStyles.fill);const strokeWidth=particle.strokeWidth??0;context.lineWidth=strokeWidth,colorStyles.stroke&&(context.strokeStyle=colorStyles.stroke);const drawData={container,context,particle,radius,opacity,delta,transformData};context.beginPath(),function drawShape(data){const{container,context,particle,radius,opacity,delta,transformData}=data;if(!particle.shape)return;const drawer=container.shapeDrawers.get(particle.shape);drawer&&drawer.draw({context,particle,radius,opacity,delta,pixelRatio:container.retina.pixelRatio,transformData:{...transformData}})}(drawData),particle.shapeClose&&context.closePath(),strokeWidth>0&&context.stroke(),particle.shapeFill&&context.fill(),function drawShapeAfterDraw(data){const{container,context,particle,radius,opacity,delta,transformData}=data;if(!particle.shape)return;const drawer=container.shapeDrawers.get(particle.shape);drawer&&drawer.afterDraw&&drawer.afterDraw({context,particle,radius,opacity,delta,pixelRatio:container.retina.pixelRatio,transformData:{...transformData}})}(drawData),function drawEffect(data){const{container,context,particle,radius,opacity,delta,transformData}=data;if(!particle.effect)return;const drawer=container.effectDrawers.get(particle.effect);drawer&&drawer.draw({context,particle,radius,opacity,delta,pixelRatio:container.retina.pixelRatio,transformData:{...transformData}})}(drawData),context.globalCompositeOperation="source-over",context.setTransform(1,0,0,1,0,0)}({container,context:ctx,particle,delta,colorStyles,backgroundMask:options.backgroundMask.enable,composite:options.backgroundMask.composite,radius:radius*(1-particle.zIndexFactor)**zIndexOptions.sizeRate,opacity:zOpacity,shadow:particle.options.shadow,transform}),this._applyPostDrawUpdaters(particle)}))}drawParticlePlugin(plugin,particle,delta){this.draw((ctx=>function drawParticlePlugin(context,plugin,particle,delta){plugin.drawParticle&&plugin.drawParticle(context,particle,delta)}(ctx,plugin,particle,delta)))}drawPlugin(plugin,delta){this.draw((ctx=>function drawPlugin(context,plugin,delta){plugin.draw&&plugin.draw(context,delta)}(ctx,plugin,delta)))}async init(){this._safeMutationObserver((obs=>obs.disconnect())),this._mutationObserver=function safeMutationObserver(callback){if(!isSsr()&&"undefined"!=typeof MutationObserver)return new MutationObserver(callback)}((records=>{for(const record of records)"attributes"===record.type&&"style"===record.attributeName&&this._repairStyle()})),this.resize(),this._initStyle(),this._initCover();try{await this._initTrail()}catch(e){getLogger().error(e)}this.initBackground(),this._safeMutationObserver((obs=>{this.element&&obs.observe(this.element,{attributes:!0})})),this.initUpdaters(),this.initPlugins(),this.paint()}initBackground(){const background=this.container.actualOptions.background,element=this.element;if(!element)return;const elementStyle=element.style;if(elementStyle){if(background.color){const color=rangeColorToRgb(background.color);elementStyle.backgroundColor=color?getStyleFromRgb(color,background.opacity):""}else elementStyle.backgroundColor="";elementStyle.backgroundImage=background.image||"",elementStyle.backgroundPosition=background.position||"",elementStyle.backgroundRepeat=background.repeat||"",elementStyle.backgroundSize=background.size||""}}initPlugins(){this._resizePlugins=[];for(const[,plugin]of this.container.plugins)plugin.resize&&this._resizePlugins.push(plugin),(plugin.particleFillColor||plugin.particleStrokeColor)&&this._colorPlugins.push(plugin)}initUpdaters(){this._preDrawUpdaters=[],this._postDrawUpdaters=[];for(const updater of this.container.particles.updaters)updater.afterDraw&&this._postDrawUpdaters.push(updater),(updater.getColorStyles||updater.getTransformValues||updater.beforeDraw)&&this._preDrawUpdaters.push(updater)}loadCanvas(canvas){this._generated&&this.element&&this.element.remove(),this._generated=canvas.dataset&&"generated"in canvas.dataset?"true"===canvas.dataset.generated:this._generated,this.element=canvas,this.element.ariaHidden="true",this._originalStyle=deepExtend({},this.element.style),this.size.height=canvas.offsetHeight,this.size.width=canvas.offsetWidth,this._context=this.element.getContext("2d"),this._safeMutationObserver((obs=>{this.element&&obs.observe(this.element,{attributes:!0})})),this.container.retina.init(),this.initBackground()}paint(){const options=this.container.actualOptions;this.draw((ctx=>{options.backgroundMask.enable&&options.backgroundMask.cover?(clear(ctx,this.size),this._paintBase(this._coverColorStyle)):this._paintBase()}))}resize(){if(!this.element)return!1;const container=this.container,pxRatio=container.retina.pixelRatio,size=container.canvas.size,newSize_width=this.element.offsetWidth*pxRatio,newSize_height=this.element.offsetHeight*pxRatio;if(newSize_height===size.height&&newSize_width===size.width&&newSize_height===this.element.height&&newSize_width===this.element.width)return!1;const oldSize={...size};return this.element.width=size.width=this.element.offsetWidth*pxRatio,this.element.height=size.height=this.element.offsetHeight*pxRatio,this.container.started&&container.particles.setResizeFactor({width:size.width/oldSize.width,height:size.height/oldSize.height}),!0}stop(){this._safeMutationObserver((obs=>obs.disconnect())),this._mutationObserver=void 0,this.draw((ctx=>clear(ctx,this.size)))}async windowResize(){if(!this.element||!this.resize())return;const container=this.container,needsRefresh=container.updateActualOptions();container.particles.setDensity(),this._applyResizePlugins(),needsRefresh&&await container.refresh()}}function manageListener(element,event,handler,add,options){if(add){let addOptions={passive:!0};isBoolean(options)?addOptions.capture=options:void 0!==options&&(addOptions=options),element.addEventListener(event,handler,addOptions)}else{const removeOptions=options;element.removeEventListener(event,handler,removeOptions)}}class EventListeners{constructor(container){this.container=container,this._doMouseTouchClick=e=>{const container=this.container,options=container.actualOptions;if(this._canPush){const mouseInteractivity=container.interactivity.mouse,mousePos=mouseInteractivity.position;if(!mousePos)return;mouseInteractivity.clickPosition={...mousePos},mouseInteractivity.clickTime=(new Date).getTime();executeOnSingleOrMultiple(options.interactivity.events.onClick.mode,(mode=>this.container.handleClickMode(mode)))}"touchend"===e.type&&setTimeout((()=>this._mouseTouchFinish()),500)},this._handleThemeChange=e=>{const mediaEvent=e,container=this.container,options=container.options,defaultThemes=options.defaultThemes,themeName=mediaEvent.matches?defaultThemes.dark:defaultThemes.light,theme=options.themes.find((theme=>theme.name===themeName));theme&&theme.default.auto&&container.loadTheme(themeName)},this._handleVisibilityChange=()=>{const container=this.container,options=container.actualOptions;this._mouseTouchFinish(),options.pauseOnBlur&&(document&&document.hidden?(container.pageHidden=!0,container.pause()):(container.pageHidden=!1,container.getAnimationStatus()?container.play(!0):container.draw(!0)))},this._handleWindowResize=async()=>{this._resizeTimeout&&(clearTimeout(this._resizeTimeout),delete this._resizeTimeout),this._resizeTimeout=setTimeout((async()=>{const canvas=this.container.canvas;canvas&&await canvas.windowResize()}),1e3*this.container.actualOptions.interactivity.events.resize.delay)},this._manageInteractivityListeners=(mouseLeaveTmpEvent,add)=>{const handlers=this._handlers,container=this.container,options=container.actualOptions,interactivityEl=container.interactivity.element;if(!interactivityEl)return;const html=interactivityEl,canvasEl=container.canvas.element;canvasEl&&(canvasEl.style.pointerEvents=html===canvasEl?"initial":"none"),(options.interactivity.events.onHover.enable||options.interactivity.events.onClick.enable)&&(manageListener(interactivityEl,"pointermove",handlers.mouseMove,add),manageListener(interactivityEl,"touchstart",handlers.touchStart,add),manageListener(interactivityEl,"touchmove",handlers.touchMove,add),options.interactivity.events.onClick.enable?(manageListener(interactivityEl,"touchend",handlers.touchEndClick,add),manageListener(interactivityEl,"pointerup",handlers.mouseUp,add),manageListener(interactivityEl,"pointerdown",handlers.mouseDown,add)):manageListener(interactivityEl,"touchend",handlers.touchEnd,add),manageListener(interactivityEl,mouseLeaveTmpEvent,handlers.mouseLeave,add),manageListener(interactivityEl,"touchcancel",handlers.touchCancel,add))},this._manageListeners=add=>{const handlers=this._handlers,container=this.container,detectType=container.actualOptions.interactivity.detectsOn,canvasEl=container.canvas.element;let mouseLeaveTmpEvent="pointerleave";"window"===detectType?(container.interactivity.element=window,mouseLeaveTmpEvent="pointerout"):container.interactivity.element="parent"===detectType&&canvasEl?canvasEl.parentElement??canvasEl.parentNode:canvasEl,this._manageMediaMatch(add),this._manageResize(add),this._manageInteractivityListeners(mouseLeaveTmpEvent,add),document&&manageListener(document,"visibilitychange",handlers.visibilityChange,add,!1)},this._manageMediaMatch=add=>{const handlers=this._handlers,mediaMatch=safeMatchMedia("(prefers-color-scheme: dark)");mediaMatch&&(void 0===mediaMatch.addEventListener?void 0!==mediaMatch.addListener&&(add?mediaMatch.addListener(handlers.oldThemeChange):mediaMatch.removeListener(handlers.oldThemeChange)):manageListener(mediaMatch,"change",handlers.themeChange,add))},this._manageResize=add=>{const handlers=this._handlers,container=this.container;if(!container.actualOptions.interactivity.events.resize)return;if("undefined"==typeof ResizeObserver)return void manageListener(window,"resize",handlers.resize,add);const canvasEl=container.canvas.element;this._resizeObserver&&!add?(canvasEl&&this._resizeObserver.unobserve(canvasEl),this._resizeObserver.disconnect(),delete this._resizeObserver):!this._resizeObserver&&add&&canvasEl&&(this._resizeObserver=new ResizeObserver((async entries=>{entries.find((e=>e.target===canvasEl))&&await this._handleWindowResize()})),this._resizeObserver.observe(canvasEl))},this._mouseDown=()=>{const{interactivity}=this.container;if(!interactivity)return;const{mouse}=interactivity;mouse.clicking=!0,mouse.downPosition=mouse.position},this._mouseTouchClick=e=>{const container=this.container,options=container.actualOptions,{mouse}=container.interactivity;mouse.inside=!0;let handled=!1;const mousePosition=mouse.position;if(mousePosition&&options.interactivity.events.onClick.enable){for(const[,plugin]of container.plugins)if(plugin.clickPositionValid&&(handled=plugin.clickPositionValid(mousePosition),handled))break;handled||this._doMouseTouchClick(e),mouse.clicking=!1}},this._mouseTouchFinish=()=>{const interactivity=this.container.interactivity;if(!interactivity)return;const mouse=interactivity.mouse;delete mouse.position,delete mouse.clickPosition,delete mouse.downPosition,interactivity.status="pointerleave",mouse.inside=!1,mouse.clicking=!1},this._mouseTouchMove=e=>{const container=this.container,options=container.actualOptions,interactivity=container.interactivity,canvasEl=container.canvas.element;if(!interactivity||!interactivity.element)return;let pos;if(interactivity.mouse.inside=!0,e.type.startsWith("pointer")){this._canPush=!0;const mouseEvent=e;if(interactivity.element===window){if(canvasEl){const clientRect=canvasEl.getBoundingClientRect();pos={x:mouseEvent.clientX-clientRect.left,y:mouseEvent.clientY-clientRect.top}}}else if("parent"===options.interactivity.detectsOn){const source=mouseEvent.target,target=mouseEvent.currentTarget;if(source&&target&&canvasEl){const sourceRect=source.getBoundingClientRect(),targetRect=target.getBoundingClientRect(),canvasRect=canvasEl.getBoundingClientRect();pos={x:mouseEvent.offsetX+2*sourceRect.left-(targetRect.left+canvasRect.left),y:mouseEvent.offsetY+2*sourceRect.top-(targetRect.top+canvasRect.top)}}else pos={x:mouseEvent.offsetX??mouseEvent.clientX,y:mouseEvent.offsetY??mouseEvent.clientY}}else mouseEvent.target===canvasEl&&(pos={x:mouseEvent.offsetX??mouseEvent.clientX,y:mouseEvent.offsetY??mouseEvent.clientY})}else if(this._canPush="touchmove"!==e.type,canvasEl){const touchEvent=e,lastTouch=touchEvent.touches[touchEvent.touches.length-1],canvasRect=canvasEl.getBoundingClientRect();pos={x:lastTouch.clientX-(canvasRect.left??0),y:lastTouch.clientY-(canvasRect.top??0)}}const pxRatio=container.retina.pixelRatio;pos&&(pos.x*=pxRatio,pos.y*=pxRatio),interactivity.mouse.position=pos,interactivity.status="pointermove"},this._touchEnd=e=>{const evt=e,touches=Array.from(evt.changedTouches);for(const touch of touches)this._touches.delete(touch.identifier);this._mouseTouchFinish()},this._touchEndClick=e=>{const evt=e,touches=Array.from(evt.changedTouches);for(const touch of touches)this._touches.delete(touch.identifier);this._mouseTouchClick(e)},this._touchStart=e=>{const evt=e,touches=Array.from(evt.changedTouches);for(const touch of touches)this._touches.set(touch.identifier,performance.now());this._mouseTouchMove(e)},this._canPush=!0,this._touches=new Map,this._handlers={mouseDown:()=>this._mouseDown(),mouseLeave:()=>this._mouseTouchFinish(),mouseMove:e=>this._mouseTouchMove(e),mouseUp:e=>this._mouseTouchClick(e),touchStart:e=>this._touchStart(e),touchMove:e=>this._mouseTouchMove(e),touchEnd:e=>this._touchEnd(e),touchCancel:e=>this._touchEnd(e),touchEndClick:e=>this._touchEndClick(e),visibilityChange:()=>this._handleVisibilityChange(),themeChange:e=>this._handleThemeChange(e),oldThemeChange:e=>this._handleThemeChange(e),resize:()=>{this._handleWindowResize()}}}addListeners(){this._manageListeners(!0)}removeListeners(){this._manageListeners(!1)}}class OptionsColor{constructor(){this.value=""}static create(source,data){const color=new OptionsColor;return color.load(source),void 0!==data&&(isString(data)||isArray(data)?color.load({value:data}):color.load(data)),color}load(data){void 0!==data?.value&&(this.value=data.value)}}class Background{constructor(){this.color=new OptionsColor,this.color.value="",this.image="",this.position="",this.repeat="",this.size="",this.opacity=1}load(data){data&&(void 0!==data.color&&(this.color=OptionsColor.create(this.color,data.color)),void 0!==data.image&&(this.image=data.image),void 0!==data.position&&(this.position=data.position),void 0!==data.repeat&&(this.repeat=data.repeat),void 0!==data.size&&(this.size=data.size),void 0!==data.opacity&&(this.opacity=data.opacity))}}class BackgroundMaskCover{constructor(){this.color=new OptionsColor,this.color.value="#fff",this.opacity=1}load(data){data&&(void 0!==data.color&&(this.color=OptionsColor.create(this.color,data.color)),void 0!==data.opacity&&(this.opacity=data.opacity))}}class BackgroundMask{constructor(){this.composite="destination-out",this.cover=new BackgroundMaskCover,this.enable=!1}load(data){if(data){if(void 0!==data.composite&&(this.composite=data.composite),void 0!==data.cover){const cover=data.cover,color=isString(data.cover)?{color:data.cover}:data.cover;this.cover.load(void 0!==cover.color?cover:{color})}void 0!==data.enable&&(this.enable=data.enable)}}}class FullScreen{constructor(){this.enable=!0,this.zIndex=0}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.zIndex&&(this.zIndex=data.zIndex))}}class ClickEvent{constructor(){this.enable=!1,this.mode=[]}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.mode&&(this.mode=data.mode))}}class DivEvent{constructor(){this.selectors=[],this.enable=!1,this.mode=[],this.type="circle"}load(data){data&&(void 0!==data.selectors&&(this.selectors=data.selectors),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.mode&&(this.mode=data.mode),void 0!==data.type&&(this.type=data.type))}}class Parallax{constructor(){this.enable=!1,this.force=2,this.smooth=10}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.force&&(this.force=data.force),void 0!==data.smooth&&(this.smooth=data.smooth))}}class HoverEvent{constructor(){this.enable=!1,this.mode=[],this.parallax=new Parallax}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.mode&&(this.mode=data.mode),this.parallax.load(data.parallax))}}class ResizeEvent{constructor(){this.delay=.5,this.enable=!0}load(data){void 0!==data&&(void 0!==data.delay&&(this.delay=data.delay),void 0!==data.enable&&(this.enable=data.enable))}}class Events{constructor(){this.onClick=new ClickEvent,this.onDiv=new DivEvent,this.onHover=new HoverEvent,this.resize=new ResizeEvent}load(data){if(!data)return;this.onClick.load(data.onClick);const onDiv=data.onDiv;void 0!==onDiv&&(this.onDiv=executeOnSingleOrMultiple(onDiv,(t=>{const tmp=new DivEvent;return tmp.load(t),tmp}))),this.onHover.load(data.onHover),this.resize.load(data.resize)}}class Modes{constructor(engine,container){this._engine=engine,this._container=container}load(data){if(!data)return;if(!this._container)return;const interactors=this._engine.interactors.get(this._container);if(interactors)for(const interactor of interactors)interactor.loadModeOptions&&interactor.loadModeOptions(this,data)}}class Interactivity{constructor(engine,container){this.detectsOn="window",this.events=new Events,this.modes=new Modes(engine,container)}load(data){if(!data)return;const detectsOn=data.detectsOn;void 0!==detectsOn&&(this.detectsOn=detectsOn),this.events.load(data.events),this.modes.load(data.modes)}}class ManualParticle{load(data){data&&(data.position&&(this.position={x:data.position.x??50,y:data.position.y??50,mode:data.position.mode??"percent"}),data.options&&(this.options=deepExtend({},data.options)))}}class Responsive{constructor(){this.maxWidth=1/0,this.options={},this.mode="canvas"}load(data){data&&(void 0!==data.maxWidth&&(this.maxWidth=data.maxWidth),void 0!==data.mode&&("screen"===data.mode?this.mode="screen":this.mode="canvas"),void 0!==data.options&&(this.options=deepExtend({},data.options)))}}class ThemeDefault{constructor(){this.auto=!1,this.mode="any",this.value=!1}load(data){data&&(void 0!==data.auto&&(this.auto=data.auto),void 0!==data.mode&&(this.mode=data.mode),void 0!==data.value&&(this.value=data.value))}}class Theme{constructor(){this.name="",this.default=new ThemeDefault}load(data){data&&(void 0!==data.name&&(this.name=data.name),this.default.load(data.default),void 0!==data.options&&(this.options=deepExtend({},data.options)))}}class AnimationOptions{constructor(){this.count=0,this.enable=!1,this.speed=1,this.decay=0,this.delay=0,this.sync=!1}load(data){data&&(void 0!==data.count&&(this.count=setRangeValue(data.count)),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.speed&&(this.speed=setRangeValue(data.speed)),void 0!==data.decay&&(this.decay=setRangeValue(data.decay)),void 0!==data.delay&&(this.delay=setRangeValue(data.delay)),void 0!==data.sync&&(this.sync=data.sync))}}class RangedAnimationOptions extends AnimationOptions{constructor(){super(),this.mode="auto",this.startValue="random"}load(data){super.load(data),data&&(void 0!==data.mode&&(this.mode=data.mode),void 0!==data.startValue&&(this.startValue=data.startValue))}}class ColorAnimation extends AnimationOptions{constructor(){super(),this.offset=0,this.sync=!0}load(data){super.load(data),data&&void 0!==data.offset&&(this.offset=setRangeValue(data.offset))}}class HslAnimation{constructor(){this.h=new ColorAnimation,this.s=new ColorAnimation,this.l=new ColorAnimation}load(data){data&&(this.h.load(data.h),this.s.load(data.s),this.l.load(data.l))}}class AnimatableColor extends OptionsColor{constructor(){super(),this.animation=new HslAnimation}static create(source,data){const color=new AnimatableColor;return color.load(source),void 0!==data&&(isString(data)||isArray(data)?color.load({value:data}):color.load(data)),color}load(data){if(super.load(data),!data)return;const colorAnimation=data.animation;void 0!==colorAnimation&&(void 0!==colorAnimation.enable?this.animation.h.load(colorAnimation):this.animation.load(data.animation))}}class CollisionsAbsorb{constructor(){this.speed=2}load(data){data&&void 0!==data.speed&&(this.speed=data.speed)}}class CollisionsOverlap{constructor(){this.enable=!0,this.retries=0}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.retries&&(this.retries=data.retries))}}class ValueWithRandom{constructor(){this.value=0}load(data){data&&void 0!==data.value&&(this.value=setRangeValue(data.value))}}class AnimationValueWithRandom extends ValueWithRandom{constructor(){super(),this.animation=new AnimationOptions}load(data){if(super.load(data),!data)return;const animation=data.animation;void 0!==animation&&this.animation.load(animation)}}class RangedAnimationValueWithRandom extends AnimationValueWithRandom{constructor(){super(),this.animation=new RangedAnimationOptions}load(data){super.load(data)}}class ParticlesBounceFactor extends ValueWithRandom{constructor(){super(),this.value=1}}class ParticlesBounce{constructor(){this.horizontal=new ParticlesBounceFactor,this.vertical=new ParticlesBounceFactor}load(data){data&&(this.horizontal.load(data.horizontal),this.vertical.load(data.vertical))}}class Collisions{constructor(){this.absorb=new CollisionsAbsorb,this.bounce=new ParticlesBounce,this.enable=!1,this.maxSpeed=50,this.mode="bounce",this.overlap=new CollisionsOverlap}load(data){data&&(this.absorb.load(data.absorb),this.bounce.load(data.bounce),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.maxSpeed&&(this.maxSpeed=setRangeValue(data.maxSpeed)),void 0!==data.mode&&(this.mode=data.mode),this.overlap.load(data.overlap))}}class Effect{constructor(){this.close=!0,this.fill=!0,this.options={},this.type=[]}load(data){if(!data)return;const options=data.options;if(void 0!==options)for(const effect in options){const item=options[effect];item&&(this.options[effect]=deepExtend(this.options[effect]??{},item))}void 0!==data.close&&(this.close=data.close),void 0!==data.fill&&(this.fill=data.fill),void 0!==data.type&&(this.type=data.type)}}class MoveAngle{constructor(){this.offset=0,this.value=90}load(data){data&&(void 0!==data.offset&&(this.offset=setRangeValue(data.offset)),void 0!==data.value&&(this.value=setRangeValue(data.value)))}}class MoveAttract{constructor(){this.distance=200,this.enable=!1,this.rotate={x:3e3,y:3e3}}load(data){if(data&&(void 0!==data.distance&&(this.distance=setRangeValue(data.distance)),void 0!==data.enable&&(this.enable=data.enable),data.rotate)){const rotateX=data.rotate.x;void 0!==rotateX&&(this.rotate.x=rotateX);const rotateY=data.rotate.y;void 0!==rotateY&&(this.rotate.y=rotateY)}}}class MoveCenter{constructor(){this.x=50,this.y=50,this.mode="percent",this.radius=0}load(data){data&&(void 0!==data.x&&(this.x=data.x),void 0!==data.y&&(this.y=data.y),void 0!==data.mode&&(this.mode=data.mode),void 0!==data.radius&&(this.radius=data.radius))}}class MoveGravity{constructor(){this.acceleration=9.81,this.enable=!1,this.inverse=!1,this.maxSpeed=50}load(data){data&&(void 0!==data.acceleration&&(this.acceleration=setRangeValue(data.acceleration)),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.inverse&&(this.inverse=data.inverse),void 0!==data.maxSpeed&&(this.maxSpeed=setRangeValue(data.maxSpeed)))}}class MovePath{constructor(){this.clamp=!0,this.delay=new ValueWithRandom,this.enable=!1,this.options={}}load(data){data&&(void 0!==data.clamp&&(this.clamp=data.clamp),this.delay.load(data.delay),void 0!==data.enable&&(this.enable=data.enable),this.generator=data.generator,data.options&&(this.options=deepExtend(this.options,data.options)))}}class MoveTrailFill{load(data){data&&(void 0!==data.color&&(this.color=OptionsColor.create(this.color,data.color)),void 0!==data.image&&(this.image=data.image))}}class MoveTrail{constructor(){this.enable=!1,this.length=10,this.fill=new MoveTrailFill}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.fill&&this.fill.load(data.fill),void 0!==data.length&&(this.length=data.length))}}class OutModes{constructor(){this.default="out"}load(data){data&&(void 0!==data.default&&(this.default=data.default),this.bottom=data.bottom??data.default,this.left=data.left??data.default,this.right=data.right??data.default,this.top=data.top??data.default)}}class Spin{constructor(){this.acceleration=0,this.enable=!1}load(data){data&&(void 0!==data.acceleration&&(this.acceleration=setRangeValue(data.acceleration)),void 0!==data.enable&&(this.enable=data.enable),data.position&&(this.position=deepExtend({},data.position)))}}class Move{constructor(){this.angle=new MoveAngle,this.attract=new MoveAttract,this.center=new MoveCenter,this.decay=0,this.distance={},this.direction="none",this.drift=0,this.enable=!1,this.gravity=new MoveGravity,this.path=new MovePath,this.outModes=new OutModes,this.random=!1,this.size=!1,this.speed=2,this.spin=new Spin,this.straight=!1,this.trail=new MoveTrail,this.vibrate=!1,this.warp=!1}load(data){if(!data)return;this.angle.load(isNumber(data.angle)?{value:data.angle}:data.angle),this.attract.load(data.attract),this.center.load(data.center),void 0!==data.decay&&(this.decay=setRangeValue(data.decay)),void 0!==data.direction&&(this.direction=data.direction),void 0!==data.distance&&(this.distance=isNumber(data.distance)?{horizontal:data.distance,vertical:data.distance}:{...data.distance}),void 0!==data.drift&&(this.drift=setRangeValue(data.drift)),void 0!==data.enable&&(this.enable=data.enable),this.gravity.load(data.gravity);const outModes=data.outModes;void 0!==outModes&&(isObject(outModes)?this.outModes.load(outModes):this.outModes.load({default:outModes})),this.path.load(data.path),void 0!==data.random&&(this.random=data.random),void 0!==data.size&&(this.size=data.size),void 0!==data.speed&&(this.speed=setRangeValue(data.speed)),this.spin.load(data.spin),void 0!==data.straight&&(this.straight=data.straight),this.trail.load(data.trail),void 0!==data.vibrate&&(this.vibrate=data.vibrate),void 0!==data.warp&&(this.warp=data.warp)}}class OpacityAnimation extends RangedAnimationOptions{constructor(){super(),this.destroy="none",this.speed=2}load(data){super.load(data),data&&void 0!==data.destroy&&(this.destroy=data.destroy)}}class Opacity extends RangedAnimationValueWithRandom{constructor(){super(),this.animation=new OpacityAnimation,this.value=1}load(data){if(!data)return;super.load(data);const animation=data.animation;void 0!==animation&&this.animation.load(animation)}}class ParticlesDensity{constructor(){this.enable=!1,this.width=1920,this.height=1080}load(data){if(!data)return;void 0!==data.enable&&(this.enable=data.enable);const width=data.width;void 0!==width&&(this.width=width);const height=data.height;void 0!==height&&(this.height=height)}}class ParticlesNumberLimit{constructor(){this.mode="delete",this.value=0}load(data){data&&(void 0!==data.mode&&(this.mode=data.mode),void 0!==data.value&&(this.value=data.value))}}class ParticlesNumber{constructor(){this.density=new ParticlesDensity,this.limit=new ParticlesNumberLimit,this.value=0}load(data){data&&(this.density.load(data.density),this.limit.load(data.limit),void 0!==data.value&&(this.value=data.value))}}class Shadow{constructor(){this.blur=0,this.color=new OptionsColor,this.enable=!1,this.offset={x:0,y:0},this.color.value="#000"}load(data){data&&(void 0!==data.blur&&(this.blur=data.blur),this.color=OptionsColor.create(this.color,data.color),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.offset&&(void 0!==data.offset.x&&(this.offset.x=data.offset.x),void 0!==data.offset.y&&(this.offset.y=data.offset.y)))}}class Shape{constructor(){this.close=!0,this.fill=!0,this.options={},this.type="circle"}load(data){if(!data)return;const options=data.options;if(void 0!==options)for(const shape in options){const item=options[shape];item&&(this.options[shape]=deepExtend(this.options[shape]??{},item))}void 0!==data.close&&(this.close=data.close),void 0!==data.fill&&(this.fill=data.fill),void 0!==data.type&&(this.type=data.type)}}class SizeAnimation extends RangedAnimationOptions{constructor(){super(),this.destroy="none",this.speed=5}load(data){super.load(data),data&&void 0!==data.destroy&&(this.destroy=data.destroy)}}class Size extends RangedAnimationValueWithRandom{constructor(){super(),this.animation=new SizeAnimation,this.value=3}load(data){if(super.load(data),!data)return;const animation=data.animation;void 0!==animation&&this.animation.load(animation)}}class Stroke{constructor(){this.width=0}load(data){data&&(void 0!==data.color&&(this.color=AnimatableColor.create(this.color,data.color)),void 0!==data.width&&(this.width=setRangeValue(data.width)),void 0!==data.opacity&&(this.opacity=setRangeValue(data.opacity)))}}class ZIndex extends ValueWithRandom{constructor(){super(),this.opacityRate=1,this.sizeRate=1,this.velocityRate=1}load(data){super.load(data),data&&(void 0!==data.opacityRate&&(this.opacityRate=data.opacityRate),void 0!==data.sizeRate&&(this.sizeRate=data.sizeRate),void 0!==data.velocityRate&&(this.velocityRate=data.velocityRate))}}class ParticlesOptions{constructor(engine,container){this._engine=engine,this._container=container,this.bounce=new ParticlesBounce,this.collisions=new Collisions,this.color=new AnimatableColor,this.color.value="#fff",this.effect=new Effect,this.groups={},this.move=new Move,this.number=new ParticlesNumber,this.opacity=new Opacity,this.reduceDuplicates=!1,this.shadow=new Shadow,this.shape=new Shape,this.size=new Size,this.stroke=new Stroke,this.zIndex=new ZIndex}load(data){if(!data)return;if(void 0!==data.groups)for(const group of Object.keys(data.groups)){if(!Object.hasOwn(data.groups,group))continue;const item=data.groups[group];void 0!==item&&(this.groups[group]=deepExtend(this.groups[group]??{},item))}void 0!==data.reduceDuplicates&&(this.reduceDuplicates=data.reduceDuplicates),this.bounce.load(data.bounce),this.color.load(AnimatableColor.create(this.color,data.color)),this.effect.load(data.effect),this.move.load(data.move),this.number.load(data.number),this.opacity.load(data.opacity),this.shape.load(data.shape),this.size.load(data.size),this.shadow.load(data.shadow),this.zIndex.load(data.zIndex),this.collisions.load(data.collisions),void 0!==data.interactivity&&(this.interactivity=deepExtend({},data.interactivity));const strokeToLoad=data.stroke;if(strokeToLoad&&(this.stroke=executeOnSingleOrMultiple(strokeToLoad,(t=>{const tmp=new Stroke;return tmp.load(t),tmp}))),this._container){const updaters=this._engine.updaters.get(this._container);if(updaters)for(const updater of updaters)updater.loadOptions&&updater.loadOptions(this,data);const interactors=this._engine.interactors.get(this._container);if(interactors)for(const interactor of interactors)interactor.loadParticlesOptions&&interactor.loadParticlesOptions(this,data)}}}function loadOptions(options,...sourceOptionsArr){for(const sourceOptions of sourceOptionsArr)options.load(sourceOptions)}function loadParticlesOptions(engine,container,...sourceOptionsArr){const options=new ParticlesOptions(engine,container);return loadOptions(options,...sourceOptionsArr),options}class Options{constructor(engine,container){this._findDefaultTheme=mode=>this.themes.find((theme=>theme.default.value&&theme.default.mode===mode))??this.themes.find((theme=>theme.default.value&&"any"===theme.default.mode)),this._importPreset=preset=>{this.load(this._engine.getPreset(preset))},this._engine=engine,this._container=container,this.autoPlay=!0,this.background=new Background,this.backgroundMask=new BackgroundMask,this.clear=!0,this.defaultThemes={},this.delay=0,this.fullScreen=new FullScreen,this.detectRetina=!0,this.duration=0,this.fpsLimit=120,this.interactivity=new Interactivity(engine,container),this.manualParticles=[],this.particles=loadParticlesOptions(this._engine,this._container),this.pauseOnBlur=!0,this.pauseOnOutsideViewport=!0,this.responsive=[],this.smooth=!1,this.style={},this.themes=[],this.zLayers=100}load(data){if(!data)return;void 0!==data.preset&&executeOnSingleOrMultiple(data.preset,(preset=>this._importPreset(preset))),void 0!==data.autoPlay&&(this.autoPlay=data.autoPlay),void 0!==data.clear&&(this.clear=data.clear),void 0!==data.name&&(this.name=data.name),void 0!==data.delay&&(this.delay=setRangeValue(data.delay));const detectRetina=data.detectRetina;void 0!==detectRetina&&(this.detectRetina=detectRetina),void 0!==data.duration&&(this.duration=setRangeValue(data.duration));const fpsLimit=data.fpsLimit;void 0!==fpsLimit&&(this.fpsLimit=fpsLimit),void 0!==data.pauseOnBlur&&(this.pauseOnBlur=data.pauseOnBlur),void 0!==data.pauseOnOutsideViewport&&(this.pauseOnOutsideViewport=data.pauseOnOutsideViewport),void 0!==data.zLayers&&(this.zLayers=data.zLayers),this.background.load(data.background);const fullScreen=data.fullScreen;isBoolean(fullScreen)?this.fullScreen.enable=fullScreen:this.fullScreen.load(fullScreen),this.backgroundMask.load(data.backgroundMask),this.interactivity.load(data.interactivity),data.manualParticles&&(this.manualParticles=data.manualParticles.map((t=>{const tmp=new ManualParticle;return tmp.load(t),tmp}))),this.particles.load(data.particles),this.style=deepExtend(this.style,data.style),this._engine.loadOptions(this,data),void 0!==data.smooth&&(this.smooth=data.smooth);const interactors=this._engine.interactors.get(this._container);if(interactors)for(const interactor of interactors)interactor.loadOptions&&interactor.loadOptions(this,data);if(void 0!==data.responsive)for(const responsive of data.responsive){const optResponsive=new Responsive;optResponsive.load(responsive),this.responsive.push(optResponsive)}if(this.responsive.sort(((a,b)=>a.maxWidth-b.maxWidth)),void 0!==data.themes)for(const theme of data.themes){const existingTheme=this.themes.find((t=>t.name===theme.name));if(existingTheme)existingTheme.load(theme);else{const optTheme=new Theme;optTheme.load(theme),this.themes.push(optTheme)}}this.defaultThemes.dark=this._findDefaultTheme("dark")?.name,this.defaultThemes.light=this._findDefaultTheme("light")?.name}setResponsive(width,pxRatio,defaultOptions){this.load(defaultOptions);const responsiveOptions=this.responsive.find((t=>"screen"===t.mode&&screen?t.maxWidth>screen.availWidth:t.maxWidth*pxRatio>width));return this.load(responsiveOptions?.options),responsiveOptions?.maxWidth}setTheme(name){if(name){const chosenTheme=this.themes.find((theme=>theme.name===name));chosenTheme&&this.load(chosenTheme.options)}else{const mediaMatch=safeMatchMedia("(prefers-color-scheme: dark)"),clientDarkMode=mediaMatch&&mediaMatch.matches,defaultTheme=this._findDefaultTheme(clientDarkMode?"dark":"light");defaultTheme&&this.load(defaultTheme.options)}}}class InteractionManager{constructor(engine,container){this.container=container,this._engine=engine,this._interactors=engine.getInteractors(this.container,!0),this._externalInteractors=[],this._particleInteractors=[]}async externalInteract(delta){for(const interactor of this._externalInteractors)interactor.isEnabled()&&await interactor.interact(delta)}handleClickMode(mode){for(const interactor of this._externalInteractors)interactor.handleClickMode&&interactor.handleClickMode(mode)}init(){this._externalInteractors=[],this._particleInteractors=[];for(const interactor of this._interactors){switch(interactor.type){case"external":this._externalInteractors.push(interactor);break;case"particles":this._particleInteractors.push(interactor)}interactor.init()}}async particlesInteract(particle,delta){for(const interactor of this._externalInteractors)interactor.clear(particle,delta);for(const interactor of this._particleInteractors)interactor.isEnabled(particle)&&await interactor.interact(particle,delta)}async reset(particle){for(const interactor of this._externalInteractors)interactor.isEnabled()&&interactor.reset(particle);for(const interactor of this._particleInteractors)interactor.isEnabled(particle)&&interactor.reset(particle)}}function fixOutMode(data){if(!isInArray(data.outMode,data.checkModes))return;const diameter=2*data.radius;data.coord>data.maxCoord-diameter?data.setCb(-data.radius):data.coord<diameter&&data.setCb(data.radius)}class Particle{constructor(engine,id,container,position,overrideOptions,group){this.container=container,this._calcPosition=(container,position,zIndex,tryCount=0)=>{for(const[,plugin]of container.plugins){const pluginPos=void 0!==plugin.particlePosition?plugin.particlePosition(position,this):void 0;if(pluginPos)return Vector3d.create(pluginPos.x,pluginPos.y,zIndex)}const exactPosition=calcExactPositionOrRandomFromSize({size:container.canvas.size,position}),pos=Vector3d.create(exactPosition.x,exactPosition.y,zIndex),radius=this.getRadius(),outModes=this.options.move.outModes,fixHorizontal=outMode=>{fixOutMode({outMode,checkModes:["bounce","bounce-horizontal"],coord:pos.x,maxCoord:container.canvas.size.width,setCb:value=>pos.x+=value,radius})},fixVertical=outMode=>{fixOutMode({outMode,checkModes:["bounce","bounce-vertical"],coord:pos.y,maxCoord:container.canvas.size.height,setCb:value=>pos.y+=value,radius})};return fixHorizontal(outModes.left??outModes.default),fixHorizontal(outModes.right??outModes.default),fixVertical(outModes.top??outModes.default),fixVertical(outModes.bottom??outModes.default),this._checkOverlap(pos,tryCount)?this._calcPosition(container,void 0,zIndex,tryCount+1):pos},this._calculateVelocity=()=>{const res=function getParticleBaseVelocity(direction){const baseVelocity=Vector.origin;return baseVelocity.length=1,baseVelocity.angle=direction,baseVelocity}(this.direction).copy(),moveOptions=this.options.move;if("inside"===moveOptions.direction||"outside"===moveOptions.direction)return res;const rad=Math.PI/180*getRangeValue(moveOptions.angle.value),radOffset=Math.PI/180*getRangeValue(moveOptions.angle.offset),range={left:radOffset-.5*rad,right:radOffset+.5*rad};return moveOptions.straight||(res.angle+=randomInRange(setRangeValue(range.left,range.right))),moveOptions.random&&"number"==typeof moveOptions.speed&&(res.length*=getRandom()),res},this._checkOverlap=(pos,tryCount=0)=>{const collisionsOptions=this.options.collisions,radius=this.getRadius();if(!collisionsOptions.enable)return!1;const overlapOptions=collisionsOptions.overlap;if(overlapOptions.enable)return!1;const retries=overlapOptions.retries;if(retries>=0&&tryCount>retries)throw new Error(`${errorPrefix} particle is overlapping and can't be placed`);return!!this.container.particles.find((particle=>getDistance(pos,particle.position)<radius+particle.getRadius()))},this._getRollColor=color=>{if(!color||!this.roll||!this.backColor&&!this.roll.alter)return color;const backFactor=this.roll.horizontal&&this.roll.vertical?2:1,backSum=this.roll.horizontal?.5*Math.PI:0;return Math.floor(((this.roll.angle??0)+backSum)/(Math.PI/backFactor))%2?this.backColor?this.backColor:this.roll.alter?function alterHsl(color,type,value){return{h:color.h,s:color.s,l:color.l+("darken"===type?-1:1)*value}}(color,this.roll.alter.type,this.roll.alter.value):color:color},this._initPosition=position=>{const container=this.container,zIndexValue=getRangeValue(this.options.zIndex.value);this.position=this._calcPosition(container,position,clamp(zIndexValue,0,container.zLayers)),this.initialPosition=this.position.copy();const canvasSize=container.canvas.size;switch(this.moveCenter={...getPosition(this.options.move.center,canvasSize),radius:this.options.move.center.radius??0,mode:this.options.move.center.mode??"percent"},this.direction=function getParticleDirectionAngle(direction,position,center){if(isNumber(direction))return direction*Math.PI/180;switch(direction){case"top":return.5*-Math.PI;case"top-right":return.25*-Math.PI;case"right":return 0;case"bottom-right":return.25*Math.PI;case"bottom":return.5*Math.PI;case"bottom-left":return.75*Math.PI;case"left":return Math.PI;case"top-left":return.75*-Math.PI;case"inside":return Math.atan2(center.y-position.y,center.x-position.x);case"outside":return Math.atan2(position.y-center.y,position.x-center.x);default:return getRandom()*Math.PI*2}}(this.options.move.direction,this.position,this.moveCenter),this.options.move.direction){case"inside":this.outType="inside";break;case"outside":this.outType="outside"}this.offset=Vector.origin},this._engine=engine,this.init(id,position,overrideOptions,group)}destroy(override){if(this.unbreakable||this.destroyed)return;this.destroyed=!0,this.bubble.inRange=!1,this.slow.inRange=!1;const container=this.container,pathGenerator=this.pathGenerator,shapeDrawer=container.shapeDrawers.get(this.shape);shapeDrawer&&shapeDrawer.particleDestroy&&shapeDrawer.particleDestroy(this);for(const[,plugin]of container.plugins)plugin.particleDestroyed&&plugin.particleDestroyed(this,override);for(const updater of container.particles.updaters)updater.particleDestroyed&&updater.particleDestroyed(this,override);pathGenerator&&pathGenerator.reset(this),this._engine.dispatchEvent("particleDestroyed",{container:this.container,data:{particle:this}})}draw(delta){const container=this.container,canvas=container.canvas;for(const[,plugin]of container.plugins)canvas.drawParticlePlugin(plugin,this,delta);canvas.drawParticle(this,delta)}getFillColor(){return this._getRollColor(this.bubble.color??getHslFromAnimation(this.color))}getMass(){return this.getRadius()**2*Math.PI*.5}getPosition(){return{x:this.position.x+this.offset.x,y:this.position.y+this.offset.y,z:this.position.z}}getRadius(){return this.bubble.radius??this.size.value}getStrokeColor(){return this._getRollColor(this.bubble.color??getHslFromAnimation(this.strokeColor))}init(id,position,overrideOptions,group){const container=this.container,engine=this._engine;this.id=id,this.group=group,this.effectClose=!0,this.effectFill=!0,this.shapeClose=!0,this.shapeFill=!0,this.pathRotation=!1,this.lastPathTime=0,this.destroyed=!1,this.unbreakable=!1,this.rotation=0,this.misplaced=!1,this.retina={maxDistance:{}},this.outType="normal",this.ignoresResizeRatio=!0;const pxRatio=container.retina.pixelRatio,mainOptions=container.actualOptions,particlesOptions=loadParticlesOptions(this._engine,container,mainOptions.particles),effectType=particlesOptions.effect.type,shapeType=particlesOptions.shape.type,{reduceDuplicates}=particlesOptions;this.effect=itemFromSingleOrMultiple(effectType,this.id,reduceDuplicates),this.shape=itemFromSingleOrMultiple(shapeType,this.id,reduceDuplicates);const effectOptions=particlesOptions.effect,shapeOptions=particlesOptions.shape;if(overrideOptions){if(overrideOptions.effect&&overrideOptions.effect.type){const effect=itemFromSingleOrMultiple(overrideOptions.effect.type,this.id,reduceDuplicates);effect&&(this.effect=effect,effectOptions.load(overrideOptions.effect))}if(overrideOptions.shape&&overrideOptions.shape.type){const shape=itemFromSingleOrMultiple(overrideOptions.shape.type,this.id,reduceDuplicates);shape&&(this.shape=shape,shapeOptions.load(overrideOptions.shape))}}this.effectData=function loadEffectData(effect,effectOptions,id,reduceDuplicates){const effectData=effectOptions.options[effect];if(effectData)return deepExtend({close:effectOptions.close,fill:effectOptions.fill},itemFromSingleOrMultiple(effectData,id,reduceDuplicates))}(this.effect,effectOptions,this.id,reduceDuplicates),this.shapeData=function loadShapeData(shape,shapeOptions,id,reduceDuplicates){const shapeData=shapeOptions.options[shape];if(shapeData)return deepExtend({close:shapeOptions.close,fill:shapeOptions.fill},itemFromSingleOrMultiple(shapeData,id,reduceDuplicates))}(this.shape,shapeOptions,this.id,reduceDuplicates),particlesOptions.load(overrideOptions);const effectData=this.effectData;effectData&&particlesOptions.load(effectData.particles);const shapeData=this.shapeData;shapeData&&particlesOptions.load(shapeData.particles);const interactivity=new Interactivity(engine,container);interactivity.load(container.actualOptions.interactivity),interactivity.load(particlesOptions.interactivity),this.interactivity=interactivity,this.effectFill=effectData?.fill??particlesOptions.effect.fill,this.effectClose=effectData?.close??particlesOptions.effect.close,this.shapeFill=shapeData?.fill??particlesOptions.shape.fill,this.shapeClose=shapeData?.close??particlesOptions.shape.close,this.options=particlesOptions;const pathOptions=this.options.move.path;this.pathDelay=1e3*getRangeValue(pathOptions.delay.value),pathOptions.generator&&(this.pathGenerator=this._engine.getPathGenerator(pathOptions.generator),this.pathGenerator&&container.addPath(pathOptions.generator,this.pathGenerator)&&this.pathGenerator.init(container)),container.retina.initParticle(this),this.size=initParticleNumericAnimationValue(this.options.size,pxRatio),this.bubble={inRange:!1},this.slow={inRange:!1,factor:1},this._initPosition(position),this.initialVelocity=this._calculateVelocity(),this.velocity=this.initialVelocity.copy(),this.moveDecay=1-getRangeValue(this.options.move.decay);const particles=container.particles;particles.setLastZIndex(this.position.z),this.zIndexFactor=this.position.z/container.zLayers,this.sides=24;let effectDrawer=container.effectDrawers.get(this.effect);effectDrawer||(effectDrawer=this._engine.getEffectDrawer(this.effect),effectDrawer&&container.effectDrawers.set(this.effect,effectDrawer)),effectDrawer&&effectDrawer.loadEffect&&effectDrawer.loadEffect(this);let shapeDrawer=container.shapeDrawers.get(this.shape);shapeDrawer||(shapeDrawer=this._engine.getShapeDrawer(this.shape),shapeDrawer&&container.shapeDrawers.set(this.shape,shapeDrawer)),shapeDrawer&&shapeDrawer.loadShape&&shapeDrawer.loadShape(this);const sideCountFunc=shapeDrawer?.getSidesCount;sideCountFunc&&(this.sides=sideCountFunc(this)),this.spawning=!1,this.shadowColor=rangeColorToRgb(this.options.shadow.color);for(const updater of particles.updaters)updater.init(this);for(const mover of particles.movers)mover.init&&mover.init(this);effectDrawer&&effectDrawer.particleInit&&effectDrawer.particleInit(container,this),shapeDrawer&&shapeDrawer.particleInit&&shapeDrawer.particleInit(container,this);for(const[,plugin]of container.plugins)plugin.particleCreated&&plugin.particleCreated(this)}isInsideCanvas(){const radius=this.getRadius(),canvasSize=this.container.canvas.size,position=this.position;return position.x>=-radius&&position.y>=-radius&&position.y<=canvasSize.height+radius&&position.x<=canvasSize.width+radius}isVisible(){return!this.destroyed&&!this.spawning&&this.isInsideCanvas()}reset(){for(const updater of this.container.particles.updaters)updater.reset&&updater.reset(this)}}class Point{constructor(position,particle){this.position=position,this.particle=particle}}class Range{constructor(x,y){this.position={x,y}}}class Rectangle extends Range{constructor(x,y,width,height){super(x,y),this.size={height,width}}contains(point){const w=this.size.width,h=this.size.height,pos=this.position;return point.x>=pos.x&&point.x<=pos.x+w&&point.y>=pos.y&&point.y<=pos.y+h}intersects(range){range instanceof Circle&&range.intersects(this);const w=this.size.width,h=this.size.height,pos1=this.position,pos2=range.position,size2=range instanceof Rectangle?range.size:{width:0,height:0},w2=size2.width,h2=size2.height;return pos2.x<pos1.x+w&&pos2.x+w2>pos1.x&&pos2.y<pos1.y+h&&pos2.y+h2>pos1.y}}class Circle extends Range{constructor(x,y,radius){super(x,y),this.radius=radius}contains(point){return getDistance(point,this.position)<=this.radius}intersects(range){const pos1=this.position,pos2=range.position,distPos_x=Math.abs(pos2.x-pos1.x),distPos_y=Math.abs(pos2.y-pos1.y),r=this.radius;if(range instanceof Circle){return r+range.radius>Math.sqrt(distPos_x**2+distPos_y**2)}if(range instanceof Rectangle){const{width,height}=range.size;return Math.pow(distPos_x-width,2)+Math.pow(distPos_y-height,2)<=r**2||distPos_x<=r+width&&distPos_y<=r+height||distPos_x<=width||distPos_y<=height}return!1}}class QuadTree{constructor(rectangle,capacity){this.rectangle=rectangle,this.capacity=capacity,this._subdivide=()=>{const{x,y}=this.rectangle.position,{width,height}=this.rectangle.size,{capacity}=this;for(let i=0;i<4;i++)this._subs.push(new QuadTree(new Rectangle(x+.5*width*(i%2),y+.5*height*(Math.round(.5*i)-i%2),.5*width,.5*height),capacity));this._divided=!0},this._points=[],this._divided=!1,this._subs=[]}insert(point){return!!this.rectangle.contains(point.position)&&(this._points.length<this.capacity?(this._points.push(point),!0):(this._divided||this._subdivide(),this._subs.some((sub=>sub.insert(point)))))}query(range,check,found){const res=found||[];if(!range.intersects(this.rectangle))return[];for(const p of this._points)!range.contains(p.position)&&getDistance(range.position,p.position)>p.particle.getRadius()&&(!check||check(p.particle))||res.push(p.particle);if(this._divided)for(const sub of this._subs)sub.query(range,check,res);return res}queryCircle(position,radius,check){return this.query(new Circle(position.x,position.y,radius),check)}queryRectangle(position,size,check){return this.query(new Rectangle(position.x,position.y,size.width,size.height),check)}}const qTreeRectangle=canvasSize=>{const{height,width}=canvasSize;return new Rectangle(-.25*width,-.25*height,1.5*width,1.5*height)};class Particles{constructor(engine,container){this._addToPool=(...particles)=>{for(const particle of particles)this._pool.push(particle)},this._applyDensity=(options,manualCount,group)=>{const numberOptions=options.number;if(!options.number.density?.enable)return void(void 0===group?this._limit=numberOptions.limit.value:numberOptions.limit&&this._groupLimits.set(group,numberOptions.limit.value));const densityFactor=this._initDensityFactor(numberOptions.density),optParticlesNumber=numberOptions.value,optParticlesLimit=numberOptions.limit.value>0?numberOptions.limit.value:optParticlesNumber,particlesNumber=Math.min(optParticlesNumber,optParticlesLimit)*densityFactor+manualCount,particlesCount=Math.min(this.count,this.filter((t=>t.group===group)).length);void 0===group?this._limit=numberOptions.limit.value*densityFactor:this._groupLimits.set(group,numberOptions.limit.value*densityFactor),particlesCount<particlesNumber?this.push(Math.abs(particlesNumber-particlesCount),void 0,options,group):particlesCount>particlesNumber&&this.removeQuantity(particlesCount-particlesNumber,group)},this._initDensityFactor=densityOptions=>{const container=this._container;if(!container.canvas.element||!densityOptions.enable)return 1;const canvas=container.canvas.element,pxRatio=container.retina.pixelRatio;return canvas.width*canvas.height/(densityOptions.height*densityOptions.width*pxRatio**2)},this._pushParticle=(position,overrideOptions,group,initializer)=>{try{let particle=this._pool.pop();particle?particle.init(this._nextId,position,overrideOptions,group):particle=new Particle(this._engine,this._nextId,this._container,position,overrideOptions,group);let canAdd=!0;if(initializer&&(canAdd=initializer(particle)),!canAdd)return;return this._array.push(particle),this._zArray.push(particle),this._nextId++,this._engine.dispatchEvent("particleAdded",{container:this._container,data:{particle}}),particle}catch(e){return void getLogger().warning(`${errorPrefix} adding particle: ${e}`)}},this._removeParticle=(index,group,override)=>{const particle=this._array[index];if(!particle||particle.group!==group)return!1;const zIdx=this._zArray.indexOf(particle);return this._array.splice(index,1),this._zArray.splice(zIdx,1),particle.destroy(override),this._engine.dispatchEvent("particleRemoved",{container:this._container,data:{particle}}),this._addToPool(particle),!0},this._engine=engine,this._container=container,this._nextId=0,this._array=[],this._zArray=[],this._pool=[],this._limit=0,this._groupLimits=new Map,this._needsSort=!1,this._lastZIndex=0,this._interactionManager=new InteractionManager(engine,container);const canvasSize=container.canvas.size;this.quadTree=new QuadTree(qTreeRectangle(canvasSize),4),this.movers=this._engine.getMovers(container,!0),this.updaters=this._engine.getUpdaters(container,!0)}get count(){return this._array.length}addManualParticles(){const container=this._container,options=container.actualOptions;for(const particle of options.manualParticles)this.addParticle(particle.position?getPosition(particle.position,container.canvas.size):void 0,particle.options)}addParticle(position,overrideOptions,group,initializer){const limitOptions=this._container.actualOptions.particles.number.limit,limit=void 0===group?this._limit:this._groupLimits.get(group)??this._limit,currentCount=this.count;if(limit>0)if("delete"===limitOptions.mode){const countToRemove=currentCount+1-limit;countToRemove>0&&this.removeQuantity(countToRemove)}else if("wait"===limitOptions.mode&&currentCount>=limit)return;return this._pushParticle(position,overrideOptions,group,initializer)}clear(){this._array=[],this._zArray=[]}destroy(){this._array=[],this._zArray=[],this.movers=[],this.updaters=[]}async draw(delta){const container=this._container,canvas=container.canvas;canvas.clear(),await this.update(delta);for(const[,plugin]of container.plugins)canvas.drawPlugin(plugin,delta);for(const p of this._zArray)p.draw(delta)}filter(condition){return this._array.filter(condition)}find(condition){return this._array.find(condition)}get(index){return this._array[index]}handleClickMode(mode){this._interactionManager.handleClickMode(mode)}init(){const container=this._container,options=container.actualOptions;this._lastZIndex=0,this._needsSort=!1;let handled=!1;this.updaters=this._engine.getUpdaters(container,!0),this._interactionManager.init();for(const[,plugin]of container.plugins)if(void 0!==plugin.particlesInitialization&&(handled=plugin.particlesInitialization()),handled)break;this._interactionManager.init();for(const[,pathGenerator]of container.pathGenerators)pathGenerator.init(container);if(this.addManualParticles(),!handled){const particlesOptions=options.particles,groups=particlesOptions.groups;for(const group in groups){const groupOptions=groups[group];for(let i=this.count,j=0;j<groupOptions.number?.value&&i<particlesOptions.number.value;i++,j++)this.addParticle(void 0,groupOptions,group)}for(let i=this.count;i<particlesOptions.number.value;i++)this.addParticle()}}push(nb,mouse,overrideOptions,group){for(let i=0;i<nb;i++)this.addParticle(mouse?.position,overrideOptions,group)}async redraw(){this.clear(),this.init(),await this.draw({value:0,factor:0})}remove(particle,group,override){this.removeAt(this._array.indexOf(particle),void 0,group,override)}removeAt(index,quantity=1,group,override){if(index<0||index>this.count)return;let deleted=0;for(let i=index;deleted<quantity&&i<this.count;i++)this._removeParticle(i--,group,override)&&deleted++}removeQuantity(quantity,group){this.removeAt(0,quantity,group)}setDensity(){const options=this._container.actualOptions,groups=options.particles.groups;for(const group in groups)this._applyDensity(groups[group],0,group);this._applyDensity(options.particles,options.manualParticles.length)}setLastZIndex(zIndex){this._lastZIndex=zIndex,this._needsSort=this._needsSort||this._lastZIndex<zIndex}setResizeFactor(factor){this._resizeFactor=factor}async update(delta){const container=this._container,particlesToDelete=new Set;this.quadTree=new QuadTree(qTreeRectangle(container.canvas.size),4);for(const[,pathGenerator]of container.pathGenerators)pathGenerator.update();for(const[,plugin]of container.plugins)plugin.update&&await plugin.update(delta);const resizeFactor=this._resizeFactor;for(const particle of this._array){resizeFactor&&!particle.ignoresResizeRatio&&(particle.position.x*=resizeFactor.width,particle.position.y*=resizeFactor.height,particle.initialPosition.x*=resizeFactor.width,particle.initialPosition.y*=resizeFactor.height),particle.ignoresResizeRatio=!1,await this._interactionManager.reset(particle);for(const[,plugin]of this._container.plugins){if(particle.destroyed)break;plugin.particleUpdate&&plugin.particleUpdate(particle,delta)}for(const mover of this.movers)mover.isEnabled(particle)&&mover.move(particle,delta);particle.destroyed?particlesToDelete.add(particle):this.quadTree.insert(new Point(particle.getPosition(),particle))}if(particlesToDelete.size){const checkDelete=p=>!particlesToDelete.has(p);this._array=this.filter(checkDelete),this._zArray=this._zArray.filter(checkDelete);for(const particle of particlesToDelete)this._engine.dispatchEvent("particleRemoved",{container:this._container,data:{particle}});this._addToPool(...particlesToDelete)}await this._interactionManager.externalInteract(delta);for(const particle of this._array){for(const updater of this.updaters)updater.update(particle,delta);particle.destroyed||particle.spawning||await this._interactionManager.particlesInteract(particle,delta)}if(delete this._resizeFactor,this._needsSort){const zArray=this._zArray;zArray.sort(((a,b)=>b.position.z-a.position.z||a.id-b.id)),this._lastZIndex=zArray[zArray.length-1].position.z,this._needsSort=!1}}}class Retina{constructor(container){this.container=container,this.pixelRatio=1,this.reduceFactor=1}init(){const container=this.container,options=container.actualOptions;this.pixelRatio=!options.detectRetina||isSsr()?1:window.devicePixelRatio,this.reduceFactor=1;const ratio=this.pixelRatio,canvas=container.canvas;if(canvas.element){const element=canvas.element;canvas.size.width=element.offsetWidth*ratio,canvas.size.height=element.offsetHeight*ratio}const particles=options.particles,moveOptions=particles.move;this.maxSpeed=getRangeValue(moveOptions.gravity.maxSpeed)*ratio,this.sizeAnimationSpeed=getRangeValue(particles.size.animation.speed)*ratio}initParticle(particle){const options=particle.options,ratio=this.pixelRatio,moveOptions=options.move,moveDistance=moveOptions.distance,props=particle.retina;props.moveDrift=getRangeValue(moveOptions.drift)*ratio,props.moveSpeed=getRangeValue(moveOptions.speed)*ratio,props.sizeAnimationSpeed=getRangeValue(options.size.animation.speed)*ratio;const maxDistance=props.maxDistance;maxDistance.horizontal=void 0!==moveDistance.horizontal?moveDistance.horizontal*ratio:void 0,maxDistance.vertical=void 0!==moveDistance.vertical?moveDistance.vertical*ratio:void 0,props.maxSpeed=getRangeValue(moveOptions.gravity.maxSpeed)*ratio}}function guardCheck(container){return container&&!container.destroyed}function loadContainerOptions(engine,container,...sourceOptionsArr){const options=new Options(engine,container);return loadOptions(options,...sourceOptionsArr),options}class Container{constructor(engine,id,sourceOptions){this._intersectionManager=entries=>{if(guardCheck(this)&&this.actualOptions.pauseOnOutsideViewport)for(const entry of entries)entry.target===this.interactivity.element&&(entry.isIntersecting?this.play:this.pause)()},this._nextFrame=async timestamp=>{try{if(!this._smooth&&void 0!==this._lastFrameTime&&timestamp<this._lastFrameTime+1e3/this.fpsLimit)return void this.draw(!1);this._lastFrameTime??=timestamp;const delta=function initDelta(value,fpsLimit=60,smooth=!1){return{value,factor:smooth?60/fpsLimit:60*value/1e3}}(timestamp-this._lastFrameTime,this.fpsLimit,this._smooth);if(this.addLifeTime(delta.value),this._lastFrameTime=timestamp,delta.value>1e3)return void this.draw(!1);if(await this.particles.draw(delta),!this.alive())return void this.destroy();this.getAnimationStatus()&&this.draw(!1)}catch(e){getLogger().error(`${errorPrefix} in animation loop`,e)}},this._engine=engine,this.id=Symbol(id),this.fpsLimit=120,this._smooth=!1,this._delay=0,this._duration=0,this._lifeTime=0,this._firstStart=!0,this.started=!1,this.destroyed=!1,this._paused=!0,this._lastFrameTime=0,this.zLayers=100,this.pageHidden=!1,this._sourceOptions=sourceOptions,this._initialSourceOptions=sourceOptions,this.retina=new Retina(this),this.canvas=new Canvas(this),this.particles=new Particles(this._engine,this),this.pathGenerators=new Map,this.interactivity={mouse:{clicking:!1,inside:!1}},this.plugins=new Map,this.effectDrawers=new Map,this.shapeDrawers=new Map,this._options=loadContainerOptions(this._engine,this),this.actualOptions=loadContainerOptions(this._engine,this),this._eventListeners=new EventListeners(this),this._intersectionObserver=function safeIntersectionObserver(callback){if(!isSsr()&&"undefined"!=typeof IntersectionObserver)return new IntersectionObserver(callback)}((entries=>this._intersectionManager(entries))),this._engine.dispatchEvent("containerBuilt",{container:this})}get options(){return this._options}get sourceOptions(){return this._sourceOptions}addClickHandler(callback){if(!guardCheck(this))return;const el=this.interactivity.element;if(!el)return;const clickOrTouchHandler=(e,pos,radius)=>{if(!guardCheck(this))return;const pxRatio=this.retina.pixelRatio,posRetina={x:pos.x*pxRatio,y:pos.y*pxRatio},particles=this.particles.quadTree.queryCircle(posRetina,radius*pxRatio);callback(e,particles)};let touched=!1,touchMoved=!1;el.addEventListener("click",(e=>{if(!guardCheck(this))return;const mouseEvent=e,pos={x:mouseEvent.offsetX||mouseEvent.clientX,y:mouseEvent.offsetY||mouseEvent.clientY};clickOrTouchHandler(e,pos,1)})),el.addEventListener("touchstart",(()=>{guardCheck(this)&&(touched=!0,touchMoved=!1)})),el.addEventListener("touchmove",(()=>{guardCheck(this)&&(touchMoved=!0)})),el.addEventListener("touchend",(e=>{if(guardCheck(this)){if(touched&&!touchMoved){const touchEvent=e;let lastTouch=touchEvent.touches[touchEvent.touches.length-1];if(!lastTouch&&(lastTouch=touchEvent.changedTouches[touchEvent.changedTouches.length-1],!lastTouch))return;const element=this.canvas.element,canvasRect=element?element.getBoundingClientRect():void 0,pos={x:lastTouch.clientX-(canvasRect?canvasRect.left:0),y:lastTouch.clientY-(canvasRect?canvasRect.top:0)};clickOrTouchHandler(e,pos,Math.max(lastTouch.radiusX,lastTouch.radiusY))}touched=!1,touchMoved=!1}})),el.addEventListener("touchcancel",(()=>{guardCheck(this)&&(touched=!1,touchMoved=!1)}))}addLifeTime(value){this._lifeTime+=value}addPath(key,generator,override=!1){return!(!guardCheck(this)||!override&&this.pathGenerators.has(key))&&(this.pathGenerators.set(key,generator),!0)}alive(){return!this._duration||this._lifeTime<=this._duration}destroy(){if(!guardCheck(this))return;this.stop(),this.particles.destroy(),this.canvas.destroy();for(const[,effectDrawer]of this.effectDrawers)effectDrawer.destroy&&effectDrawer.destroy(this);for(const[,shapeDrawer]of this.shapeDrawers)shapeDrawer.destroy&&shapeDrawer.destroy(this);for(const key of this.effectDrawers.keys())this.effectDrawers.delete(key);for(const key of this.shapeDrawers.keys())this.shapeDrawers.delete(key);this._engine.clearPlugins(this),this.destroyed=!0;const mainArr=this._engine.dom(),idx=mainArr.findIndex((t=>t===this));idx>=0&&mainArr.splice(idx,1),this._engine.dispatchEvent("containerDestroyed",{container:this})}draw(force){if(!guardCheck(this))return;let refreshTime=force;this._drawAnimationFrame=requestAnimationFrame((async timestamp=>{refreshTime&&(this._lastFrameTime=void 0,refreshTime=!1),await this._nextFrame(timestamp)}))}async export(type,options={}){for(const[,plugin]of this.plugins){if(!plugin.export)continue;const res=await plugin.export(type,options);if(res.supported)return res.blob}getLogger().error(`${errorPrefix} - Export plugin with type ${type} not found`)}getAnimationStatus(){return!this._paused&&!this.pageHidden&&guardCheck(this)}handleClickMode(mode){if(guardCheck(this)){this.particles.handleClickMode(mode);for(const[,plugin]of this.plugins)plugin.handleClickMode&&plugin.handleClickMode(mode)}}async init(){if(!guardCheck(this))return;const effects=this._engine.getSupportedEffects();for(const type of effects){const drawer=this._engine.getEffectDrawer(type);drawer&&this.effectDrawers.set(type,drawer)}const shapes=this._engine.getSupportedShapes();for(const type of shapes){const drawer=this._engine.getShapeDrawer(type);drawer&&this.shapeDrawers.set(type,drawer)}this._options=loadContainerOptions(this._engine,this,this._initialSourceOptions,this.sourceOptions),this.actualOptions=loadContainerOptions(this._engine,this,this._options);const availablePlugins=this._engine.getAvailablePlugins(this);for(const[id,plugin]of availablePlugins)this.plugins.set(id,plugin);this.retina.init(),await this.canvas.init(),this.updateActualOptions(),this.canvas.initBackground(),this.canvas.resize(),this.zLayers=this.actualOptions.zLayers,this._duration=1e3*getRangeValue(this.actualOptions.duration),this._delay=1e3*getRangeValue(this.actualOptions.delay),this._lifeTime=0,this.fpsLimit=this.actualOptions.fpsLimit>0?this.actualOptions.fpsLimit:120,this._smooth=this.actualOptions.smooth;for(const[,drawer]of this.effectDrawers)drawer.init&&await drawer.init(this);for(const[,drawer]of this.shapeDrawers)drawer.init&&await drawer.init(this);for(const[,plugin]of this.plugins)plugin.init&&await plugin.init();this._engine.dispatchEvent("containerInit",{container:this}),this.particles.init(),this.particles.setDensity();for(const[,plugin]of this.plugins)plugin.particlesSetup&&plugin.particlesSetup();this._engine.dispatchEvent("particlesSetup",{container:this})}async loadTheme(name){guardCheck(this)&&(this._currentTheme=name,await this.refresh())}pause(){if(guardCheck(this)&&(void 0!==this._drawAnimationFrame&&(cancelAnimationFrame(this._drawAnimationFrame),delete this._drawAnimationFrame),!this._paused)){for(const[,plugin]of this.plugins)plugin.pause&&plugin.pause();this.pageHidden||(this._paused=!0),this._engine.dispatchEvent("containerPaused",{container:this})}}play(force){if(!guardCheck(this))return;const needsUpdate=this._paused||force;if(!this._firstStart||this.actualOptions.autoPlay){if(this._paused&&(this._paused=!1),needsUpdate)for(const[,plugin]of this.plugins)plugin.play&&plugin.play();this._engine.dispatchEvent("containerPlay",{container:this}),this.draw(needsUpdate||!1)}else this._firstStart=!1}async refresh(){if(guardCheck(this))return this.stop(),this.start()}async reset(){if(guardCheck(this))return this._initialSourceOptions=void 0,this._options=loadContainerOptions(this._engine,this),this.actualOptions=loadContainerOptions(this._engine,this,this._options),this.refresh()}async start(){guardCheck(this)&&!this.started&&(await this.init(),this.started=!0,await new Promise((resolve=>{this._delayTimeout=setTimeout((async()=>{this._eventListeners.addListeners(),this.interactivity.element instanceof HTMLElement&&this._intersectionObserver&&this._intersectionObserver.observe(this.interactivity.element);for(const[,plugin]of this.plugins)plugin.start&&await plugin.start();this._engine.dispatchEvent("containerStarted",{container:this}),this.play(),resolve()}),this._delay)})))}stop(){if(guardCheck(this)&&this.started){this._delayTimeout&&(clearTimeout(this._delayTimeout),delete this._delayTimeout),this._firstStart=!0,this.started=!1,this._eventListeners.removeListeners(),this.pause(),this.particles.clear(),this.canvas.stop(),this.interactivity.element instanceof HTMLElement&&this._intersectionObserver&&this._intersectionObserver.unobserve(this.interactivity.element);for(const[,plugin]of this.plugins)plugin.stop&&plugin.stop();for(const key of this.plugins.keys())this.plugins.delete(key);this._sourceOptions=this._options,this._engine.dispatchEvent("containerStopped",{container:this})}}updateActualOptions(){this.actualOptions.responsive=[];const newMaxWidth=this.actualOptions.setResponsive(this.canvas.size.width,this.retina.pixelRatio,this._options);return this.actualOptions.setTheme(this._currentTheme),this._responsiveMaxWidth!==newMaxWidth&&(this._responsiveMaxWidth=newMaxWidth,!0)}}class EventDispatcher{constructor(){this._listeners=new Map}addEventListener(type,listener){this.removeEventListener(type,listener);let arr=this._listeners.get(type);arr||(arr=[],this._listeners.set(type,arr)),arr.push(listener)}dispatchEvent(type,args){const listeners=this._listeners.get(type);listeners&&listeners.forEach((handler=>handler(args)))}hasEventListener(type){return!!this._listeners.get(type)}removeAllEventListeners(type){type?this._listeners.delete(type):this._listeners=new Map}removeEventListener(type,listener){const arr=this._listeners.get(type);if(!arr)return;const length=arr.length,idx=arr.indexOf(listener);idx<0||(1===length?this._listeners.delete(type):arr.splice(idx,1))}}function getItemsFromInitializer(container,map,initializers,force=!1){let res=map.get(container);return res&&!force||(res=[...initializers.values()].map((t=>t(container))),map.set(container,res)),res}class Engine{constructor(){this._configs=new Map,this._domArray=[],this._eventDispatcher=new EventDispatcher,this._initialized=!1,this.plugins=[],this._initializers={interactors:new Map,movers:new Map,updaters:new Map},this.interactors=new Map,this.movers=new Map,this.updaters=new Map,this.presets=new Map,this.effectDrawers=new Map,this.shapeDrawers=new Map,this.pathGenerators=new Map}get configs(){const res={};for(const[name,config]of this._configs)res[name]=config;return res}get version(){return"3.0.2"}addConfig(config){const name=config.name??"default";this._configs.set(name,config),this._eventDispatcher.dispatchEvent("configAdded",{data:{name,config}})}async addEffect(effect,drawer,refresh=!0){executeOnSingleOrMultiple(effect,(type=>{!this.getEffectDrawer(type)&&this.effectDrawers.set(type,drawer)})),await this.refresh(refresh)}addEventListener(type,listener){this._eventDispatcher.addEventListener(type,listener)}async addInteractor(name,interactorInitializer,refresh=!0){this._initializers.interactors.set(name,interactorInitializer),await this.refresh(refresh)}async addMover(name,moverInitializer,refresh=!0){this._initializers.movers.set(name,moverInitializer),await this.refresh(refresh)}async addParticleUpdater(name,updaterInitializer,refresh=!0){this._initializers.updaters.set(name,updaterInitializer),await this.refresh(refresh)}async addPathGenerator(name,generator,refresh=!0){!this.getPathGenerator(name)&&this.pathGenerators.set(name,generator),await this.refresh(refresh)}async addPlugin(plugin,refresh=!0){!this.getPlugin(plugin.id)&&this.plugins.push(plugin),await this.refresh(refresh)}async addPreset(preset,options,override=!1,refresh=!0){(override||!this.getPreset(preset))&&this.presets.set(preset,options),await this.refresh(refresh)}async addShape(shape,drawer,refresh=!0){executeOnSingleOrMultiple(shape,(type=>{!this.getShapeDrawer(type)&&this.shapeDrawers.set(type,drawer)})),await this.refresh(refresh)}clearPlugins(container){this.updaters.delete(container),this.movers.delete(container),this.interactors.delete(container)}dispatchEvent(type,args){this._eventDispatcher.dispatchEvent(type,args)}dom(){return this._domArray}domItem(index){const dom=this.dom(),item=dom[index];if(item&&!item.destroyed)return item;dom.splice(index,1)}getAvailablePlugins(container){const res=new Map;for(const plugin of this.plugins)plugin.needsPlugin(container.actualOptions)&&res.set(plugin.id,plugin.getPlugin(container));return res}getEffectDrawer(type){return this.effectDrawers.get(type)}getInteractors(container,force=!1){return getItemsFromInitializer(container,this.interactors,this._initializers.interactors,force)}getMovers(container,force=!1){return getItemsFromInitializer(container,this.movers,this._initializers.movers,force)}getPathGenerator(type){return this.pathGenerators.get(type)}getPlugin(plugin){return this.plugins.find((t=>t.id===plugin))}getPreset(preset){return this.presets.get(preset)}getShapeDrawer(type){return this.shapeDrawers.get(type)}getSupportedEffects(){return this.effectDrawers.keys()}getSupportedShapes(){return this.shapeDrawers.keys()}getUpdaters(container,force=!1){return getItemsFromInitializer(container,this.updaters,this._initializers.updaters,force)}init(){this._initialized||(this._initialized=!0)}async load(params){const id=params.id??`tsparticles${Math.floor(1e4*getRandom())}`,{index,url}=params,options=url?await async function getDataFromUrl(data){const url=itemFromSingleOrMultiple(data.url,data.index);if(!url)return data.fallback;const response=await fetch(url);return response.ok?response.json():(getLogger().error(`${errorPrefix} ${response.status} while retrieving config file`),data.fallback)}({fallback:params.options,url,index}):params.options;let domContainer=params.element??document.getElementById(id);domContainer||(domContainer=document.createElement("div"),domContainer.id=id,document.body.append(domContainer));const currentOptions=itemFromSingleOrMultiple(options,index),dom=this.dom(),oldIndex=dom.findIndex((v=>v.id.description===id));if(oldIndex>=0){const old=this.domItem(oldIndex);old&&!old.destroyed&&(old.destroy(),dom.splice(oldIndex,1))}let canvasEl;if("canvas"===domContainer.tagName.toLowerCase())canvasEl=domContainer,canvasEl.dataset.generated="false";else{const existingCanvases=domContainer.getElementsByTagName("canvas");existingCanvases.length?(canvasEl=existingCanvases[0],canvasEl.dataset.generated="false"):(canvasEl=document.createElement("canvas"),canvasEl.dataset.generated="true",domContainer.appendChild(canvasEl))}canvasEl.style.width||(canvasEl.style.width="100%"),canvasEl.style.height||(canvasEl.style.height="100%");const newItem=new Container(this,id,currentOptions);return oldIndex>=0?dom.splice(oldIndex,0,newItem):dom.push(newItem),newItem.canvas.loadCanvas(canvasEl),await newItem.start(),newItem}loadOptions(options,sourceOptions){for(const plugin of this.plugins)plugin.loadOptions(options,sourceOptions)}loadParticlesOptions(container,options,...sourceOptions){const updaters=this.updaters.get(container);if(updaters)for(const updater of updaters)updater.loadOptions&&updater.loadOptions(options,...sourceOptions)}async refresh(refresh=!0){refresh&&this.dom().forEach((t=>t.refresh()))}removeEventListener(type,listener){this._eventDispatcher.removeEventListener(type,listener)}setOnClickHandler(callback){const dom=this.dom();if(!dom.length)throw new Error(`${errorPrefix} can only set click handlers after calling tsParticles.load()`);for(const domItem of dom)domItem.addClickHandler(callback)}}class HslColorManager{constructor(){this.key="hsl",this.stringPrefix="hsl"}handleColor(color){const hslColor=color.value.hsl??color.value;if(void 0!==hslColor.h&&void 0!==hslColor.s&&void 0!==hslColor.l)return hslToRgb(hslColor)}handleRangeColor(color){const hslColor=color.value.hsl??color.value;if(void 0!==hslColor.h&&void 0!==hslColor.l)return hslToRgb({h:getRangeValue(hslColor.h),l:getRangeValue(hslColor.l),s:getRangeValue(hslColor.s)})}parseString(input){if(!input.startsWith("hsl"))return;const result=/hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.%]+)\s*)?\)/i.exec(input);return result?function hslaToRgba(hsla){const rgbResult=hslToRgb(hsla);return{a:hsla.a,b:rgbResult.b,g:rgbResult.g,r:rgbResult.r}}({a:result.length>4?parseAlpha(result[5]):1,h:parseInt(result[1],10),l:parseInt(result[3],10),s:parseInt(result[2],10)}):void 0}}class RgbColorManager{constructor(){this.key="rgb",this.stringPrefix="rgb"}handleColor(color){const rgbColor=color.value.rgb??color.value;if(void 0!==rgbColor.r)return rgbColor}handleRangeColor(color){const rgbColor=color.value.rgb??color.value;if(void 0!==rgbColor.r)return{r:getRangeValue(rgbColor.r),g:getRangeValue(rgbColor.g),b:getRangeValue(rgbColor.b)}}parseString(input){if(!input.startsWith(this.stringPrefix))return;const result=/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.%]+)\s*)?\)/i.exec(input);return result?{a:result.length>4?parseAlpha(result[5]):1,b:parseInt(result[3],10),g:parseInt(result[2],10),r:parseInt(result[1],10)}:void 0}}class ExternalInteractorBase{constructor(container){this.container=container,this.type="external"}}class ParticlesInteractorBase{constructor(container){this.container=container,this.type="particles"}}const tsParticles=function init(){const rgbColorManager=new RgbColorManager,hslColorManager=new HslColorManager;addColorManager(rgbColorManager),addColorManager(hslColorManager);const engine=new Engine;return engine.init(),engine}();isSsr()||(window.tsParticles=tsParticles);class AbsorberSizeLimit{constructor(){this.radius=0,this.mass=0}load(data){data&&(void 0!==data.mass&&(this.mass=data.mass),void 0!==data.radius&&(this.radius=data.radius))}}class AbsorberSize extends ValueWithRandom{constructor(){super(),this.density=5,this.value=50,this.limit=new AbsorberSizeLimit}load(data){data&&(super.load(data),void 0!==data.density&&(this.density=data.density),isNumber(data.limit)?this.limit.radius=data.limit:this.limit.load(data.limit))}}class Absorber{constructor(){this.color=new OptionsColor,this.color.value="#000000",this.draggable=!1,this.opacity=1,this.destroy=!0,this.orbits=!1,this.size=new AbsorberSize}load(data){void 0!==data&&(void 0!==data.color&&(this.color=OptionsColor.create(this.color,data.color)),void 0!==data.draggable&&(this.draggable=data.draggable),this.name=data.name,void 0!==data.opacity&&(this.opacity=data.opacity),void 0!==data.position&&(this.position={},void 0!==data.position.x&&(this.position.x=setRangeValue(data.position.x)),void 0!==data.position.y&&(this.position.y=setRangeValue(data.position.y))),void 0!==data.size&&this.size.load(data.size),void 0!==data.destroy&&(this.destroy=data.destroy),void 0!==data.orbits&&(this.orbits=data.orbits))}}class AbsorberInstance{constructor(absorbers,container,options,position){this.absorbers=absorbers,this.container=container,this._calcPosition=()=>{const exactPosition=calcPositionOrRandomFromSizeRanged({size:this.container.canvas.size,position:this.options.position});return Vector.create(exactPosition.x,exactPosition.y)},this._updateParticlePosition=(particle,v)=>{if(particle.destroyed)return;const container=this.container,canvasSize=container.canvas.size;if(particle.needsNewPosition){const newPosition=calcPositionOrRandomFromSize({size:canvasSize});particle.position.setTo(newPosition),particle.velocity.setTo(particle.initialVelocity),particle.absorberOrbit=void 0,particle.needsNewPosition=!1}if(this.options.orbits){if(void 0===particle.absorberOrbit&&(particle.absorberOrbit=Vector.create(0,0),particle.absorberOrbit.length=getDistance(particle.getPosition(),this.position),particle.absorberOrbit.angle=getRandom()*Math.PI*2),particle.absorberOrbit.length<=this.size&&!this.options.destroy){const minSize=Math.min(canvasSize.width,canvasSize.height);particle.absorberOrbit.length=minSize*(.2*getRandom()-.1+1)}void 0===particle.absorberOrbitDirection&&(particle.absorberOrbitDirection=particle.velocity.x>=0?"clockwise":"counter-clockwise");const orbitRadius=particle.absorberOrbit.length,orbitAngle=particle.absorberOrbit.angle,orbitDirection=particle.absorberOrbitDirection;particle.velocity.setTo(Vector.origin);const updateFunc={x:"clockwise"===orbitDirection?Math.cos:Math.sin,y:"clockwise"===orbitDirection?Math.sin:Math.cos};particle.position.x=this.position.x+orbitRadius*updateFunc.x(orbitAngle),particle.position.y=this.position.y+orbitRadius*updateFunc.y(orbitAngle),particle.absorberOrbit.length-=v.length,particle.absorberOrbit.angle+=(particle.retina.moveSpeed??0)*container.retina.pixelRatio/100*container.retina.reduceFactor}else{const addV=Vector.origin;addV.length=v.length,addV.angle=v.angle,particle.velocity.addTo(addV)}},this.initialPosition=position?Vector.create(position.x,position.y):void 0,options instanceof Absorber?this.options=options:(this.options=new Absorber,this.options.load(options)),this.dragging=!1,this.name=this.options.name,this.opacity=this.options.opacity,this.size=getRangeValue(this.options.size.value)*container.retina.pixelRatio,this.mass=this.size*this.options.size.density*container.retina.reduceFactor;const limit=this.options.size.limit;this.limit={radius:limit.radius*container.retina.pixelRatio*container.retina.reduceFactor,mass:limit.mass},this.color=rangeColorToRgb(this.options.color)??{b:0,g:0,r:0},this.position=this.initialPosition?.copy()??this._calcPosition()}attract(particle){const container=this.container,options=this.options;if(options.draggable){const mouse=container.interactivity.mouse;if(mouse.clicking&&mouse.downPosition){getDistance(this.position,mouse.downPosition)<=this.size&&(this.dragging=!0)}else this.dragging=!1;this.dragging&&mouse.position&&(this.position.x=mouse.position.x,this.position.y=mouse.position.y)}const pos=particle.getPosition(),{dx,dy,distance}=getDistances(this.position,pos),v=Vector.create(dx,dy);if(v.length=this.mass/Math.pow(distance,2)*container.retina.reduceFactor,distance<this.size+particle.getRadius()){const sizeFactor=.033*particle.getRadius()*container.retina.pixelRatio;this.size>particle.getRadius()&&distance<this.size-particle.getRadius()||void 0!==particle.absorberOrbit&&particle.absorberOrbit.length<0?options.destroy?particle.destroy():(particle.needsNewPosition=!0,this._updateParticlePosition(particle,v)):(options.destroy&&(particle.size.value-=sizeFactor),this._updateParticlePosition(particle,v)),(this.limit.radius<=0||this.size<this.limit.radius)&&(this.size+=sizeFactor),(this.limit.mass<=0||this.mass<this.limit.mass)&&(this.mass+=sizeFactor*this.options.size.density*container.retina.reduceFactor)}else this._updateParticlePosition(particle,v)}draw(context){context.translate(this.position.x,this.position.y),context.beginPath(),context.arc(0,0,this.size,0,2*Math.PI,!1),context.closePath(),context.fillStyle=getStyleFromRgb(this.color,this.opacity),context.fill()}resize(){const initialPosition=this.initialPosition;this.position=initialPosition&&isPointInside(initialPosition,this.container.canvas.size,Vector.origin)?initialPosition:this._calcPosition()}}class Absorbers{constructor(container){this.container=container,this.array=[],this.absorbers=[],this.interactivityAbsorbers=[],container.getAbsorber=idxOrName=>void 0===idxOrName||isNumber(idxOrName)?this.array[idxOrName||0]:this.array.find((t=>t.name===idxOrName)),container.addAbsorber=(options,position)=>this.addAbsorber(options,position)}addAbsorber(options,position){const absorber=new AbsorberInstance(this,this.container,options,position);return this.array.push(absorber),absorber}draw(context){for(const absorber of this.array)absorber.draw(context)}handleClickMode(mode){const absorberOptions=this.absorbers,modeAbsorbers=this.interactivityAbsorbers;if("absorber"===mode){const absorbersOptions=itemFromSingleOrMultiple(modeAbsorbers)??itemFromSingleOrMultiple(absorberOptions),aPosition=this.container.interactivity.mouse.clickPosition;this.addAbsorber(absorbersOptions,aPosition)}}async init(){this.absorbers=this.container.actualOptions.absorbers,this.interactivityAbsorbers=this.container.actualOptions.interactivity.modes.absorbers,executeOnSingleOrMultiple(this.absorbers,(absorber=>{this.addAbsorber(absorber)}))}particleUpdate(particle){for(const absorber of this.array)if(absorber.attract(particle),particle.destroyed)break}removeAbsorber(absorber){const index=this.array.indexOf(absorber);index>=0&&this.array.splice(index,1)}resize(){for(const absorber of this.array)absorber.resize()}stop(){this.array=[]}}class AbsorbersPlugin{constructor(){this.id="absorbers"}getPlugin(container){return new Absorbers(container)}loadOptions(options,source){(this.needsPlugin(options)||this.needsPlugin(source))&&(source?.absorbers&&(options.absorbers=executeOnSingleOrMultiple(source.absorbers,(absorber=>{const tmp=new Absorber;return tmp.load(absorber),tmp}))),options.interactivity.modes.absorbers=executeOnSingleOrMultiple(source?.interactivity?.modes?.absorbers,(absorber=>{const tmp=new Absorber;return tmp.load(absorber),tmp})))}needsPlugin(options){if(!options)return!1;const absorbers=options.absorbers;return isArray(absorbers)?!!absorbers.length:!!absorbers||!(!options.interactivity?.events?.onClick?.mode||!isInArray("absorber",options.interactivity.events.onClick.mode))}}class DestroyBounds{load(data){data&&(void 0!==data.bottom&&(this.bottom=setRangeValue(data.bottom)),void 0!==data.left&&(this.left=setRangeValue(data.left)),void 0!==data.right&&(this.right=setRangeValue(data.right)),void 0!==data.top&&(this.top=setRangeValue(data.top)))}}class SplitFactor extends ValueWithRandom{constructor(){super(),this.value=3}}class SplitRate extends ValueWithRandom{constructor(){super(),this.value={min:4,max:9}}}class Split{constructor(){this.count=1,this.factor=new SplitFactor,this.rate=new SplitRate,this.sizeOffset=!0}load(data){data&&(void 0!==data.color&&(this.color=OptionsColor.create(this.color,data.color)),void 0!==data.count&&(this.count=data.count),this.factor.load(data.factor),this.rate.load(data.rate),this.particles=executeOnSingleOrMultiple(data.particles,(particles=>deepExtend({},particles))),void 0!==data.sizeOffset&&(this.sizeOffset=data.sizeOffset),data.colorOffset&&(this.colorOffset=this.colorOffset??{},void 0!==data.colorOffset.h&&(this.colorOffset.h=data.colorOffset.h),void 0!==data.colorOffset.s&&(this.colorOffset.s=data.colorOffset.s),void 0!==data.colorOffset.l&&(this.colorOffset.l=data.colorOffset.l)))}}class Destroy{constructor(){this.bounds=new DestroyBounds,this.mode="none",this.split=new Split}load(data){data&&(data.mode&&(this.mode=data.mode),data.bounds&&this.bounds.load(data.bounds),this.split.load(data.split))}}function addSplitParticle(engine,container,parent,splitParticlesOptions){const destroyOptions=parent.options.destroy;if(!destroyOptions)return;const splitOptions=destroyOptions.split,options=loadParticlesOptions(engine,container,parent.options),factor=getRangeValue(splitOptions.factor.value),parentColor=parent.getFillColor();splitOptions.color?options.color.load(splitOptions.color):splitOptions.colorOffset&&parentColor?options.color.load({value:{hsl:{h:parentColor.h+getRangeValue(splitOptions.colorOffset.h??0),s:parentColor.s+getRangeValue(splitOptions.colorOffset.s??0),l:parentColor.l+getRangeValue(splitOptions.colorOffset.l??0)}}}):options.color.load({value:{hsl:parent.getFillColor()}}),options.move.load({center:{x:parent.position.x,y:parent.position.y,mode:"precise"}}),isNumber(options.size.value)?options.size.value/=factor:(options.size.value.min/=factor,options.size.value.max/=factor),options.load(splitParticlesOptions);const offset=splitOptions.sizeOffset?setRangeValue(-parent.size.value,parent.size.value):0,position={x:parent.position.x+randomInRange(offset),y:parent.position.y+randomInRange(offset)};return container.particles.addParticle(position,options,parent.group,(particle=>!(particle.size.value<.5)&&(particle.velocity.length=randomInRange(setRangeValue(parent.velocity.length,particle.velocity.length)),particle.splitCount=(parent.splitCount??0)+1,particle.unbreakable=!0,setTimeout((()=>{particle.unbreakable=!1}),500),!0)))}class DestroyUpdater{constructor(engine,container){this.engine=engine,this.container=container}init(particle){const container=this.container,destroyOptions=particle.options.destroy;if(!destroyOptions)return;particle.splitCount=0;const destroyBoundsOptions=destroyOptions.bounds;particle.destroyBounds||(particle.destroyBounds={});const{bottom,left,right,top}=destroyBoundsOptions,{destroyBounds}=particle,canvasSize=container.canvas.size;bottom&&(destroyBounds.bottom=getRangeValue(bottom)*canvasSize.height/100),left&&(destroyBounds.left=getRangeValue(left)*canvasSize.width/100),right&&(destroyBounds.right=getRangeValue(right)*canvasSize.width/100),top&&(destroyBounds.top=getRangeValue(top)*canvasSize.height/100)}isEnabled(particle){return!particle.destroyed}loadOptions(options,...sources){options.destroy||(options.destroy=new Destroy);for(const source of sources)options.destroy.load(source?.destroy)}particleDestroyed(particle,override){if(override)return;const destroyOptions=particle.options.destroy;destroyOptions&&"split"===destroyOptions.mode&&function split(engine,container,particle){const destroyOptions=particle.options.destroy;if(!destroyOptions)return;const splitOptions=destroyOptions.split;if(splitOptions.count>=0&&(void 0===particle.splitCount||particle.splitCount++>splitOptions.count))return;const rate=getRangeValue(splitOptions.rate.value),particlesSplitOptions=itemFromSingleOrMultiple(splitOptions.particles);for(let i=0;i<rate;i++)addSplitParticle(engine,container,particle,particlesSplitOptions)}(this.engine,this.container,particle)}update(particle){if(!this.isEnabled(particle))return;const position=particle.getPosition(),bounds=particle.destroyBounds;bounds&&(void 0!==bounds.bottom&&position.y>=bounds.bottom||void 0!==bounds.left&&position.x<=bounds.left||void 0!==bounds.right&&position.x>=bounds.right||void 0!==bounds.top&&position.y<=bounds.top)&&particle.destroy()}}class EmitterLife{constructor(){this.wait=!1}load(data){data&&(void 0!==data.count&&(this.count=data.count),void 0!==data.delay&&(this.delay=setRangeValue(data.delay)),void 0!==data.duration&&(this.duration=setRangeValue(data.duration)),void 0!==data.wait&&(this.wait=data.wait))}}class EmitterRate{constructor(){this.quantity=1,this.delay=.1}load(data){void 0!==data&&(void 0!==data.quantity&&(this.quantity=setRangeValue(data.quantity)),void 0!==data.delay&&(this.delay=setRangeValue(data.delay)))}}class EmitterShapeReplace{constructor(){this.color=!1,this.opacity=!1}load(data){data&&(void 0!==data.color&&(this.color=data.color),void 0!==data.opacity&&(this.opacity=data.opacity))}}class EmitterShape{constructor(){this.options={},this.replace=new EmitterShapeReplace,this.type="square"}load(data){data&&(void 0!==data.options&&(this.options=deepExtend({},data.options??{})),this.replace.load(data.replace),void 0!==data.type&&(this.type=data.type))}}class EmitterSize{constructor(){this.mode="percent",this.height=0,this.width=0}load(data){void 0!==data&&(void 0!==data.mode&&(this.mode=data.mode),void 0!==data.height&&(this.height=data.height),void 0!==data.width&&(this.width=data.width))}}class Emitter{constructor(){this.autoPlay=!0,this.fill=!0,this.life=new EmitterLife,this.rate=new EmitterRate,this.shape=new EmitterShape,this.startCount=0}load(data){data&&(void 0!==data.autoPlay&&(this.autoPlay=data.autoPlay),void 0!==data.size&&(this.size||(this.size=new EmitterSize),this.size.load(data.size)),void 0!==data.direction&&(this.direction=data.direction),this.domId=data.domId,void 0!==data.fill&&(this.fill=data.fill),this.life.load(data.life),this.name=data.name,this.particles=executeOnSingleOrMultiple(data.particles,(particles=>deepExtend({},particles))),this.rate.load(data.rate),this.shape.load(data.shape),void 0!==data.position&&(this.position={},void 0!==data.position.x&&(this.position.x=setRangeValue(data.position.x)),void 0!==data.position.y&&(this.position.y=setRangeValue(data.position.y))),void 0!==data.spawnColor&&(void 0===this.spawnColor&&(this.spawnColor=new AnimatableColor),this.spawnColor.load(data.spawnColor)),void 0!==data.startCount&&(this.startCount=data.startCount))}}function setParticlesOptionsColor(particlesOptions,color){particlesOptions.color?particlesOptions.color.value=color:particlesOptions.color={value:color}}class EmitterInstance{constructor(engine,emitters,container,options,position){this.emitters=emitters,this.container=container,this._destroy=()=>{this._mutationObserver?.disconnect(),this._mutationObserver=void 0,this._resizeObserver?.disconnect(),this._resizeObserver=void 0,this.emitters.removeEmitter(this),this._engine.dispatchEvent("emitterDestroyed",{container:this.container,data:{emitter:this}})},this._prepareToDie=()=>{if(this._paused)return;const duration=void 0!==this.options.life?.duration?getRangeValue(this.options.life.duration):void 0;this.container.retina.reduceFactor&&(this._lifeCount>0||this._immortal)&&void 0!==duration&&duration>0&&(this._duration=1e3*duration)},this._setColorAnimation=(animation,initValue,maxValue)=>{const container=this.container;if(!animation.enable)return initValue;const colorOffset=randomInRange(animation.offset),emitFactor=1e3*getRangeValue(this.options.rate.delay)/container.retina.reduceFactor;return(initValue+getRangeValue(animation.speed??0)*container.fpsLimit/emitFactor+3.6*colorOffset)%maxValue},this._engine=engine,this._currentDuration=0,this._currentEmitDelay=0,this._currentSpawnDelay=0,this._initialPosition=position,options instanceof Emitter?this.options=options:(this.options=new Emitter,this.options.load(options)),this._spawnDelay=1e3*getRangeValue(this.options.life.delay??0)/this.container.retina.reduceFactor,this.position=this._initialPosition??this._calcPosition(),this.name=this.options.name,this.fill=this.options.fill,this._firstSpawn=!this.options.life.wait,this._startParticlesAdded=!1;let particlesOptions=deepExtend({},this.options.particles);if(particlesOptions??={},particlesOptions.move??={},particlesOptions.move.direction??=this.options.direction,this.options.spawnColor&&(this.spawnColor=rangeColorToHsl(this.options.spawnColor)),this._paused=!this.options.autoPlay,this._particlesOptions=particlesOptions,this._size=this._calcSize(),this.size=getSize(this._size,this.container.canvas.size),this._lifeCount=this.options.life.count??-1,this._immortal=this._lifeCount<=0,this.options.domId){const element=document.getElementById(this.options.domId);element&&(this._mutationObserver=new MutationObserver((()=>{this.resize()})),this._resizeObserver=new ResizeObserver((()=>{this.resize()})),this._mutationObserver.observe(element,{attributes:!0,attributeFilter:["style","width","height"]}),this._resizeObserver.observe(element))}const shapeOptions=this.options.shape,shapeGenerator=this._engine.emitterShapeManager?.getShapeGenerator(shapeOptions.type);shapeGenerator&&(this._shape=shapeGenerator.generate(this.position,this.size,this.fill,shapeOptions.options)),this._engine.dispatchEvent("emitterCreated",{container,data:{emitter:this}}),this.play()}externalPause(){this._paused=!0,this.pause()}externalPlay(){this._paused=!1,this.play()}async init(){await(this._shape?.init())}pause(){this._paused||delete this._emitDelay}play(){if(!this._paused&&this.container.retina.reduceFactor&&(this._lifeCount>0||this._immortal||!this.options.life.count)&&(this._firstSpawn||this._currentSpawnDelay>=(this._spawnDelay??0))){if(void 0===this._emitDelay){const delay=getRangeValue(this.options.rate.delay);this._emitDelay=1e3*delay/this.container.retina.reduceFactor}(this._lifeCount>0||this._immortal)&&this._prepareToDie()}}resize(){const initialPosition=this._initialPosition;this.position=initialPosition&&isPointInside(initialPosition,this.container.canvas.size,Vector.origin)?initialPosition:this._calcPosition(),this._size=this._calcSize(),this.size=getSize(this._size,this.container.canvas.size),this._shape?.resize(this.position,this.size)}async update(delta){this._paused||(this._firstSpawn&&(this._firstSpawn=!1,this._currentSpawnDelay=this._spawnDelay??0,this._currentEmitDelay=this._emitDelay??0),this._startParticlesAdded||(this._startParticlesAdded=!0,await this._emitParticles(this.options.startCount)),void 0!==this._duration&&(this._currentDuration+=delta.value,this._currentDuration>=this._duration&&(this.pause(),void 0!==this._spawnDelay&&delete this._spawnDelay,this._immortal||this._lifeCount--,this._lifeCount>0||this._immortal?(this.position=this._calcPosition(),this._shape?.resize(this.position,this.size),this._spawnDelay=1e3*getRangeValue(this.options.life.delay??0)/this.container.retina.reduceFactor):this._destroy(),this._currentDuration-=this._duration,delete this._duration)),void 0!==this._spawnDelay&&(this._currentSpawnDelay+=delta.value,this._currentSpawnDelay>=this._spawnDelay&&(this._engine.dispatchEvent("emitterPlay",{container:this.container}),this.play(),this._currentSpawnDelay-=this._currentSpawnDelay,delete this._spawnDelay)),void 0!==this._emitDelay&&(this._currentEmitDelay+=delta.value,this._currentEmitDelay>=this._emitDelay&&(this._emit(),this._currentEmitDelay-=this._emitDelay)))}_calcPosition(){if(this.options.domId){const container=this.container,element=document.getElementById(this.options.domId);if(element){const elRect=element.getBoundingClientRect();return{x:(elRect.x+elRect.width/2)*container.retina.pixelRatio,y:(elRect.y+elRect.height/2)*container.retina.pixelRatio}}}return calcPositionOrRandomFromSizeRanged({size:this.container.canvas.size,position:this.options.position})}_calcSize(){const container=this.container;if(this.options.domId){const element=document.getElementById(this.options.domId);if(element){const elRect=element.getBoundingClientRect();return{width:elRect.width*container.retina.pixelRatio,height:elRect.height*container.retina.pixelRatio,mode:"precise"}}}return this.options.size??(()=>{const size=new EmitterSize;return size.load({height:0,mode:"percent",width:0}),size})()}async _emit(){if(this._paused)return;const quantity=getRangeValue(this.options.rate.quantity);await this._emitParticles(quantity)}async _emitParticles(quantity){const singleParticlesOptions=itemFromSingleOrMultiple(this._particlesOptions);for(let i=0;i<quantity;i++){const particlesOptions=deepExtend({},singleParticlesOptions);if(this.spawnColor){const hslAnimation=this.options.spawnColor?.animation;hslAnimation&&(this.spawnColor.h=this._setColorAnimation(hslAnimation.h,this.spawnColor.h,360),this.spawnColor.s=this._setColorAnimation(hslAnimation.s,this.spawnColor.s,100),this.spawnColor.l=this._setColorAnimation(hslAnimation.l,this.spawnColor.l,100)),setParticlesOptionsColor(particlesOptions,this.spawnColor)}const shapeOptions=this.options.shape;let position=this.position;if(this._shape){const shapePosData=await this._shape.randomPosition();if(shapePosData){position=shapePosData.position;const replaceData=shapeOptions.replace;replaceData.color&&shapePosData.color&&setParticlesOptionsColor(particlesOptions,shapePosData.color),replaceData.opacity&&(particlesOptions.opacity?particlesOptions.opacity.value=shapePosData.opacity:particlesOptions.opacity={value:shapePosData.opacity})}else position=null}position&&this.container.particles.addParticle(position,particlesOptions)}}}class Emitters{constructor(engine,container){this.container=container,this._engine=engine,this.array=[],this.emitters=[],this.interactivityEmitters={random:{count:1,enable:!1},value:[]},container.getEmitter=idxOrName=>void 0===idxOrName||isNumber(idxOrName)?this.array[idxOrName||0]:this.array.find((t=>t.name===idxOrName)),container.addEmitter=async(options,position)=>this.addEmitter(options,position),container.removeEmitter=idxOrName=>{const emitter=container.getEmitter(idxOrName);emitter&&this.removeEmitter(emitter)},container.playEmitter=idxOrName=>{const emitter=container.getEmitter(idxOrName);emitter&&emitter.externalPlay()},container.pauseEmitter=idxOrName=>{const emitter=container.getEmitter(idxOrName);emitter&&emitter.externalPause()}}async addEmitter(options,position){const emitterOptions=new Emitter;emitterOptions.load(options);const emitter=new EmitterInstance(this._engine,this,this.container,emitterOptions,position);return await emitter.init(),this.array.push(emitter),emitter}handleClickMode(mode){const emitterOptions=this.emitters,modeEmitters=this.interactivityEmitters;if("emitter"!==mode)return;let emittersModeOptions;if(modeEmitters&&isArray(modeEmitters.value))if(modeEmitters.value.length>0&&modeEmitters.random.enable){emittersModeOptions=[];const usedIndexes=[];for(let i=0;i<modeEmitters.random.count;i++){const idx=arrayRandomIndex(modeEmitters.value);usedIndexes.includes(idx)&&usedIndexes.length<modeEmitters.value.length?i--:(usedIndexes.push(idx),emittersModeOptions.push(itemFromArray(modeEmitters.value,idx)))}}else emittersModeOptions=modeEmitters.value;else emittersModeOptions=modeEmitters?.value;const emittersOptions=emittersModeOptions??emitterOptions,ePosition=this.container.interactivity.mouse.clickPosition;executeOnSingleOrMultiple(emittersOptions,(emitter=>{this.addEmitter(emitter,ePosition)}))}async init(){if(this.emitters=this.container.actualOptions.emitters,this.interactivityEmitters=this.container.actualOptions.interactivity.modes.emitters,this.emitters)if(isArray(this.emitters))for(const emitterOptions of this.emitters)await this.addEmitter(emitterOptions);else await this.addEmitter(this.emitters)}pause(){for(const emitter of this.array)emitter.pause()}play(){for(const emitter of this.array)emitter.play()}removeEmitter(emitter){const index=this.array.indexOf(emitter);index>=0&&this.array.splice(index,1)}resize(){for(const emitter of this.array)emitter.resize()}stop(){this.array=[]}async update(delta){for(const emitter of this.array)await emitter.update(delta)}}const shapeGeneratorss=new Map;class ShapeManager{constructor(engine){this._engine=engine}addShapeGenerator(name,generator){this.getShapeGenerator(name)||shapeGeneratorss.set(name,generator)}getShapeGenerator(name){return shapeGeneratorss.get(name)}getSupportedShapeGenerators(){return shapeGeneratorss.keys()}}class EmitterShapeBase{constructor(position,size,fill,options){this.position=position,this.size=size,this.fill=fill,this.options=options}resize(position,size){this.position=position,this.size=size}}class EmittersPlugin{constructor(engine){this._engine=engine,this.id="emitters"}getPlugin(container){return new Emitters(this._engine,container)}loadOptions(options,source){if(!this.needsPlugin(options)&&!this.needsPlugin(source))return;source?.emitters&&(options.emitters=executeOnSingleOrMultiple(source.emitters,(emitter=>{const tmp=new Emitter;return tmp.load(emitter),tmp})));const interactivityEmitters=source?.interactivity?.modes?.emitters;if(interactivityEmitters)if(isArray(interactivityEmitters))options.interactivity.modes.emitters={random:{count:1,enable:!0},value:interactivityEmitters.map((s=>{const tmp=new Emitter;return tmp.load(s),tmp}))};else{const emitterMode=interactivityEmitters;if(void 0!==emitterMode.value)if(isArray(emitterMode.value))options.interactivity.modes.emitters={random:{count:emitterMode.random.count??1,enable:emitterMode.random.enable??!1},value:emitterMode.value.map((s=>{const tmp=new Emitter;return tmp.load(s),tmp}))};else{const tmp=new Emitter;tmp.load(emitterMode.value),options.interactivity.modes.emitters={random:{count:emitterMode.random.count??1,enable:emitterMode.random.enable??!1},value:tmp}}else{(options.interactivity.modes.emitters={random:{count:1,enable:!1},value:new Emitter}).value.load(interactivityEmitters)}}}needsPlugin(options){if(!options)return!1;const emitters=options.emitters;return isArray(emitters)&&!!emitters.length||void 0!==emitters||!!options.interactivity?.events?.onClick?.mode&&isInArray("emitter",options.interactivity.events.onClick.mode)}}class EmittersCircleShape extends EmitterShapeBase{constructor(position,size,fill,options){super(position,size,fill,options)}async init(){}async randomPosition(){const size=this.size,fill=this.fill,position=this.position,[a,b]=[size.width/2,size.height/2],randomTheta=((x,y)=>{const u=getRandom()/4,theta=Math.atan(y/x*Math.tan(2*Math.PI*u)),v=getRandom();return v<.25?theta:v<.5?Math.PI-theta:v<.75?Math.PI+theta:-theta})(a,b),maxRadius=(theta=randomTheta,(x=a)*(y=b)/Math.sqrt((y*Math.cos(theta))**2+(x*Math.sin(theta))**2)),randomRadius=fill?maxRadius*Math.sqrt(getRandom()):maxRadius;var x,y,theta;return{position:{x:position.x+randomRadius*Math.cos(randomTheta),y:position.y+randomRadius*Math.sin(randomTheta)}}}}class EmittersCircleShapeGenerator{generate(position,size,fill,options){return new EmittersCircleShape(position,size,fill,options)}}function randomSquareCoordinate(position,offset){return position+offset*(getRandom()-.5)}class EmittersSquareShape extends EmitterShapeBase{constructor(position,size,fill,options){super(position,size,fill,options)}async init(){}async randomPosition(){const fill=this.fill,position=this.position,size=this.size;if(fill)return{position:{x:randomSquareCoordinate(position.x,size.width),y:randomSquareCoordinate(position.y,size.height)}};{const halfW=size.width/2,halfH=size.height/2,side=Math.floor(4*getRandom()),v=2*(getRandom()-.5);switch(side){case 0:return{position:{x:position.x+v*halfW,y:position.y-halfH}};case 1:return{position:{x:position.x-halfW,y:position.y+v*halfH}};case 2:return{position:{x:position.x+v*halfW,y:position.y+halfH}};default:return{position:{x:position.x+halfW,y:position.y+v*halfH}}}}}}class EmittersSquareShapeGenerator{generate(position,size,fill,options){return new EmittersSquareShape(position,size,fill,options)}}class Trail{constructor(){this.delay=1,this.pauseOnStop=!1,this.quantity=1}load(data){data&&(void 0!==data.delay&&(this.delay=data.delay),void 0!==data.quantity&&(this.quantity=data.quantity),void 0!==data.particles&&(this.particles=deepExtend({},data.particles)),void 0!==data.pauseOnStop&&(this.pauseOnStop=data.pauseOnStop))}}class TrailMaker extends ExternalInteractorBase{constructor(container){super(container),this._delay=0}clear(){}init(){}async interact(delta){const container=this.container,{interactivity}=container;if(!container.retina.reduceFactor)return;const trailOptions=container.actualOptions.interactivity.modes.trail;if(!trailOptions)return;const optDelay=1e3*trailOptions.delay/this.container.retina.reduceFactor;if(this._delay<optDelay&&(this._delay+=delta.value),this._delay<optDelay)return;const canEmit=!(trailOptions.pauseOnStop&&(interactivity.mouse.position===this._lastPosition||interactivity.mouse.position?.x===this._lastPosition?.x&&interactivity.mouse.position?.y===this._lastPosition?.y)),mousePos=container.interactivity.mouse.position;mousePos?this._lastPosition={...mousePos}:delete this._lastPosition,canEmit&&container.particles.push(trailOptions.quantity,container.interactivity.mouse,trailOptions.particles),this._delay-=optDelay}isEnabled(particle){const container=this.container,options=container.actualOptions,mouse=container.interactivity.mouse,events=(particle?.interactivity??options.interactivity).events;return mouse.clicking&&mouse.inside&&!!mouse.position&&isInArray("trail",events.onClick.mode)||mouse.inside&&!!mouse.position&&isInArray("trail",events.onHover.mode)}loadModeOptions(options,...sources){options.trail||(options.trail=new Trail);for(const source of sources)options.trail.load(source?.trail)}reset(){}}class RollLight{constructor(){this.enable=!1,this.value=0}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.value&&(this.value=setRangeValue(data.value)))}}class Roll{constructor(){this.darken=new RollLight,this.enable=!1,this.enlighten=new RollLight,this.mode="vertical",this.speed=25}load(data){data&&(void 0!==data.backColor&&(this.backColor=OptionsColor.create(this.backColor,data.backColor)),this.darken.load(data.darken),void 0!==data.enable&&(this.enable=data.enable),this.enlighten.load(data.enlighten),void 0!==data.mode&&(this.mode=data.mode),void 0!==data.speed&&(this.speed=setRangeValue(data.speed)))}}class RollUpdater{getTransformValues(particle){const roll=particle.roll?.enable&&particle.roll,rollHorizontal=roll&&roll.horizontal,rollVertical=roll&&roll.vertical;return{a:rollHorizontal?Math.cos(roll.angle):void 0,d:rollVertical?Math.sin(roll.angle):void 0}}init(particle){!function initParticle(particle){const rollOpt=particle.options.roll;if(rollOpt?.enable)if(particle.roll={enable:rollOpt.enable,horizontal:"horizontal"===rollOpt.mode||"both"===rollOpt.mode,vertical:"vertical"===rollOpt.mode||"both"===rollOpt.mode,angle:getRandom()*Math.PI*2,speed:getRangeValue(rollOpt.speed)/360},rollOpt.backColor)particle.backColor=rangeColorToHsl(rollOpt.backColor);else if(rollOpt.darken.enable&&rollOpt.enlighten.enable){const alterType=getRandom()>=.5?"darken":"enlighten";particle.roll.alter={type:alterType,value:getRangeValue("darken"===alterType?rollOpt.darken.value:rollOpt.enlighten.value)}}else rollOpt.darken.enable?particle.roll.alter={type:"darken",value:getRangeValue(rollOpt.darken.value)}:rollOpt.enlighten.enable&&(particle.roll.alter={type:"enlighten",value:getRangeValue(rollOpt.enlighten.value)});else particle.roll={enable:!1,horizontal:!1,vertical:!1,angle:0,speed:0}}(particle)}isEnabled(particle){const roll=particle.options.roll;return!particle.destroyed&&!particle.spawning&&!!roll?.enable}loadOptions(options,...sources){options.roll||(options.roll=new Roll);for(const source of sources)options.roll.load(source?.roll)}update(particle,delta){this.isEnabled(particle)&&function updateRoll(particle,delta){const roll=particle.options.roll,data=particle.roll;if(!data||!roll?.enable)return;const speed=data.speed*delta.factor,max=2*Math.PI;data.angle+=speed,data.angle>max&&(data.angle-=max)}(particle,delta)}}function move(particle,moveOptions,moveSpeed,maxSpeed,moveDrift,delta){!function applyPath(particle,delta){const particlesOptions=particle.options,pathOptions=particlesOptions.move.path;if(!pathOptions.enable)return;if(particle.lastPathTime<=particle.pathDelay)return void(particle.lastPathTime+=delta.value);const path=particle.pathGenerator?.generate(particle,delta);path&&particle.velocity.addTo(path);pathOptions.clamp&&(particle.velocity.x=clamp(particle.velocity.x,-1,1),particle.velocity.y=clamp(particle.velocity.y,-1,1));particle.lastPathTime-=particle.pathDelay}(particle,delta);const gravityOptions=particle.gravity,gravityFactor=gravityOptions?.enable&&gravityOptions.inverse?-1:1;moveDrift&&moveSpeed&&(particle.velocity.x+=moveDrift*delta.factor/(60*moveSpeed)),gravityOptions?.enable&&moveSpeed&&(particle.velocity.y+=gravityFactor*(gravityOptions.acceleration*delta.factor)/(60*moveSpeed));const decay=particle.moveDecay;particle.velocity.multTo(decay);const velocity=particle.velocity.mult(moveSpeed);gravityOptions?.enable&&maxSpeed>0&&(!gravityOptions.inverse&&velocity.y>=0&&velocity.y>=maxSpeed||gravityOptions.inverse&&velocity.y<=0&&velocity.y<=-maxSpeed)&&(velocity.y=gravityFactor*maxSpeed,moveSpeed&&(particle.velocity.y=velocity.y/moveSpeed));const zIndexOptions=particle.options.zIndex,zVelocityFactor=(1-particle.zIndexFactor)**zIndexOptions.velocityRate;velocity.multTo(zVelocityFactor);const{position}=particle;position.addTo(velocity),moveOptions.vibrate&&(position.x+=Math.sin(position.x*Math.cos(position.y)),position.y+=Math.cos(position.y*Math.sin(position.x)))}class BaseMover{constructor(){this._initSpin=particle=>{const container=particle.container,spinOptions=particle.options.move.spin;if(!spinOptions.enable)return;const spinPos=spinOptions.position??{x:50,y:50},spinCenter={x:.01*spinPos.x*container.canvas.size.width,y:.01*spinPos.y*container.canvas.size.height},distance=getDistance(particle.getPosition(),spinCenter),spinAcceleration=getRangeValue(spinOptions.acceleration);particle.retina.spinAcceleration=spinAcceleration*container.retina.pixelRatio,particle.spin={center:spinCenter,direction:particle.velocity.x>=0?"clockwise":"counter-clockwise",angle:particle.velocity.angle,radius:distance,acceleration:particle.retina.spinAcceleration}}}init(particle){const gravityOptions=particle.options.move.gravity;particle.gravity={enable:gravityOptions.enable,acceleration:getRangeValue(gravityOptions.acceleration),inverse:gravityOptions.inverse},this._initSpin(particle)}isEnabled(particle){return!particle.destroyed&&particle.options.move.enable}move(particle,delta){const particleOptions=particle.options,moveOptions=particleOptions.move;if(!moveOptions.enable)return;const container=particle.container,pxRatio=container.retina.pixelRatio,slowFactor=function getProximitySpeedFactor(particle){return particle.slow.inRange?particle.slow.factor:1}(particle),baseSpeed=(particle.retina.moveSpeed??=getRangeValue(moveOptions.speed)*pxRatio)*container.retina.reduceFactor,moveDrift=particle.retina.moveDrift??=getRangeValue(particle.options.move.drift)*pxRatio,maxSize=getRangeMax(particleOptions.size.value)*pxRatio,moveSpeed=baseSpeed*(moveOptions.size?particle.getRadius()/maxSize:1)*slowFactor*(delta.factor||1)/2,maxSpeed=particle.retina.maxSpeed??container.retina.maxSpeed;moveOptions.spin.enable?function spin(particle,moveSpeed){const container=particle.container;if(!particle.spin)return;const updateFunc={x:"clockwise"===particle.spin.direction?Math.cos:Math.sin,y:"clockwise"===particle.spin.direction?Math.sin:Math.cos};particle.position.x=particle.spin.center.x+particle.spin.radius*updateFunc.x(particle.spin.angle),particle.position.y=particle.spin.center.y+particle.spin.radius*updateFunc.y(particle.spin.angle),particle.spin.radius+=particle.spin.acceleration;const maxCanvasSize=Math.max(container.canvas.size.width,container.canvas.size.height),halfMaxSize=.5*maxCanvasSize;particle.spin.radius>halfMaxSize?(particle.spin.radius=halfMaxSize,particle.spin.acceleration*=-1):particle.spin.radius<0&&(particle.spin.radius=0,particle.spin.acceleration*=-1),particle.spin.angle+=.01*moveSpeed*(1-particle.spin.radius/maxCanvasSize)}(particle,moveSpeed):move(particle,moveOptions,moveSpeed,maxSpeed,moveDrift,delta),function applyDistance(particle){const initialPosition=particle.initialPosition,{dx,dy}=getDistances(initialPosition,particle.position),dxFixed=Math.abs(dx),dyFixed=Math.abs(dy),{maxDistance}=particle.retina,hDistance=maxDistance.horizontal,vDistance=maxDistance.vertical;if(hDistance||vDistance)if((hDistance&&dxFixed>=hDistance||vDistance&&dyFixed>=vDistance)&&!particle.misplaced)particle.misplaced=!!hDistance&&dxFixed>hDistance||!!vDistance&&dyFixed>vDistance,hDistance&&(particle.velocity.x=.5*particle.velocity.y-particle.velocity.x),vDistance&&(particle.velocity.y=.5*particle.velocity.x-particle.velocity.y);else if((!hDistance||dxFixed<hDistance)&&(!vDistance||dyFixed<vDistance)&&particle.misplaced)particle.misplaced=!1;else if(particle.misplaced){const pos=particle.position,vel=particle.velocity;hDistance&&(pos.x<initialPosition.x&&vel.x<0||pos.x>initialPosition.x&&vel.x>0)&&(vel.x*=-getRandom()),vDistance&&(pos.y<initialPosition.y&&vel.y<0||pos.y>initialPosition.y&&vel.y>0)&&(vel.y*=-getRandom())}}(particle)}}class CircleDrawer{draw(data){const{context,particle,radius}=data;particle.circleRange||(particle.circleRange={min:0,max:2*Math.PI});const circleRange=particle.circleRange;context.arc(0,0,radius,circleRange.min,circleRange.max,!1)}getSidesCount(){return 12}particleInit(container,particle){const shapeData=particle.shapeData,angle=shapeData?.angle??{max:360,min:0};particle.circleRange=isObject(angle)?{min:angle.min*Math.PI/180,max:angle.max*Math.PI/180}:{min:0,max:angle*Math.PI/180}}}function updateColorValue(delta,colorValue,valueAnimation,max,decrease){if(!colorValue||!valueAnimation.enable||(colorValue.maxLoops??0)>0&&(colorValue.loops??0)>(colorValue.maxLoops??0))return;if(colorValue.time||(colorValue.time=0),(colorValue.delayTime??0)>0&&colorValue.time<(colorValue.delayTime??0)&&(colorValue.time+=delta.value),(colorValue.delayTime??0)>0&&colorValue.time<(colorValue.delayTime??0))return;const offset=randomInRange(valueAnimation.offset),velocity=(colorValue.velocity??0)*delta.factor+3.6*offset,decay=colorValue.decay??1;decrease&&"increasing"!==colorValue.status?(colorValue.value-=velocity,colorValue.value<0&&(colorValue.loops||(colorValue.loops=0),colorValue.loops++,colorValue.status="increasing",colorValue.value+=colorValue.value)):(colorValue.value+=velocity,colorValue.value>max&&(colorValue.loops||(colorValue.loops=0),colorValue.loops++,decrease&&(colorValue.status="decreasing",colorValue.value-=colorValue.value%max))),colorValue.velocity&&1!==decay&&(colorValue.velocity*=decay),colorValue.value>max&&(colorValue.value%=max)}class ColorUpdater{constructor(container){this.container=container}init(particle){const hslColor=rangeColorToHsl(particle.options.color,particle.id,particle.options.reduceDuplicates);hslColor&&(particle.color=getHslAnimationFromHsl(hslColor,particle.options.color.animation,this.container.retina.reduceFactor))}isEnabled(particle){const{h:hAnimation,s:sAnimation,l:lAnimation}=particle.options.color.animation,{color}=particle;return!particle.destroyed&&!particle.spawning&&(void 0!==color?.h.value&&hAnimation.enable||void 0!==color?.s.value&&sAnimation.enable||void 0!==color?.l.value&&lAnimation.enable)}update(particle,delta){!function updateColor(particle,delta){const{h:hAnimation,s:sAnimation,l:lAnimation}=particle.options.color.animation,{color}=particle;if(!color)return;const{h,s,l}=color;h&&updateColorValue(delta,h,hAnimation,360,!1),s&&updateColorValue(delta,s,sAnimation,100,!0),l&&updateColorValue(delta,l,lAnimation,100,!0)}(particle,delta)}}class OpacityUpdater{constructor(container){this.container=container}init(particle){const opacityOptions=particle.options.opacity;particle.opacity=initParticleNumericAnimationValue(opacityOptions,1);const opacityAnimation=opacityOptions.animation;opacityAnimation.enable&&(particle.opacity.velocity=getRangeValue(opacityAnimation.speed)/100*this.container.retina.reduceFactor,opacityAnimation.sync||(particle.opacity.velocity*=getRandom()))}isEnabled(particle){return!particle.destroyed&&!particle.spawning&&!!particle.opacity&&particle.opacity.enable&&((particle.opacity.maxLoops??0)<=0||(particle.opacity.maxLoops??0)>0&&(particle.opacity.loops??0)<(particle.opacity.maxLoops??0))}reset(particle){particle.opacity&&(particle.opacity.time=0,particle.opacity.loops=0)}update(particle,delta){this.isEnabled(particle)&&function updateOpacity(particle,delta){const data=particle.opacity;if(particle.destroyed||!data?.enable||(data.maxLoops??0)>0&&(data.loops??0)>(data.maxLoops??0))return;const minValue=data.min,maxValue=data.max,decay=data.decay??1;if(data.time||(data.time=0),(data.delayTime??0)>0&&data.time<(data.delayTime??0)&&(data.time+=delta.value),!((data.delayTime??0)>0&&data.time<(data.delayTime??0))){switch(data.status){case"increasing":data.value>=maxValue?(data.status="decreasing",data.loops||(data.loops=0),data.loops++):data.value+=(data.velocity??0)*delta.factor;break;case"decreasing":data.value<=minValue?(data.status="increasing",data.loops||(data.loops=0),data.loops++):data.value-=(data.velocity??0)*delta.factor}data.velocity&&1!==data.decay&&(data.velocity*=decay),function checkDestroy(particle,value,minValue,maxValue){switch(particle.options.opacity.animation.destroy){case"max":value>=maxValue&&particle.destroy();break;case"min":value<=minValue&&particle.destroy()}}(particle,data.value,minValue,maxValue),particle.destroyed||(data.value=clamp(data.value,minValue,maxValue))}}(particle,delta)}}class BounceOutMode{constructor(container){this.container=container,this.modes=["bounce","bounce-vertical","bounce-horizontal","bounceVertical","bounceHorizontal","split"]}update(particle,direction,delta,outMode){if(!this.modes.includes(outMode))return;const container=this.container;let handled=!1;for(const[,plugin]of container.plugins)if(void 0!==plugin.particleBounce&&(handled=plugin.particleBounce(particle,delta,direction)),handled)break;if(handled)return;const pos=particle.getPosition(),offset=particle.offset,size=particle.getRadius(),bounds=calculateBounds(pos,size),canvasSize=container.canvas.size;!function bounceHorizontal(data){if("bounce"!==data.outMode&&"bounce-horizontal"!==data.outMode&&"bounceHorizontal"!==data.outMode&&"split"!==data.outMode||"left"!==data.direction&&"right"!==data.direction)return;data.bounds.right<0&&"left"===data.direction?data.particle.position.x=data.size+data.offset.x:data.bounds.left>data.canvasSize.width&&"right"===data.direction&&(data.particle.position.x=data.canvasSize.width-data.size-data.offset.x);const velocity=data.particle.velocity.x;let bounced=!1;if("right"===data.direction&&data.bounds.right>=data.canvasSize.width&&velocity>0||"left"===data.direction&&data.bounds.left<=0&&velocity<0){const newVelocity=getRangeValue(data.particle.options.bounce.horizontal.value);data.particle.velocity.x*=-newVelocity,bounced=!0}if(!bounced)return;const minPos=data.offset.x+data.size;data.bounds.right>=data.canvasSize.width&&"right"===data.direction?data.particle.position.x=data.canvasSize.width-minPos:data.bounds.left<=0&&"left"===data.direction&&(data.particle.position.x=minPos),"split"===data.outMode&&data.particle.destroy()}({particle,outMode,direction,bounds,canvasSize,offset,size}),function bounceVertical(data){if("bounce"!==data.outMode&&"bounce-vertical"!==data.outMode&&"bounceVertical"!==data.outMode&&"split"!==data.outMode||"bottom"!==data.direction&&"top"!==data.direction)return;data.bounds.bottom<0&&"top"===data.direction?data.particle.position.y=data.size+data.offset.y:data.bounds.top>data.canvasSize.height&&"bottom"===data.direction&&(data.particle.position.y=data.canvasSize.height-data.size-data.offset.y);const velocity=data.particle.velocity.y;let bounced=!1;if("bottom"===data.direction&&data.bounds.bottom>=data.canvasSize.height&&velocity>0||"top"===data.direction&&data.bounds.top<=0&&velocity<0){const newVelocity=getRangeValue(data.particle.options.bounce.vertical.value);data.particle.velocity.y*=-newVelocity,bounced=!0}if(!bounced)return;const minPos=data.offset.y+data.size;data.bounds.bottom>=data.canvasSize.height&&"bottom"===data.direction?data.particle.position.y=data.canvasSize.height-minPos:data.bounds.top<=0&&"top"===data.direction&&(data.particle.position.y=minPos),"split"===data.outMode&&data.particle.destroy()}({particle,outMode,direction,bounds,canvasSize,offset,size})}}class DestroyOutMode{constructor(container){this.container=container,this.modes=["destroy"]}update(particle,direction,_delta,outMode){if(!this.modes.includes(outMode))return;const container=this.container;switch(particle.outType){case"normal":case"outside":if(isPointInside(particle.position,container.canvas.size,Vector.origin,particle.getRadius(),direction))return;break;case"inside":{const{dx,dy}=getDistances(particle.position,particle.moveCenter),{x:vx,y:vy}=particle.velocity;if(vx<0&&dx>particle.moveCenter.radius||vy<0&&dy>particle.moveCenter.radius||vx>=0&&dx<-particle.moveCenter.radius||vy>=0&&dy<-particle.moveCenter.radius)return;break}}container.particles.remove(particle,void 0,!0)}}class NoneOutMode{constructor(container){this.container=container,this.modes=["none"]}update(particle,direction,delta,outMode){if(!this.modes.includes(outMode))return;if(particle.options.move.distance.horizontal&&("left"===direction||"right"===direction)||particle.options.move.distance.vertical&&("top"===direction||"bottom"===direction))return;const gravityOptions=particle.options.move.gravity,container=this.container,canvasSize=container.canvas.size,pRadius=particle.getRadius();if(gravityOptions.enable){const position=particle.position;(!gravityOptions.inverse&&position.y>canvasSize.height+pRadius&&"bottom"===direction||gravityOptions.inverse&&position.y<-pRadius&&"top"===direction)&&container.particles.remove(particle)}else{if(particle.velocity.y>0&&particle.position.y<=canvasSize.height+pRadius||particle.velocity.y<0&&particle.position.y>=-pRadius||particle.velocity.x>0&&particle.position.x<=canvasSize.width+pRadius||particle.velocity.x<0&&particle.position.x>=-pRadius)return;isPointInside(particle.position,container.canvas.size,Vector.origin,pRadius,direction)||container.particles.remove(particle)}}}class OutOutMode{constructor(container){this.container=container,this.modes=["out"]}update(particle,direction,delta,outMode){if(!this.modes.includes(outMode))return;const container=this.container;switch(particle.outType){case"inside":{const{x:vx,y:vy}=particle.velocity,circVec=Vector.origin;circVec.length=particle.moveCenter.radius,circVec.angle=particle.velocity.angle+Math.PI,circVec.addTo(Vector.create(particle.moveCenter));const{dx,dy}=getDistances(particle.position,circVec);if(vx<=0&&dx>=0||vy<=0&&dy>=0||vx>=0&&dx<=0||vy>=0&&dy<=0)return;particle.position.x=Math.floor(randomInRange({min:0,max:container.canvas.size.width})),particle.position.y=Math.floor(randomInRange({min:0,max:container.canvas.size.height}));const{dx:newDx,dy:newDy}=getDistances(particle.position,particle.moveCenter);particle.direction=Math.atan2(-newDy,-newDx),particle.velocity.angle=particle.direction;break}default:if(isPointInside(particle.position,container.canvas.size,Vector.origin,particle.getRadius(),direction))return;switch(particle.outType){case"outside":{particle.position.x=Math.floor(randomInRange({min:-particle.moveCenter.radius,max:particle.moveCenter.radius}))+particle.moveCenter.x,particle.position.y=Math.floor(randomInRange({min:-particle.moveCenter.radius,max:particle.moveCenter.radius}))+particle.moveCenter.y;const{dx,dy}=getDistances(particle.position,particle.moveCenter);particle.moveCenter.radius&&(particle.direction=Math.atan2(dy,dx),particle.velocity.angle=particle.direction);break}case"normal":{const warp=particle.options.move.warp,canvasSize=container.canvas.size,newPos={bottom:canvasSize.height+particle.getRadius()+particle.offset.y,left:-particle.getRadius()-particle.offset.x,right:canvasSize.width+particle.getRadius()+particle.offset.x,top:-particle.getRadius()-particle.offset.y},sizeValue=particle.getRadius(),nextBounds=calculateBounds(particle.position,sizeValue);"right"===direction&&nextBounds.left>canvasSize.width+particle.offset.x?(particle.position.x=newPos.left,particle.initialPosition.x=particle.position.x,warp||(particle.position.y=getRandom()*canvasSize.height,particle.initialPosition.y=particle.position.y)):"left"===direction&&nextBounds.right<-particle.offset.x&&(particle.position.x=newPos.right,particle.initialPosition.x=particle.position.x,warp||(particle.position.y=getRandom()*canvasSize.height,particle.initialPosition.y=particle.position.y)),"bottom"===direction&&nextBounds.top>canvasSize.height+particle.offset.y?(warp||(particle.position.x=getRandom()*canvasSize.width,particle.initialPosition.x=particle.position.x),particle.position.y=newPos.top,particle.initialPosition.y=particle.position.y):"top"===direction&&nextBounds.bottom<-particle.offset.y&&(warp||(particle.position.x=getRandom()*canvasSize.width,particle.initialPosition.x=particle.position.x),particle.position.y=newPos.bottom,particle.initialPosition.y=particle.position.y);break}}}}}class OutOfCanvasUpdater{constructor(container){this.container=container,this._updateOutMode=(particle,delta,outMode,direction)=>{for(const updater of this.updaters)updater.update(particle,direction,delta,outMode)},this.updaters=[new BounceOutMode(container),new DestroyOutMode(container),new OutOutMode(container),new NoneOutMode(container)]}init(){}isEnabled(particle){return!particle.destroyed&&!particle.spawning}update(particle,delta){const outModes=particle.options.move.outModes;this._updateOutMode(particle,delta,outModes.bottom??outModes.default,"bottom"),this._updateOutMode(particle,delta,outModes.left??outModes.default,"left"),this._updateOutMode(particle,delta,outModes.right??outModes.default,"right"),this._updateOutMode(particle,delta,outModes.top??outModes.default,"top")}}class SizeUpdater{init(particle){const container=particle.container,sizeAnimation=particle.options.size.animation;sizeAnimation.enable&&(particle.size.velocity=(particle.retina.sizeAnimationSpeed??container.retina.sizeAnimationSpeed)/100*container.retina.reduceFactor,sizeAnimation.sync||(particle.size.velocity*=getRandom()))}isEnabled(particle){return!particle.destroyed&&!particle.spawning&&particle.size.enable&&((particle.size.maxLoops??0)<=0||(particle.size.maxLoops??0)>0&&(particle.size.loops??0)<(particle.size.maxLoops??0))}reset(particle){particle.size.loops=0}update(particle,delta){this.isEnabled(particle)&&function updateSize(particle,delta){const data=particle.size;if(particle.destroyed||!data||!data.enable||(data.maxLoops??0)>0&&(data.loops??0)>(data.maxLoops??0))return;const sizeVelocity=(data.velocity??0)*delta.factor,minValue=data.min,maxValue=data.max,decay=data.decay??1;if(data.time||(data.time=0),(data.delayTime??0)>0&&data.time<(data.delayTime??0)&&(data.time+=delta.value),!((data.delayTime??0)>0&&data.time<(data.delayTime??0))){switch(data.status){case"increasing":data.value>=maxValue?(data.status="decreasing",data.loops||(data.loops=0),data.loops++):data.value+=sizeVelocity;break;case"decreasing":data.value<=minValue?(data.status="increasing",data.loops||(data.loops=0),data.loops++):data.value-=sizeVelocity}data.velocity&&1!==decay&&(data.velocity*=decay),function Utils_checkDestroy(particle,value,minValue,maxValue){switch(particle.options.size.animation.destroy){case"max":value>=maxValue&&particle.destroy();break;case"min":value<=minValue&&particle.destroy()}}(particle,data.value,minValue,maxValue),particle.destroyed||(data.value=clamp(data.value,minValue,maxValue))}}(particle,delta)}}async function loadBasic(engine,refresh=!0){await async function loadBaseMover(engine,refresh=!0){await engine.addMover("base",(()=>new BaseMover),refresh)}(engine,!1),await async function loadCircleShape(engine,refresh=!0){await engine.addShape("circle",new CircleDrawer,refresh)}(engine,!1),await async function loadColorUpdater(engine,refresh=!0){await engine.addParticleUpdater("color",(container=>new ColorUpdater(container)),refresh)}(engine,!1),await async function loadOpacityUpdater(engine,refresh=!0){await engine.addParticleUpdater("opacity",(container=>new OpacityUpdater(container)),refresh)}(engine,!1),await async function loadOutModesUpdater(engine,refresh=!0){await engine.addParticleUpdater("outModes",(container=>new OutOfCanvasUpdater(container)),refresh)}(engine,!1),await async function loadSizeUpdater(engine,refresh=!0){await engine.addParticleUpdater("size",(()=>new SizeUpdater),refresh)}(engine,!1),await engine.refresh(refresh)}const validTypes=["emoji"],defaultFont='"Twemoji Mozilla", Apple Color Emoji, "Segoe UI Emoji", "Noto Color Emoji", "EmojiOne Color"';class EmojiDrawer{constructor(){this._emojiShapeDict=new Map}destroy(){for(const[,emojiData]of this._emojiShapeDict)emojiData instanceof ImageBitmap&&emojiData?.close()}draw(data){const{context,particle,radius,opacity}=data,emojiData=particle.emojiData;emojiData&&(context.globalAlpha=opacity,context.drawImage(emojiData,-radius,-radius,2*radius,2*radius),context.globalAlpha=1)}async init(container){const options=container.actualOptions;if(validTypes.find((t=>isInArray(t,options.particles.shape.type)))){const promises=[loadFont(defaultFont)],shapeOptions=validTypes.map((t=>options.particles.shape.options[t])).find((t=>!!t));shapeOptions&&executeOnSingleOrMultiple(shapeOptions,(shape=>{shape.font&&promises.push(loadFont(shape.font))})),await Promise.all(promises)}}particleDestroy(particle){delete particle.emojiData}particleInit(container,particle){if(!particle.emojiData){const shapeData=particle.shapeData;if(!shapeData?.value)return;const emoji=itemFromSingleOrMultiple(shapeData.value,particle.randomIndexData),font=shapeData.font??defaultFont;if(!emoji)return;const key=`${emoji}_${font}`,existingData=this._emojiShapeDict.get(key);if(existingData)return void(particle.emojiData=existingData);const canvasSize=2*getRangeMax(particle.size.value);let emojiData;if("undefined"!=typeof OffscreenCanvas){const canvas=new OffscreenCanvas(canvasSize,canvasSize),context=canvas.getContext("2d");if(!context)return;context.font=`400 ${2*getRangeMax(particle.size.value)}px ${font}`,context.textBaseline="middle",context.textAlign="center",context.fillText(emoji,getRangeMax(particle.size.value),getRangeMax(particle.size.value)),emojiData=canvas.transferToImageBitmap()}else{const canvas=document.createElement("canvas");canvas.width=canvasSize,canvas.height=canvasSize;const context=canvas.getContext("2d");if(!context)return;context.font=`400 ${2*getRangeMax(particle.size.value)}px ${font}`,context.textBaseline="middle",context.textAlign="center",context.fillText(emoji,getRangeMax(particle.size.value),getRangeMax(particle.size.value)),emojiData=canvas}this._emojiShapeDict.set(key,emojiData),particle.emojiData=emojiData}}}class Attract{constructor(){this.distance=200,this.duration=.4,this.easing="ease-out-quad",this.factor=1,this.maxSpeed=50,this.speed=1}load(data){data&&(void 0!==data.distance&&(this.distance=data.distance),void 0!==data.duration&&(this.duration=data.duration),void 0!==data.easing&&(this.easing=data.easing),void 0!==data.factor&&(this.factor=data.factor),void 0!==data.maxSpeed&&(this.maxSpeed=data.maxSpeed),void 0!==data.speed&&(this.speed=data.speed))}}class Attractor extends ExternalInteractorBase{constructor(engine,container){super(container),this._clickAttract=()=>{const container=this.container;container.attract||(container.attract={particles:[]});const{attract}=container;if(attract.finish||(attract.count||(attract.count=0),attract.count++,attract.count===container.particles.count&&(attract.finish=!0)),attract.clicking){const mousePos=container.interactivity.mouse.clickPosition,attractRadius=container.retina.attractModeDistance;if(!attractRadius||attractRadius<0||!mousePos)return;this._processAttract(mousePos,attractRadius,new Circle(mousePos.x,mousePos.y,attractRadius))}else!1===attract.clicking&&(attract.particles=[])},this._hoverAttract=()=>{const container=this.container,mousePos=container.interactivity.mouse.position,attractRadius=container.retina.attractModeDistance;!attractRadius||attractRadius<0||!mousePos||this._processAttract(mousePos,attractRadius,new Circle(mousePos.x,mousePos.y,attractRadius))},this._processAttract=(position,attractRadius,area)=>{const container=this.container,attractOptions=container.actualOptions.interactivity.modes.attract;if(!attractOptions)return;const query=container.particles.quadTree.query(area,(p=>this.isEnabled(p)));for(const particle of query){const{dx,dy,distance}=getDistances(particle.position,position),velocity=attractOptions.speed*attractOptions.factor,attractFactor=clamp(getEasing(attractOptions.easing)(1-distance/attractRadius)*velocity,0,attractOptions.maxSpeed),normVec=Vector.create(0===distance?velocity:dx/distance*attractFactor,0===distance?velocity:dy/distance*attractFactor);particle.position.subFrom(normVec)}},this._engine=engine,container.attract||(container.attract={particles:[]}),this.handleClickMode=mode=>{const attract=this.container.actualOptions.interactivity.modes.attract;if(attract&&"attract"===mode){container.attract||(container.attract={particles:[]}),container.attract.clicking=!0,container.attract.count=0;for(const particle of container.attract.particles)this.isEnabled(particle)&&particle.velocity.setTo(particle.initialVelocity);container.attract.particles=[],container.attract.finish=!1,setTimeout((()=>{container.destroyed||(container.attract||(container.attract={particles:[]}),container.attract.clicking=!1)}),1e3*attract.duration)}}}clear(){}init(){const container=this.container,attract=container.actualOptions.interactivity.modes.attract;attract&&(container.retina.attractModeDistance=attract.distance*container.retina.pixelRatio)}async interact(){const container=this.container,options=container.actualOptions,mouseMoveStatus="pointermove"===container.interactivity.status,events=options.interactivity.events,hoverEnabled=events.onHover.enable,hoverMode=events.onHover.mode,clickEnabled=events.onClick.enable,clickMode=events.onClick.mode;mouseMoveStatus&&hoverEnabled&&isInArray("attract",hoverMode)?this._hoverAttract():clickEnabled&&isInArray("attract",clickMode)&&this._clickAttract()}isEnabled(particle){const container=this.container,options=container.actualOptions,mouse=container.interactivity.mouse,events=(particle?.interactivity??options.interactivity).events;if(!(mouse.position&&events.onHover.enable||mouse.clickPosition&&events.onClick.enable))return!1;const hoverMode=events.onHover.mode,clickMode=events.onClick.mode;return isInArray("attract",hoverMode)||isInArray("attract",clickMode)}loadModeOptions(options,...sources){options.attract||(options.attract=new Attract);for(const source of sources)options.attract.load(source?.attract)}reset(){}}class Bounce{constructor(){this.distance=200}load(data){data&&void 0!==data.distance&&(this.distance=data.distance)}}class Bouncer extends ExternalInteractorBase{constructor(container){super(container),this._processBounce=(position,radius,area)=>{const query=this.container.particles.quadTree.query(area,(p=>this.isEnabled(p)));for(const particle of query)area instanceof Circle?circleBounce(circleBounceDataFromParticle(particle),{position,radius,mass:radius**2*Math.PI/2,velocity:Vector.origin,factor:Vector.origin}):area instanceof Rectangle&&rectBounce(particle,calculateBounds(position,radius))},this._processMouseBounce=()=>{const container=this.container,tolerance=10*container.retina.pixelRatio,mousePos=container.interactivity.mouse.position,radius=container.retina.bounceModeDistance;!radius||radius<0||!mousePos||this._processBounce(mousePos,radius,new Circle(mousePos.x,mousePos.y,radius+tolerance))},this._singleSelectorBounce=(selector,div)=>{const container=this.container,query=document.querySelectorAll(selector);query.length&&query.forEach((item=>{const elem=item,pxRatio=container.retina.pixelRatio,pos={x:(elem.offsetLeft+elem.offsetWidth/2)*pxRatio,y:(elem.offsetTop+elem.offsetHeight/2)*pxRatio},radius=elem.offsetWidth/2*pxRatio,tolerance=10*pxRatio,area="circle"===div.type?new Circle(pos.x,pos.y,radius+tolerance):new Rectangle(elem.offsetLeft*pxRatio-tolerance,elem.offsetTop*pxRatio-tolerance,elem.offsetWidth*pxRatio+2*tolerance,elem.offsetHeight*pxRatio+2*tolerance);this._processBounce(pos,radius,area)}))}}clear(){}init(){const container=this.container,bounce=container.actualOptions.interactivity.modes.bounce;bounce&&(container.retina.bounceModeDistance=bounce.distance*container.retina.pixelRatio)}async interact(){const container=this.container,events=container.actualOptions.interactivity.events,mouseMoveStatus="pointermove"===container.interactivity.status,hoverEnabled=events.onHover.enable,hoverMode=events.onHover.mode,divs=events.onDiv;mouseMoveStatus&&hoverEnabled&&isInArray("bounce",hoverMode)?this._processMouseBounce():divModeExecute("bounce",divs,((selector,div)=>this._singleSelectorBounce(selector,div)))}isEnabled(particle){const container=this.container,options=container.actualOptions,mouse=container.interactivity.mouse,events=(particle?.interactivity??options.interactivity).events,divs=events.onDiv;return mouse.position&&events.onHover.enable&&isInArray("bounce",events.onHover.mode)||isDivModeEnabled("bounce",divs)}loadModeOptions(options,...sources){options.bounce||(options.bounce=new Bounce);for(const source of sources)options.bounce.load(source?.bounce)}reset(){}}class BubbleBase{constructor(){this.distance=200,this.duration=.4,this.mix=!1}load(data){if(data){if(void 0!==data.distance&&(this.distance=data.distance),void 0!==data.duration&&(this.duration=data.duration),void 0!==data.mix&&(this.mix=data.mix),void 0!==data.opacity&&(this.opacity=data.opacity),void 0!==data.color){const sourceColor=isArray(this.color)?void 0:this.color;this.color=executeOnSingleOrMultiple(data.color,(color=>OptionsColor.create(sourceColor,color)))}void 0!==data.size&&(this.size=data.size)}}}class BubbleDiv extends BubbleBase{constructor(){super(),this.selectors=[]}load(data){super.load(data),data&&void 0!==data.selectors&&(this.selectors=data.selectors)}}class Bubble extends BubbleBase{load(data){super.load(data),data&&(this.divs=executeOnSingleOrMultiple(data.divs,(div=>{const tmp=new BubbleDiv;return tmp.load(div),tmp})))}}function calculateBubbleValue(particleValue,modeValue,optionsValue,ratio){if(modeValue>=optionsValue){return clamp(particleValue+(modeValue-optionsValue)*ratio,particleValue,modeValue)}if(modeValue<optionsValue){return clamp(particleValue-(optionsValue-modeValue)*ratio,modeValue,particleValue)}}class Bubbler extends ExternalInteractorBase{constructor(container){super(container),this._clickBubble=()=>{const container=this.container,options=container.actualOptions,mouseClickPos=container.interactivity.mouse.clickPosition,bubbleOptions=options.interactivity.modes.bubble;if(!bubbleOptions||!mouseClickPos)return;container.bubble||(container.bubble={});const distance=container.retina.bubbleModeDistance;if(!distance||distance<0)return;const query=container.particles.quadTree.queryCircle(mouseClickPos,distance,(p=>this.isEnabled(p))),{bubble}=container;for(const particle of query){if(!bubble.clicking)continue;particle.bubble.inRange=!bubble.durationEnd;const distMouse=getDistance(particle.getPosition(),mouseClickPos),timeSpent=((new Date).getTime()-(container.interactivity.mouse.clickTime||0))/1e3;timeSpent>bubbleOptions.duration&&(bubble.durationEnd=!0),timeSpent>2*bubbleOptions.duration&&(bubble.clicking=!1,bubble.durationEnd=!1);const sizeData={bubbleObj:{optValue:container.retina.bubbleModeSize,value:particle.bubble.radius},particlesObj:{optValue:getRangeMax(particle.options.size.value)*container.retina.pixelRatio,value:particle.size.value},type:"size"};this._process(particle,distMouse,timeSpent,sizeData);const opacityData={bubbleObj:{optValue:bubbleOptions.opacity,value:particle.bubble.opacity},particlesObj:{optValue:getRangeMax(particle.options.opacity.value),value:particle.opacity?.value??1},type:"opacity"};this._process(particle,distMouse,timeSpent,opacityData),!bubble.durationEnd&&distMouse<=distance?this._hoverBubbleColor(particle,distMouse):delete particle.bubble.color}},this._hoverBubble=()=>{const container=this.container,mousePos=container.interactivity.mouse.position,distance=container.retina.bubbleModeDistance;if(!distance||distance<0||void 0===mousePos)return;const query=container.particles.quadTree.queryCircle(mousePos,distance,(p=>this.isEnabled(p)));for(const particle of query){particle.bubble.inRange=!0;const pointDistance=getDistance(particle.getPosition(),mousePos),ratio=1-pointDistance/distance;pointDistance<=distance?ratio>=0&&"pointermove"===container.interactivity.status&&(this._hoverBubbleSize(particle,ratio),this._hoverBubbleOpacity(particle,ratio),this._hoverBubbleColor(particle,ratio)):this.reset(particle),"pointerleave"===container.interactivity.status&&this.reset(particle)}},this._hoverBubbleColor=(particle,ratio,divBubble)=>{const options=this.container.actualOptions,bubbleOptions=divBubble??options.interactivity.modes.bubble;if(bubbleOptions){if(!particle.bubble.finalColor){const modeColor=bubbleOptions.color;if(!modeColor)return;const bubbleColor=itemFromSingleOrMultiple(modeColor);particle.bubble.finalColor=rangeColorToHsl(bubbleColor)}if(particle.bubble.finalColor)if(bubbleOptions.mix){particle.bubble.color=void 0;const pColor=particle.getFillColor();particle.bubble.color=pColor?rgbToHsl(colorMix(pColor,particle.bubble.finalColor,1-ratio,ratio)):particle.bubble.finalColor}else particle.bubble.color=particle.bubble.finalColor}},this._hoverBubbleOpacity=(particle,ratio,divBubble)=>{const options=this.container.actualOptions,modeOpacity=divBubble?.opacity??options.interactivity.modes.bubble?.opacity;if(!modeOpacity)return;const optOpacity=particle.options.opacity.value,opacity=calculateBubbleValue(particle.opacity?.value??1,modeOpacity,getRangeMax(optOpacity),ratio);void 0!==opacity&&(particle.bubble.opacity=opacity)},this._hoverBubbleSize=(particle,ratio,divBubble)=>{const container=this.container,modeSize=divBubble?.size?divBubble.size*container.retina.pixelRatio:container.retina.bubbleModeSize;if(void 0===modeSize)return;const optSize=getRangeMax(particle.options.size.value)*container.retina.pixelRatio,size=calculateBubbleValue(particle.size.value,modeSize,optSize,ratio);void 0!==size&&(particle.bubble.radius=size)},this._process=(particle,distMouse,timeSpent,data)=>{const container=this.container,bubbleParam=data.bubbleObj.optValue,bubbleOptions=container.actualOptions.interactivity.modes.bubble;if(!bubbleOptions||void 0===bubbleParam)return;const bubbleDuration=bubbleOptions.duration,bubbleDistance=container.retina.bubbleModeDistance,particlesParam=data.particlesObj.optValue,pObjBubble=data.bubbleObj.value,pObj=data.particlesObj.value||0,type=data.type;if(bubbleDistance&&!(bubbleDistance<0)&&bubbleParam!==particlesParam)if(container.bubble||(container.bubble={}),container.bubble.durationEnd)pObjBubble&&("size"===type&&delete particle.bubble.radius,"opacity"===type&&delete particle.bubble.opacity);else if(distMouse<=bubbleDistance){if((pObjBubble??pObj)!==bubbleParam){const value=pObj-timeSpent*(pObj-bubbleParam)/bubbleDuration;"size"===type&&(particle.bubble.radius=value),"opacity"===type&&(particle.bubble.opacity=value)}}else"size"===type&&delete particle.bubble.radius,"opacity"===type&&delete particle.bubble.opacity},this._singleSelectorHover=(delta,selector,div)=>{const container=this.container,selectors=document.querySelectorAll(selector),bubble=container.actualOptions.interactivity.modes.bubble;bubble&&selectors.length&&selectors.forEach((item=>{const elem=item,pxRatio=container.retina.pixelRatio,pos={x:(elem.offsetLeft+elem.offsetWidth/2)*pxRatio,y:(elem.offsetTop+elem.offsetHeight/2)*pxRatio},repulseRadius=elem.offsetWidth/2*pxRatio,area="circle"===div.type?new Circle(pos.x,pos.y,repulseRadius):new Rectangle(elem.offsetLeft*pxRatio,elem.offsetTop*pxRatio,elem.offsetWidth*pxRatio,elem.offsetHeight*pxRatio),query=container.particles.quadTree.query(area,(p=>this.isEnabled(p)));for(const particle of query){if(!area.contains(particle.getPosition()))continue;particle.bubble.inRange=!0;const divBubble=divMode(bubble.divs,elem);particle.bubble.div&&particle.bubble.div===elem||(this.clear(particle,delta,!0),particle.bubble.div=elem),this._hoverBubbleSize(particle,1,divBubble),this._hoverBubbleOpacity(particle,1,divBubble),this._hoverBubbleColor(particle,1,divBubble)}}))},container.bubble||(container.bubble={}),this.handleClickMode=mode=>{"bubble"===mode&&(container.bubble||(container.bubble={}),container.bubble.clicking=!0)}}clear(particle,delta,force){particle.bubble.inRange&&!force||(delete particle.bubble.div,delete particle.bubble.opacity,delete particle.bubble.radius,delete particle.bubble.color)}init(){const container=this.container,bubble=container.actualOptions.interactivity.modes.bubble;bubble&&(container.retina.bubbleModeDistance=bubble.distance*container.retina.pixelRatio,void 0!==bubble.size&&(container.retina.bubbleModeSize=bubble.size*container.retina.pixelRatio))}async interact(delta){const events=this.container.actualOptions.interactivity.events,onHover=events.onHover,onClick=events.onClick,hoverEnabled=onHover.enable,hoverMode=onHover.mode,clickEnabled=onClick.enable,clickMode=onClick.mode,divs=events.onDiv;hoverEnabled&&isInArray("bubble",hoverMode)?this._hoverBubble():clickEnabled&&isInArray("bubble",clickMode)?this._clickBubble():divModeExecute("bubble",divs,((selector,div)=>this._singleSelectorHover(delta,selector,div)))}isEnabled(particle){const container=this.container,options=container.actualOptions,mouse=container.interactivity.mouse,events=(particle?.interactivity??options.interactivity).events,{onClick,onDiv,onHover}=events,divBubble=isDivModeEnabled("bubble",onDiv);return!!(divBubble||onHover.enable&&mouse.position||onClick.enable&&mouse.clickPosition)&&(isInArray("bubble",onHover.mode)||isInArray("bubble",onClick.mode)||divBubble)}loadModeOptions(options,...sources){options.bubble||(options.bubble=new Bubble);for(const source of sources)options.bubble.load(source?.bubble)}reset(particle){particle.bubble.inRange=!1}}class ConnectLinks{constructor(){this.opacity=.5}load(data){data&&void 0!==data.opacity&&(this.opacity=data.opacity)}}class Connect{constructor(){this.distance=80,this.links=new ConnectLinks,this.radius=60}load(data){data&&(void 0!==data.distance&&(this.distance=data.distance),this.links.load(data.links),void 0!==data.radius&&(this.radius=data.radius))}}function lineStyle(container,ctx,p1,p2){const connectOptions=container.actualOptions.interactivity.modes.connect;if(connectOptions)return function gradient(context,p1,p2,opacity){const gradStop=Math.floor(p2.getRadius()/p1.getRadius()),color1=p1.getFillColor(),color2=p2.getFillColor();if(!color1||!color2)return;const sourcePos=p1.getPosition(),destPos=p2.getPosition(),midRgb=colorMix(color1,color2,p1.getRadius(),p2.getRadius()),grad=context.createLinearGradient(sourcePos.x,sourcePos.y,destPos.x,destPos.y);return grad.addColorStop(0,getStyleFromHsl(color1,opacity)),grad.addColorStop(gradStop>1?1:gradStop,getStyleFromRgb(midRgb,opacity)),grad.addColorStop(1,getStyleFromHsl(color2,opacity)),grad}(ctx,p1,p2,connectOptions.links.opacity)}function drawConnection(container,p1,p2){container.canvas.draw((ctx=>{const ls=lineStyle(container,ctx,p1,p2);if(!ls)return;const pos1=p1.getPosition(),pos2=p2.getPosition();!function drawConnectLine(context,width,lineStyle,begin,end){drawLine(context,begin,end),context.lineWidth=width,context.strokeStyle=lineStyle,context.stroke()}(ctx,p1.retina.linksWidth??0,ls,pos1,pos2)}))}class Connector extends ExternalInteractorBase{constructor(container){super(container)}clear(){}init(){const container=this.container,connect=container.actualOptions.interactivity.modes.connect;connect&&(container.retina.connectModeDistance=connect.distance*container.retina.pixelRatio,container.retina.connectModeRadius=connect.radius*container.retina.pixelRatio)}async interact(){const container=this.container;if(container.actualOptions.interactivity.events.onHover.enable&&"pointermove"===container.interactivity.status){const mousePos=container.interactivity.mouse.position;if(!container.retina.connectModeDistance||container.retina.connectModeDistance<0||!container.retina.connectModeRadius||container.retina.connectModeRadius<0||!mousePos)return;const distance=Math.abs(container.retina.connectModeRadius),query=container.particles.quadTree.queryCircle(mousePos,distance,(p=>this.isEnabled(p)));let i=0;for(const p1 of query){const pos1=p1.getPosition();for(const p2 of query.slice(i+1)){const pos2=p2.getPosition(),distMax=Math.abs(container.retina.connectModeDistance),xDiff=Math.abs(pos1.x-pos2.x),yDiff=Math.abs(pos1.y-pos2.y);xDiff<distMax&&yDiff<distMax&&drawConnection(container,p1,p2)}++i}}}isEnabled(particle){const container=this.container,mouse=container.interactivity.mouse,events=(particle?.interactivity??container.actualOptions.interactivity).events;return!(!events.onHover.enable||!mouse.position)&&isInArray("connect",events.onHover.mode)}loadModeOptions(options,...sources){options.connect||(options.connect=new Connect);for(const source of sources)options.connect.load(source?.connect)}reset(){}}class GrabLinks{constructor(){this.blink=!1,this.consent=!1,this.opacity=1}load(data){data&&(void 0!==data.blink&&(this.blink=data.blink),void 0!==data.color&&(this.color=OptionsColor.create(this.color,data.color)),void 0!==data.consent&&(this.consent=data.consent),void 0!==data.opacity&&(this.opacity=data.opacity))}}class Grab{constructor(){this.distance=100,this.links=new GrabLinks}load(data){data&&(void 0!==data.distance&&(this.distance=data.distance),this.links.load(data.links))}}function drawGrab(container,particle,lineColor,opacity,mousePos){container.canvas.draw((ctx=>{const beginPos=particle.getPosition();!function drawGrabLine(context,width,begin,end,colorLine,opacity){drawLine(context,begin,end),context.strokeStyle=getStyleFromRgb(colorLine,opacity),context.lineWidth=width,context.stroke()}(ctx,particle.retina.linksWidth??0,beginPos,mousePos,lineColor,opacity)}))}class Grabber extends ExternalInteractorBase{constructor(container){super(container)}clear(){}init(){const container=this.container,grab=container.actualOptions.interactivity.modes.grab;grab&&(container.retina.grabModeDistance=grab.distance*container.retina.pixelRatio)}async interact(){const container=this.container,interactivity=container.actualOptions.interactivity;if(!interactivity.modes.grab||!interactivity.events.onHover.enable||"pointermove"!==container.interactivity.status)return;const mousePos=container.interactivity.mouse.position;if(!mousePos)return;const distance=container.retina.grabModeDistance;if(!distance||distance<0)return;const query=container.particles.quadTree.queryCircle(mousePos,distance,(p=>this.isEnabled(p)));for(const particle of query){const pointDistance=getDistance(particle.getPosition(),mousePos);if(pointDistance>distance)continue;const grabLineOptions=interactivity.modes.grab.links,lineOpacity=grabLineOptions.opacity,opacityLine=lineOpacity-pointDistance*lineOpacity/distance;if(opacityLine<=0)continue;const optColor=grabLineOptions.color??particle.options.links?.color;if(!container.particles.grabLineColor&&optColor){const linksOptions=interactivity.modes.grab.links;container.particles.grabLineColor=getLinkRandomColor(optColor,linksOptions.blink,linksOptions.consent)}const colorLine=getLinkColor(particle,void 0,container.particles.grabLineColor);colorLine&&drawGrab(container,particle,colorLine,opacityLine,mousePos)}}isEnabled(particle){const container=this.container,mouse=container.interactivity.mouse,events=(particle?.interactivity??container.actualOptions.interactivity).events;return events.onHover.enable&&!!mouse.position&&isInArray("grab",events.onHover.mode)}loadModeOptions(options,...sources){options.grab||(options.grab=new Grab);for(const source of sources)options.grab.load(source?.grab)}reset(){}}class Pauser extends ExternalInteractorBase{constructor(container){super(container),this.handleClickMode=mode=>{if("pause"!==mode)return;const container=this.container;container.getAnimationStatus()?container.pause():container.play()}}clear(){}init(){}async interact(){}isEnabled(){return!0}reset(){}}class Push{constructor(){this.default=!0,this.groups=[],this.quantity=4}load(data){if(!data)return;void 0!==data.default&&(this.default=data.default),void 0!==data.groups&&(this.groups=data.groups.map((t=>t))),this.groups.length||(this.default=!0);const quantity=data.quantity;void 0!==quantity&&(this.quantity=setRangeValue(quantity))}}class Pusher extends ExternalInteractorBase{constructor(container){super(container),this.handleClickMode=mode=>{if("push"!==mode)return;const container=this.container,pushOptions=container.actualOptions.interactivity.modes.push;if(!pushOptions)return;const quantity=getRangeValue(pushOptions.quantity);if(quantity<=0)return;const group=itemFromArray([void 0,...pushOptions.groups]),groupOptions=void 0!==group?container.actualOptions.particles.groups[group]:void 0;container.particles.push(quantity,container.interactivity.mouse,groupOptions,group)}}clear(){}init(){}async interact(){}isEnabled(){return!0}loadModeOptions(options,...sources){options.push||(options.push=new Push);for(const source of sources)options.push.load(source?.push)}reset(){}}class Remove{constructor(){this.quantity=2}load(data){if(!data)return;const quantity=data.quantity;void 0!==quantity&&(this.quantity=setRangeValue(quantity))}}class Remover extends ExternalInteractorBase{constructor(container){super(container),this.handleClickMode=mode=>{const container=this.container,options=container.actualOptions;if(!options.interactivity.modes.remove||"remove"!==mode)return;const removeNb=getRangeValue(options.interactivity.modes.remove.quantity);container.particles.removeQuantity(removeNb)}}clear(){}init(){}async interact(){}isEnabled(){return!0}loadModeOptions(options,...sources){options.remove||(options.remove=new Remove);for(const source of sources)options.remove.load(source?.remove)}reset(){}}class RepulseBase{constructor(){this.distance=200,this.duration=.4,this.factor=100,this.speed=1,this.maxSpeed=50,this.easing="ease-out-quad"}load(data){data&&(void 0!==data.distance&&(this.distance=data.distance),void 0!==data.duration&&(this.duration=data.duration),void 0!==data.easing&&(this.easing=data.easing),void 0!==data.factor&&(this.factor=data.factor),void 0!==data.speed&&(this.speed=data.speed),void 0!==data.maxSpeed&&(this.maxSpeed=data.maxSpeed))}}class RepulseDiv extends RepulseBase{constructor(){super(),this.selectors=[]}load(data){super.load(data),data&&void 0!==data.selectors&&(this.selectors=data.selectors)}}class Repulse extends RepulseBase{load(data){super.load(data),data&&(this.divs=executeOnSingleOrMultiple(data.divs,(div=>{const tmp=new RepulseDiv;return tmp.load(div),tmp})))}}class Repulser extends ExternalInteractorBase{constructor(engine,container){super(container),this._clickRepulse=()=>{const container=this.container,repulseOptions=container.actualOptions.interactivity.modes.repulse;if(!repulseOptions)return;const repulse=container.repulse||{particles:[]};if(repulse.finish||(repulse.count||(repulse.count=0),repulse.count++,repulse.count===container.particles.count&&(repulse.finish=!0)),repulse.clicking){const repulseDistance=container.retina.repulseModeDistance;if(!repulseDistance||repulseDistance<0)return;const repulseRadius=Math.pow(repulseDistance/6,3),mouseClickPos=container.interactivity.mouse.clickPosition;if(void 0===mouseClickPos)return;const range=new Circle(mouseClickPos.x,mouseClickPos.y,repulseRadius),query=container.particles.quadTree.query(range,(p=>this.isEnabled(p)));for(const particle of query){const{dx,dy,distance}=getDistances(mouseClickPos,particle.position),d=distance**2,force=-repulseRadius*repulseOptions.speed/d;if(d<=repulseRadius){repulse.particles.push(particle);const vect=Vector.create(dx,dy);vect.length=force,particle.velocity.setTo(vect)}}}else if(!1===repulse.clicking){for(const particle of repulse.particles)particle.velocity.setTo(particle.initialVelocity);repulse.particles=[]}},this._hoverRepulse=()=>{const container=this.container,mousePos=container.interactivity.mouse.position,repulseRadius=container.retina.repulseModeDistance;!repulseRadius||repulseRadius<0||!mousePos||this._processRepulse(mousePos,repulseRadius,new Circle(mousePos.x,mousePos.y,repulseRadius))},this._processRepulse=(position,repulseRadius,area,divRepulse)=>{const container=this.container,query=container.particles.quadTree.query(area,(p=>this.isEnabled(p))),repulseOptions=container.actualOptions.interactivity.modes.repulse;if(!repulseOptions)return;const{easing,speed,factor,maxSpeed}=repulseOptions,easingFunc=getEasing(easing),velocity=(divRepulse?.speed??speed)*factor;for(const particle of query){const{dx,dy,distance}=getDistances(particle.position,position),repulseFactor=clamp(easingFunc(1-distance/repulseRadius)*velocity,0,maxSpeed),normVec=Vector.create(0===distance?velocity:dx/distance*repulseFactor,0===distance?velocity:dy/distance*repulseFactor);particle.position.addTo(normVec)}},this._singleSelectorRepulse=(selector,div)=>{const container=this.container,repulse=container.actualOptions.interactivity.modes.repulse;if(!repulse)return;const query=document.querySelectorAll(selector);query.length&&query.forEach((item=>{const elem=item,pxRatio=container.retina.pixelRatio,pos={x:(elem.offsetLeft+elem.offsetWidth/2)*pxRatio,y:(elem.offsetTop+elem.offsetHeight/2)*pxRatio},repulseRadius=elem.offsetWidth/2*pxRatio,area="circle"===div.type?new Circle(pos.x,pos.y,repulseRadius):new Rectangle(elem.offsetLeft*pxRatio,elem.offsetTop*pxRatio,elem.offsetWidth*pxRatio,elem.offsetHeight*pxRatio),divRepulse=divMode(repulse.divs,elem);this._processRepulse(pos,repulseRadius,area,divRepulse)}))},this._engine=engine,container.repulse||(container.repulse={particles:[]}),this.handleClickMode=mode=>{const repulseOpts=this.container.actualOptions.interactivity.modes.repulse;if(!repulseOpts||"repulse"!==mode)return;container.repulse||(container.repulse={particles:[]});const repulse=container.repulse;repulse.clicking=!0,repulse.count=0;for(const particle of container.repulse.particles)this.isEnabled(particle)&&particle.velocity.setTo(particle.initialVelocity);repulse.particles=[],repulse.finish=!1,setTimeout((()=>{container.destroyed||(repulse.clicking=!1)}),1e3*repulseOpts.duration)}}clear(){}init(){const container=this.container,repulse=container.actualOptions.interactivity.modes.repulse;repulse&&(container.retina.repulseModeDistance=repulse.distance*container.retina.pixelRatio)}async interact(){const container=this.container,options=container.actualOptions,mouseMoveStatus="pointermove"===container.interactivity.status,events=options.interactivity.events,hover=events.onHover,hoverEnabled=hover.enable,hoverMode=hover.mode,click=events.onClick,clickEnabled=click.enable,clickMode=click.mode,divs=events.onDiv;mouseMoveStatus&&hoverEnabled&&isInArray("repulse",hoverMode)?this._hoverRepulse():clickEnabled&&isInArray("repulse",clickMode)?this._clickRepulse():divModeExecute("repulse",divs,((selector,div)=>this._singleSelectorRepulse(selector,div)))}isEnabled(particle){const container=this.container,options=container.actualOptions,mouse=container.interactivity.mouse,events=(particle?.interactivity??options.interactivity).events,divs=events.onDiv,hover=events.onHover,click=events.onClick,divRepulse=isDivModeEnabled("repulse",divs);if(!(divRepulse||hover.enable&&mouse.position||click.enable&&mouse.clickPosition))return!1;const hoverMode=hover.mode,clickMode=click.mode;return isInArray("repulse",hoverMode)||isInArray("repulse",clickMode)||divRepulse}loadModeOptions(options,...sources){options.repulse||(options.repulse=new Repulse);for(const source of sources)options.repulse.load(source?.repulse)}reset(){}}class Slow{constructor(){this.factor=3,this.radius=200}load(data){data&&(void 0!==data.factor&&(this.factor=data.factor),void 0!==data.radius&&(this.radius=data.radius))}}class Slower extends ExternalInteractorBase{constructor(container){super(container)}clear(particle,delta,force){particle.slow.inRange&&!force||(particle.slow.factor=1)}init(){const container=this.container,slow=container.actualOptions.interactivity.modes.slow;slow&&(container.retina.slowModeRadius=slow.radius*container.retina.pixelRatio)}async interact(){}isEnabled(particle){const container=this.container,mouse=container.interactivity.mouse,events=(particle?.interactivity??container.actualOptions.interactivity).events;return events.onHover.enable&&!!mouse.position&&isInArray("slow",events.onHover.mode)}loadModeOptions(options,...sources){options.slow||(options.slow=new Slow);for(const source of sources)options.slow.load(source?.slow)}reset(particle){particle.slow.inRange=!1;const container=this.container,options=container.actualOptions,mousePos=container.interactivity.mouse.position,radius=container.retina.slowModeRadius,slowOptions=options.interactivity.modes.slow;if(!slowOptions||!radius||radius<0||!mousePos)return;const dist=getDistance(mousePos,particle.getPosition()),proximityFactor=dist/radius,slowFactor=slowOptions.factor,{slow}=particle;dist>radius||(slow.inRange=!0,slow.factor=proximityFactor/slowFactor)}}const InterlaceOffsets=[0,4,2,1],InterlaceSteps=[8,8,4,2];class ByteStream{constructor(bytes){this.pos=0,this.data=new Uint8ClampedArray(bytes)}getString(count){const slice=this.data.slice(this.pos,this.pos+count);return this.pos+=slice.length,slice.reduce(((acc,curr)=>acc+String.fromCharCode(curr)),"")}nextByte(){return this.data[this.pos++]}nextTwoBytes(){return this.pos+=2,this.data[this.pos-2]+(this.data[this.pos-1]<<8)}readSubBlocks(){let blockString="",size=0;do{size=this.data[this.pos++];for(let count=size;--count>=0;blockString+=String.fromCharCode(this.data[this.pos++]));}while(0!==size);return blockString}readSubBlocksBin(){let size=0,len=0;for(let offset=0;0!==(size=this.data[this.pos+offset]);offset+=size+1)len+=size;const blockData=new Uint8Array(len);for(let i=0;0!==(size=this.data[this.pos++]);)for(let count=size;--count>=0;blockData[i++]=this.data[this.pos++]);return blockData}skipSubBlocks(){for(;0!==this.data[this.pos];this.pos+=this.data[this.pos]+1);this.pos++}}function parseColorTable(byteStream,count){const colors=[];for(let i=0;i<count;i++)colors.push({r:byteStream.data[byteStream.pos],g:byteStream.data[byteStream.pos+1],b:byteStream.data[byteStream.pos+2]}),byteStream.pos+=3;return colors}async function parseBlock(byteStream,gif,avgAlpha,getFrameIndex,getTransparencyIndex,progressCallback){switch(byteStream.nextByte()){case 59:return!0;case 44:await async function parseImageBlock(byteStream,gif,avgAlpha,getFrameIndex,getTransparencyIndex,progressCallback){const frame=gif.frames[getFrameIndex(!0)];frame.left=byteStream.nextTwoBytes(),frame.top=byteStream.nextTwoBytes(),frame.width=byteStream.nextTwoBytes(),frame.height=byteStream.nextTwoBytes();const packedByte=byteStream.nextByte(),localColorTableFlag=128==(128&packedByte),interlacedFlag=64==(64&packedByte);frame.sortFlag=32==(32&packedByte),frame.reserved=(24&packedByte)>>>3;const localColorCount=1<<1+(7&packedByte);localColorTableFlag&&(frame.localColorTable=parseColorTable(byteStream,localColorCount));const getColor=index=>{const{r,g,b}=(localColorTableFlag?frame.localColorTable:gif.globalColorTable)[index];return{r,g,b,a:index===getTransparencyIndex(null)?avgAlpha?~~((r+g+b)/3):0:255}},image=(()=>{try{return new ImageData(frame.width,frame.height,{colorSpace:"srgb"})}catch(error){if(error instanceof DOMException&&"IndexSizeError"===error.name)return null;throw error}})();if(null==image)throw new EvalError("GIF frame size is to large");const minCodeSize=byteStream.nextByte(),imageData=byteStream.readSubBlocksBin(),clearCode=1<<minCodeSize,readBits=(pos,len)=>{const bytePos=pos>>>3,bitPos=7&pos;return(imageData[bytePos]+(imageData[bytePos+1]<<8)+(imageData[bytePos+2]<<16)&(1<<len)-1<<bitPos)>>>bitPos};if(interlacedFlag){for(let code=0,size=minCodeSize+1,pos=0,dic=[[0]],pass=0;pass<4;pass++){if(InterlaceOffsets[pass]<frame.height)for(let pixelPos=0,lineIndex=0;;){const last=code;if(code=readBits(pos,size),pos+=size+1,code===clearCode){size=minCodeSize+1,dic.length=clearCode+2;for(let i=0;i<dic.length;i++)dic[i]=i<clearCode?[i]:[]}else{code>=dic.length?dic.push(dic[last].concat(dic[last][0])):last!==clearCode&&dic.push(dic[last].concat(dic[code][0]));for(let i=0;i<dic[code].length;i++){const{r,g,b,a}=getColor(dic[code][i]);image.data.set([r,g,b,a],InterlaceOffsets[pass]*frame.width+InterlaceSteps[pass]*lineIndex+pixelPos%(4*frame.width)),pixelPos+=4}dic.length===1<<size&&size<12&&size++}if(pixelPos===4*frame.width*(lineIndex+1)&&(lineIndex++,InterlaceOffsets[pass]+InterlaceSteps[pass]*lineIndex>=frame.height))break}progressCallback?.(byteStream.pos/(byteStream.data.length-1),getFrameIndex(!1)+1,image,{x:frame.left,y:frame.top},{width:gif.width,height:gif.height})}frame.image=image,frame.bitmap=await createImageBitmap(image)}else{for(let code=0,size=minCodeSize+1,pos=0,dic=[[0]],pixelPos=-4;;){const last=code;if(code=readBits(pos,size),pos+=size,code===clearCode){size=minCodeSize+1,dic.length=clearCode+2;for(let i=0;i<dic.length;i++)dic[i]=i<clearCode?[i]:[]}else{if(code===clearCode+1)break;code>=dic.length?dic.push(dic[last].concat(dic[last][0])):last!==clearCode&&dic.push(dic[last].concat(dic[code][0]));for(let i=0;i<dic[code].length;i++){const{r,g,b,a}=getColor(dic[code][i]);image.data.set([r,g,b,a],pixelPos+=4)}dic.length>=1<<size&&size<12&&size++}}frame.image=image,frame.bitmap=await createImageBitmap(image),progressCallback?.((byteStream.pos+1)/byteStream.data.length,getFrameIndex(!1)+1,frame.image,{x:frame.left,y:frame.top},{width:gif.width,height:gif.height})}}(byteStream,gif,avgAlpha,getFrameIndex,getTransparencyIndex,progressCallback);break;case 33:await async function parseExtensionBlock(byteStream,gif,getFrameIndex,getTransparencyIndex){switch(byteStream.nextByte()){case 249:{const frame=gif.frames[getFrameIndex(!1)];byteStream.pos++;const packedByte=byteStream.nextByte();frame.GCreserved=(224&packedByte)>>>5,frame.disposalMethod=(28&packedByte)>>>2,frame.userInputDelayFlag=2==(2&packedByte);const transparencyFlag=1==(1&packedByte);frame.delayTime=10*byteStream.nextTwoBytes();const transparencyIndex=byteStream.nextByte();transparencyFlag&&getTransparencyIndex(transparencyIndex),byteStream.pos++;break}case 255:{byteStream.pos++;const applicationExtension={identifier:byteStream.getString(8),authenticationCode:byteStream.getString(3),data:byteStream.readSubBlocksBin()};gif.applicationExtensions.push(applicationExtension);break}case 254:gif.comments.push([getFrameIndex(!1),byteStream.readSubBlocks()]);break;case 1:if(0===gif.globalColorTable.length)throw new EvalError("plain text extension without global color table");byteStream.pos++,gif.frames[getFrameIndex(!1)].plainTextData={left:byteStream.nextTwoBytes(),top:byteStream.nextTwoBytes(),width:byteStream.nextTwoBytes(),height:byteStream.nextTwoBytes(),charSize:{width:byteStream.nextTwoBytes(),height:byteStream.nextTwoBytes()},foregroundColor:byteStream.nextByte(),backgroundColor:byteStream.nextByte(),text:byteStream.readSubBlocks()};break;default:byteStream.skipSubBlocks()}}(byteStream,gif,getFrameIndex,getTransparencyIndex);break;default:throw new EvalError("undefined block found")}return!1}const currentColorRegex=/(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d.]+%?\))|currentcolor/gi;async function loadImage(image){return new Promise((resolve=>{image.loading=!0;const img=new Image;image.element=img,img.addEventListener("load",(()=>{image.loading=!1,resolve()})),img.addEventListener("error",(()=>{image.element=void 0,image.error=!0,image.loading=!1,getLogger().error(`${errorPrefix} loading image: ${image.source}`),resolve()})),img.src=image.source}))}async function loadGifImage(image){if("gif"===image.type){image.loading=!0;try{image.gifData=await async function decodeGIF(gifURL,progressCallback,avgAlpha){avgAlpha||(avgAlpha=!1);const res=await fetch(gifURL);if(!res.ok&&404===res.status)throw new EvalError("file not found");const buffer=await res.arrayBuffer(),gif={width:0,height:0,totalTime:0,colorRes:0,pixelAspectRatio:0,frames:[],sortFlag:!1,globalColorTable:[],backgroundImage:new ImageData(1,1,{colorSpace:"srgb"}),comments:[],applicationExtensions:[]},byteStream=new ByteStream(new Uint8ClampedArray(buffer));if("GIF89a"!==byteStream.getString(6))throw new Error("not a supported GIF file");gif.width=byteStream.nextTwoBytes(),gif.height=byteStream.nextTwoBytes();const packedByte=byteStream.nextByte(),globalColorTableFlag=128==(128&packedByte);gif.colorRes=(112&packedByte)>>>4,gif.sortFlag=8==(8&packedByte);const globalColorCount=1<<1+(7&packedByte),backgroundColorIndex=byteStream.nextByte();gif.pixelAspectRatio=byteStream.nextByte(),0!==gif.pixelAspectRatio&&(gif.pixelAspectRatio=(gif.pixelAspectRatio+15)/64),globalColorTableFlag&&(gif.globalColorTable=parseColorTable(byteStream,globalColorCount));const backgroundImage=(()=>{try{return new ImageData(gif.width,gif.height,{colorSpace:"srgb"})}catch(error){if(error instanceof DOMException&&"IndexSizeError"===error.name)return null;throw error}})();if(null==backgroundImage)throw new Error("GIF frame size is to large");const{r,g,b}=gif.globalColorTable[backgroundColorIndex];backgroundImage.data.set(globalColorTableFlag?[r,g,b,255]:[0,0,0,0]);for(let i=4;i<backgroundImage.data.length;i*=2)backgroundImage.data.copyWithin(i,0,i);gif.backgroundImage=backgroundImage;let frameIndex=-1,incrementFrameIndex=!0,transparencyIndex=-1;const getframeIndex=increment=>(increment&&(incrementFrameIndex=!0),frameIndex),getTransparencyIndex=newValue=>(null!=newValue&&(transparencyIndex=newValue),transparencyIndex);try{do{incrementFrameIndex&&(gif.frames.push({left:0,top:0,width:0,height:0,disposalMethod:0,image:new ImageData(1,1,{colorSpace:"srgb"}),plainTextData:null,userInputDelayFlag:!1,delayTime:0,sortFlag:!1,localColorTable:[],reserved:0,GCreserved:0}),frameIndex++,transparencyIndex=-1,incrementFrameIndex=!1)}while(!await parseBlock(byteStream,gif,avgAlpha,getframeIndex,getTransparencyIndex,progressCallback));gif.frames.length--;for(const frame of gif.frames){if(frame.userInputDelayFlag&&0===frame.delayTime){gif.totalTime=1/0;break}gif.totalTime+=frame.delayTime}return gif}catch(error){if(error instanceof EvalError)throw new Error(`error while parsing frame ${frameIndex} "${error.message}"`);throw error}}(image.source),image.gifLoopCount=function getGIFLoopAmount(gif){for(const extension of gif.applicationExtensions)if(extension.identifier+extension.authenticationCode==="NETSCAPE2.0")return extension.data[1]+(extension.data[2]<<8);return NaN}(image.gifData)??0,0===image.gifLoopCount&&(image.gifLoopCount=1/0)}catch{image.error=!0}image.loading=!1}else await loadImage(image)}async function downloadSvgImage(image){if("svg"!==image.type)return void await loadImage(image);image.loading=!0;const response=await fetch(image.source);response.ok?image.svgData=await response.text():(getLogger().error(`${errorPrefix} Image not found`),image.error=!0),image.loading=!1}function replaceImageColor(image,imageData,color,particle){const svgColoredData=function replaceColorSvg(imageShape,color,opacity){const{svgData}=imageShape;if(!svgData)return"";const colorStyle=getStyleFromHsl(color,opacity);if(svgData.includes("fill"))return svgData.replace(currentColorRegex,(()=>colorStyle));const preFillIndex=svgData.indexOf(">");return`${svgData.substring(0,preFillIndex)} fill="${colorStyle}"${svgData.substring(preFillIndex)}`}(image,color,particle.opacity?.value??1),imageRes={color,gif:imageData.gif,data:{...image,svgData:svgColoredData},loaded:!1,ratio:imageData.width/imageData.height,replaceColor:imageData.replaceColor,source:imageData.src};return new Promise((resolve=>{const svg=new Blob([svgColoredData],{type:"image/svg+xml"}),domUrl=URL||window.URL||window.webkitURL||window,url=domUrl.createObjectURL(svg),img=new Image;img.addEventListener("load",(()=>{imageRes.loaded=!0,imageRes.element=img,resolve(imageRes),domUrl.revokeObjectURL(url)})),img.addEventListener("error",(async()=>{domUrl.revokeObjectURL(url);const img2={...image,error:!1,loading:!0};await loadImage(img2),imageRes.loaded=!0,imageRes.element=img2.element,resolve(imageRes)})),img.src=url}))}class ImageDrawer{constructor(engine){this.loadImageShape=async imageShape=>{if(!this._engine.loadImage)throw new Error(`${errorPrefix} image shape not initialized`);await this._engine.loadImage({gif:imageShape.gif,name:imageShape.name,replaceColor:imageShape.replaceColor??!1,src:imageShape.src})},this._engine=engine}addImage(image){this._engine.images||(this._engine.images=[]),this._engine.images.push(image)}draw(data){const{context,radius,particle,opacity,delta}=data,image=particle.image,element=image?.element;if(image){if(context.globalAlpha=opacity,image.gif&&image.gifData){const offscreenCanvas=new OffscreenCanvas(image.gifData.width,image.gifData.height),offscreenContext=offscreenCanvas.getContext("2d");if(!offscreenContext)throw new Error("could not create offscreen canvas context");offscreenContext.imageSmoothingQuality="low",offscreenContext.imageSmoothingEnabled=!1,offscreenContext.clearRect(0,0,offscreenCanvas.width,offscreenCanvas.height),void 0===particle.gifLoopCount&&(particle.gifLoopCount=image.gifLoopCount??0);let frameIndex=particle.gifFrame??0;const pos={x:.5*-image.gifData.width,y:.5*-image.gifData.height},frame=image.gifData.frames[frameIndex];if(void 0===particle.gifTime&&(particle.gifTime=0),!frame.bitmap)return;switch(context.scale(radius/image.gifData.width,radius/image.gifData.height),frame.disposalMethod){case 4:case 5:case 6:case 7:case 0:offscreenContext.drawImage(frame.bitmap,frame.left,frame.top),context.drawImage(offscreenCanvas,pos.x,pos.y),offscreenContext.clearRect(0,0,offscreenCanvas.width,offscreenCanvas.height);break;case 1:offscreenContext.drawImage(frame.bitmap,frame.left,frame.top),context.drawImage(offscreenCanvas,pos.x,pos.y);break;case 2:offscreenContext.drawImage(frame.bitmap,frame.left,frame.top),context.drawImage(offscreenCanvas,pos.x,pos.y),offscreenContext.clearRect(0,0,offscreenCanvas.width,offscreenCanvas.height),0===image.gifData.globalColorTable.length?offscreenContext.putImageData(image.gifData.frames[0].image,pos.x+frame.left,pos.y+frame.top):offscreenContext.putImageData(image.gifData.backgroundImage,pos.x,pos.y);break;case 3:{const previousImageData=offscreenContext.getImageData(0,0,offscreenCanvas.width,offscreenCanvas.height);offscreenContext.drawImage(frame.bitmap,frame.left,frame.top),context.drawImage(offscreenCanvas,pos.x,pos.y),offscreenContext.clearRect(0,0,offscreenCanvas.width,offscreenCanvas.height),offscreenContext.putImageData(previousImageData,0,0)}}if(particle.gifTime+=delta.value,particle.gifTime>frame.delayTime){if(particle.gifTime-=frame.delayTime,++frameIndex>=image.gifData.frames.length){if(--particle.gifLoopCount<=0)return;frameIndex=0,offscreenContext.clearRect(0,0,offscreenCanvas.width,offscreenCanvas.height)}particle.gifFrame=frameIndex}context.scale(image.gifData.width/radius,image.gifData.height/radius)}else if(element){const ratio=image.ratio,pos={x:-radius,y:-radius},diameter=2*radius;context.drawImage(element,pos.x,pos.y,diameter,diameter/ratio)}context.globalAlpha=1}}getSidesCount(){return 12}async init(container){const options=container.actualOptions;if(options.preload&&this._engine.loadImage)for(const imageData of options.preload)await this._engine.loadImage(imageData)}loadShape(particle){if("image"!==particle.shape&&"images"!==particle.shape)return;this._engine.images||(this._engine.images=[]);const imageData=particle.shapeData;if(!imageData)return;this._engine.images.find((t=>t.name===imageData.name||t.source===imageData.src))||this.loadImageShape(imageData).then((()=>{this.loadShape(particle)}))}particleInit(container,particle){if("image"!==particle.shape&&"images"!==particle.shape)return;this._engine.images||(this._engine.images=[]);const images=this._engine.images,imageData=particle.shapeData;if(!imageData)return;const color=particle.getFillColor(),image=images.find((t=>t.name===imageData.name||t.source===imageData.src));if(!image)return;const replaceColor=imageData.replaceColor??image.replaceColor;image.loading?setTimeout((()=>{this.particleInit(container,particle)})):(async()=>{let imageRes;imageRes=image.svgData&&color?await replaceImageColor(image,imageData,color,particle):{color,data:image,element:image.element,gif:image.gif,gifData:image.gifData,gifLoopCount:image.gifLoopCount,loaded:!0,ratio:imageData.width&&imageData.height?imageData.width/imageData.height:image.ratio??1,replaceColor,source:imageData.src},imageRes.ratio||(imageRes.ratio=1);const imageShape={image:imageRes,fill:imageData.fill??particle.shapeFill,close:imageData.close??particle.shapeClose};particle.image=imageShape.image,particle.shapeFill=imageShape.fill,particle.shapeClose=imageShape.close})()}}class Preload{constructor(){this.src="",this.gif=!1}load(data){data&&(void 0!==data.gif&&(this.gif=data.gif),void 0!==data.height&&(this.height=data.height),void 0!==data.name&&(this.name=data.name),void 0!==data.replaceColor&&(this.replaceColor=data.replaceColor),void 0!==data.src&&(this.src=data.src),void 0!==data.width&&(this.width=data.width))}}class ImagePreloaderPlugin{constructor(engine){this.id="imagePreloader",this._engine=engine}getPlugin(){return{}}loadOptions(options,source){if(!source||!source.preload)return;options.preload||(options.preload=[]);const preloadOptions=options.preload;for(const item of source.preload){const existing=preloadOptions.find((t=>t.name===item.name||t.src===item.src));if(existing)existing.load(item);else{const preload=new Preload;preload.load(item),preloadOptions.push(preload)}}}needsPlugin(){return!0}}async function loadImageShape(engine,refresh=!0){!function addLoadImageToEngine(engine){engine.loadImage||(engine.loadImage=async data=>{if(!data.name&&!data.src)throw new Error(`${errorPrefix} no image source provided`);if(engine.images||(engine.images=[]),!engine.images.find((t=>t.name===data.name||t.source===data.src)))try{const image={gif:data.gif??!1,name:data.name??data.src,source:data.src,type:data.src.substring(data.src.length-3),error:!1,loading:!0,replaceColor:data.replaceColor,ratio:data.width&&data.height?data.width/data.height:void 0};engine.images.push(image);const imageFunc=data.gif?loadGifImage:data.replaceColor?downloadSvgImage:loadImage;await imageFunc(image)}catch{throw new Error(`${errorPrefix} ${data.name??data.src} not found`)}})}(engine);const preloader=new ImagePreloaderPlugin(engine);await engine.addPlugin(preloader,refresh),await engine.addShape(["image","images"],new ImageDrawer(engine),refresh)}class LifeDelay extends ValueWithRandom{constructor(){super(),this.sync=!1}load(data){data&&(super.load(data),void 0!==data.sync&&(this.sync=data.sync))}}class LifeDuration extends ValueWithRandom{constructor(){super(),this.sync=!1}load(data){data&&(super.load(data),void 0!==data.sync&&(this.sync=data.sync))}}class Life{constructor(){this.count=0,this.delay=new LifeDelay,this.duration=new LifeDuration}load(data){data&&(void 0!==data.count&&(this.count=data.count),this.delay.load(data.delay),this.duration.load(data.duration))}}class LifeUpdater{constructor(container){this.container=container}init(particle){const container=this.container,lifeOptions=particle.options.life;lifeOptions&&(particle.life={delay:container.retina.reduceFactor?getRangeValue(lifeOptions.delay.value)*(lifeOptions.delay.sync?1:getRandom())/container.retina.reduceFactor*1e3:0,delayTime:0,duration:container.retina.reduceFactor?getRangeValue(lifeOptions.duration.value)*(lifeOptions.duration.sync?1:getRandom())/container.retina.reduceFactor*1e3:0,time:0,count:lifeOptions.count},particle.life.duration<=0&&(particle.life.duration=-1),particle.life.count<=0&&(particle.life.count=-1),particle.life&&(particle.spawning=particle.life.delay>0))}isEnabled(particle){return!particle.destroyed}loadOptions(options,...sources){options.life||(options.life=new Life);for(const source of sources)options.life.load(source?.life)}update(particle,delta){if(!this.isEnabled(particle)||!particle.life)return;const life=particle.life;let justSpawned=!1;if(particle.spawning){if(life.delayTime+=delta.value,!(life.delayTime>=particle.life.delay))return;justSpawned=!0,particle.spawning=!1,life.delayTime=0,life.time=0}if(-1===life.duration)return;if(particle.spawning)return;if(justSpawned?life.time=0:life.time+=delta.value,life.time<life.duration)return;if(life.time=0,particle.life.count>0&&particle.life.count--,0===particle.life.count)return void particle.destroy();const canvasSize=this.container.canvas.size,widthRange=setRangeValue(0,canvasSize.width),heightRange=setRangeValue(0,canvasSize.width);particle.position.x=randomInRange(widthRange),particle.position.y=randomInRange(heightRange),particle.spawning=!0,life.delayTime=0,life.time=0,particle.reset();const lifeOptions=particle.options.life;lifeOptions&&(life.delay=1e3*getRangeValue(lifeOptions.delay.value),life.duration=1e3*getRangeValue(lifeOptions.duration.value))}}class LineDrawer{draw(data){const{context,particle,radius}=data,shapeData=particle.shapeData;context.moveTo(-radius/2,0),context.lineTo(radius/2,0),context.lineCap=shapeData?.cap??"butt"}getSidesCount(){return 1}}class ParallaxMover{init(){}isEnabled(particle){return!isSsr()&&!particle.destroyed&&particle.container.actualOptions.interactivity.events.onHover.parallax.enable}move(particle){const container=particle.container,parallaxOptions=container.actualOptions.interactivity.events.onHover.parallax;if(isSsr()||!parallaxOptions.enable)return;const parallaxForce=parallaxOptions.force,mousePos=container.interactivity.mouse.position;if(!mousePos)return;const canvasSize=container.canvas.size,canvasCenter_x=.5*canvasSize.width,canvasCenter_y=.5*canvasSize.height,parallaxSmooth=parallaxOptions.smooth,factor=particle.getRadius()/parallaxForce,centerDistance_x=(mousePos.x-canvasCenter_x)*factor,centerDistance_y=(mousePos.y-canvasCenter_y)*factor,{offset}=particle;offset.x+=(centerDistance_x-offset.x)/parallaxSmooth,offset.y+=(centerDistance_y-offset.y)/parallaxSmooth}}class Attractor_Attractor extends ParticlesInteractorBase{constructor(container){super(container)}clear(){}init(){}async interact(p1){const container=this.container;void 0===p1.attractDistance&&(p1.attractDistance=getRangeValue(p1.options.move.attract.distance)*container.retina.pixelRatio);const distance=p1.attractDistance,pos1=p1.getPosition(),query=container.particles.quadTree.queryCircle(pos1,distance);for(const p2 of query){if(p1===p2||!p2.options.move.attract.enable||p2.destroyed||p2.spawning)continue;const pos2=p2.getPosition(),{dx,dy}=getDistances(pos1,pos2),rotate=p1.options.move.attract.rotate,ax=dx/(1e3*rotate.x),ay=dy/(1e3*rotate.y),p1Factor=p2.size.value/p1.size.value,p2Factor=1/p1Factor;p1.velocity.x-=ax*p1Factor,p1.velocity.y-=ay*p1Factor,p2.velocity.x+=ax*p2Factor,p2.velocity.y+=ay*p2Factor}}isEnabled(particle){return particle.options.move.attract.enable}reset(){}}function updateAbsorb(p1,r1,p2,r2,delta,pixelRatio){const factor=clamp(p1.options.collisions.absorb.speed*delta.factor/10,0,r2);p1.size.value+=factor/2,p2.size.value-=factor,r2<=pixelRatio&&(p2.size.value=0,p2.destroy())}const fixBounceSpeed=p=>{void 0===p.collisionMaxSpeed&&(p.collisionMaxSpeed=getRangeValue(p.options.collisions.maxSpeed)),p.velocity.length>p.collisionMaxSpeed&&(p.velocity.length=p.collisionMaxSpeed)};function bounce(p1,p2){circleBounce(circleBounceDataFromParticle(p1),circleBounceDataFromParticle(p2)),fixBounceSpeed(p1),fixBounceSpeed(p2)}function resolveCollision(p1,p2,delta,pixelRatio){switch(p1.options.collisions.mode){case"absorb":!function absorb(p1,p2,delta,pixelRatio){const r1=p1.getRadius(),r2=p2.getRadius();void 0===r1&&void 0!==r2?p1.destroy():void 0!==r1&&void 0===r2?p2.destroy():void 0!==r1&&void 0!==r2&&(r1>=r2?updateAbsorb(p1,0,p2,r2,delta,pixelRatio):updateAbsorb(p2,0,p1,r1,delta,pixelRatio))}(p1,p2,delta,pixelRatio);break;case"bounce":bounce(p1,p2);break;case"destroy":!function destroy(p1,p2){p1.unbreakable||p2.unbreakable||bounce(p1,p2),void 0===p1.getRadius()&&void 0!==p2.getRadius()?p1.destroy():void 0!==p1.getRadius()&&void 0===p2.getRadius()?p2.destroy():void 0!==p1.getRadius()&&void 0!==p2.getRadius()&&(p1.getRadius()>=p2.getRadius()?p2:p1).destroy()}(p1,p2)}}class Collider extends ParticlesInteractorBase{constructor(container){super(container)}clear(){}init(){}async interact(p1,delta){if(p1.destroyed||p1.spawning)return;const container=this.container,pos1=p1.getPosition(),radius1=p1.getRadius(),query=container.particles.quadTree.queryCircle(pos1,2*radius1);for(const p2 of query){if(p1===p2||!p2.options.collisions.enable||p1.options.collisions.mode!==p2.options.collisions.mode||p2.destroyed||p2.spawning)continue;const pos2=p2.getPosition(),radius2=p2.getRadius();if(Math.abs(Math.round(pos1.z)-Math.round(pos2.z))>radius1+radius2)continue;getDistance(pos1,pos2)>radius1+radius2||resolveCollision(p1,p2,delta,container.retina.pixelRatio)}}isEnabled(particle){return particle.options.collisions.enable}reset(){}}class CircleWarp extends Circle{constructor(x,y,radius,canvasSize){super(x,y,radius),this.canvasSize=canvasSize,this.canvasSize={...canvasSize}}contains(point){const{width,height}=this.canvasSize,{x,y}=point;return super.contains(point)||super.contains({x:x-width,y})||super.contains({x:x-width,y:y-height})||super.contains({x,y:y-height})}intersects(range){if(super.intersects(range))return!0;const rect=range,circle=range,newPos={x:range.position.x-this.canvasSize.width,y:range.position.y-this.canvasSize.height};if(void 0!==circle.radius){const biggerCircle=new Circle(newPos.x,newPos.y,2*circle.radius);return super.intersects(biggerCircle)}if(void 0!==rect.size){const rectSW=new Rectangle(newPos.x,newPos.y,2*rect.size.width,2*rect.size.height);return super.intersects(rectSW)}return!1}}class LinksShadow{constructor(){this.blur=5,this.color=new OptionsColor,this.color.value="#000",this.enable=!1}load(data){data&&(void 0!==data.blur&&(this.blur=data.blur),this.color=OptionsColor.create(this.color,data.color),void 0!==data.enable&&(this.enable=data.enable))}}class LinksTriangle{constructor(){this.enable=!1,this.frequency=1}load(data){data&&(void 0!==data.color&&(this.color=OptionsColor.create(this.color,data.color)),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.frequency&&(this.frequency=data.frequency),void 0!==data.opacity&&(this.opacity=data.opacity))}}class Links{constructor(){this.blink=!1,this.color=new OptionsColor,this.color.value="#fff",this.consent=!1,this.distance=100,this.enable=!1,this.frequency=1,this.opacity=1,this.shadow=new LinksShadow,this.triangles=new LinksTriangle,this.width=1,this.warp=!1}load(data){data&&(void 0!==data.id&&(this.id=data.id),void 0!==data.blink&&(this.blink=data.blink),this.color=OptionsColor.create(this.color,data.color),void 0!==data.consent&&(this.consent=data.consent),void 0!==data.distance&&(this.distance=data.distance),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.frequency&&(this.frequency=data.frequency),void 0!==data.opacity&&(this.opacity=data.opacity),this.shadow.load(data.shadow),this.triangles.load(data.triangles),void 0!==data.width&&(this.width=data.width),void 0!==data.warp&&(this.warp=data.warp))}}function getLinkDistance(pos1,pos2,optDistance,canvasSize,warp){const{dx,dy,distance}=getDistances(pos1,pos2);if(!warp||distance<=optDistance)return distance;const absDiffs={x:Math.abs(dx),y:Math.abs(dy)},warpDistances_x=Math.min(absDiffs.x,canvasSize.width-absDiffs.x),warpDistances_y=Math.min(absDiffs.y,canvasSize.height-absDiffs.y);return Math.sqrt(warpDistances_x**2+warpDistances_y**2)}class Linker extends ParticlesInteractorBase{constructor(container){super(container),this._setColor=p1=>{if(!p1.options.links)return;const container=this.linkContainer,linksOptions=p1.options.links;let linkColor=void 0===linksOptions.id?container.particles.linksColor:container.particles.linksColors.get(linksOptions.id);if(linkColor)return;linkColor=getLinkRandomColor(linksOptions.color,linksOptions.blink,linksOptions.consent),void 0===linksOptions.id?container.particles.linksColor=linkColor:container.particles.linksColors.set(linksOptions.id,linkColor)},this.linkContainer=container}clear(){}init(){this.linkContainer.particles.linksColor=void 0,this.linkContainer.particles.linksColors=new Map}async interact(p1){if(!p1.options.links)return;p1.links=[];const pos1=p1.getPosition(),container=this.container,canvasSize=container.canvas.size;if(pos1.x<0||pos1.y<0||pos1.x>canvasSize.width||pos1.y>canvasSize.height)return;const linkOpt1=p1.options.links,optOpacity=linkOpt1.opacity,optDistance=p1.retina.linksDistance??0,warp=linkOpt1.warp,range=warp?new CircleWarp(pos1.x,pos1.y,optDistance,canvasSize):new Circle(pos1.x,pos1.y,optDistance),query=container.particles.quadTree.query(range);for(const p2 of query){const linkOpt2=p2.options.links;if(p1===p2||!linkOpt2?.enable||linkOpt1.id!==linkOpt2.id||p2.spawning||p2.destroyed||!p2.links||p1.links.some((t=>t.destination===p2))||p2.links.some((t=>t.destination===p1)))continue;const pos2=p2.getPosition();if(pos2.x<0||pos2.y<0||pos2.x>canvasSize.width||pos2.y>canvasSize.height)continue;const distance=getLinkDistance(pos1,pos2,optDistance,canvasSize,warp&&linkOpt2.warp);if(distance>optDistance)continue;const opacityLine=(1-distance/optDistance)*optOpacity;this._setColor(p1),p1.links.push({destination:p2,opacity:opacityLine})}}isEnabled(particle){return!!particle.options.links?.enable}loadParticlesOptions(options,...sources){options.links||(options.links=new Links);for(const source of sources)options.links.load(source?.links)}reset(){}}function setLinkFrequency(particles,dictionary){const key=function getLinkKey(ids){return ids.sort(((a,b)=>a-b)),ids.join("_")}(particles.map((t=>t.id)));let res=dictionary.get(key);return void 0===res&&(res=getRandom(),dictionary.set(key,res)),res}class LinkInstance{constructor(container){this.container=container,this._drawLinkLine=(p1,link)=>{const p1LinksOptions=p1.options.links;if(!p1LinksOptions?.enable)return;const container=this.container,options=container.actualOptions,p2=link.destination,pos1=p1.getPosition(),pos2=p2.getPosition();let opacity=link.opacity;container.canvas.draw((ctx=>{let colorLine;const twinkle=p1.options.twinkle?.lines;if(twinkle?.enable){const twinkleFreq=twinkle.frequency,twinkleRgb=rangeColorToRgb(twinkle.color);getRandom()<twinkleFreq&&twinkleRgb&&(colorLine=twinkleRgb,opacity=getRangeValue(twinkle.opacity))}if(!colorLine){const linkColor=void 0!==p1LinksOptions.id?container.particles.linksColors.get(p1LinksOptions.id):container.particles.linksColor;colorLine=getLinkColor(p1,p2,linkColor)}if(!colorLine)return;const width=p1.retina.linksWidth??0,maxDistance=p1.retina.linksDistance??0,{backgroundMask}=options;!function drawLinkLine(params){let drawn=!1;const{begin,end,maxDistance,context,canvasSize,width,backgroundMask,colorLine,opacity,links}=params;if(getDistance(begin,end)<=maxDistance)drawLine(context,begin,end),drawn=!0;else if(links.warp){let pi1,pi2;const d1=getDistances(begin,{x:end.x-canvasSize.width,y:end.y});if(d1.distance<=maxDistance){const yi=begin.y-d1.dy/d1.dx*begin.x;pi1={x:0,y:yi},pi2={x:canvasSize.width,y:yi}}else{const d2=getDistances(begin,{x:end.x,y:end.y-canvasSize.height});if(d2.distance<=maxDistance){const xi=-(begin.y-d2.dy/d2.dx*begin.x)/(d2.dy/d2.dx);pi1={x:xi,y:0},pi2={x:xi,y:canvasSize.height}}else{const d3=getDistances(begin,{x:end.x-canvasSize.width,y:end.y-canvasSize.height});if(d3.distance<=maxDistance){const yi=begin.y-d3.dy/d3.dx*begin.x;pi1={x:-yi/(d3.dy/d3.dx),y:yi},pi2={x:pi1.x+canvasSize.width,y:pi1.y+canvasSize.height}}}}pi1&&pi2&&(drawLine(context,begin,pi1),drawLine(context,end,pi2),drawn=!0)}if(!drawn)return;context.lineWidth=width,backgroundMask.enable&&(context.globalCompositeOperation=backgroundMask.composite),context.strokeStyle=getStyleFromRgb(colorLine,opacity);const{shadow}=links;if(shadow.enable){const shadowColor=rangeColorToRgb(shadow.color);shadowColor&&(context.shadowBlur=shadow.blur,context.shadowColor=getStyleFromRgb(shadowColor))}context.stroke()}({context:ctx,width,begin:pos1,end:pos2,maxDistance,canvasSize:container.canvas.size,links:p1LinksOptions,backgroundMask,colorLine,opacity})}))},this._drawLinkTriangle=(p1,link1,link2)=>{const linksOptions=p1.options.links;if(!linksOptions?.enable)return;const triangleOptions=linksOptions.triangles;if(!triangleOptions.enable)return;const container=this.container,options=container.actualOptions,p2=link1.destination,p3=link2.destination,opacityTriangle=triangleOptions.opacity??(link1.opacity+link2.opacity)/2;opacityTriangle<=0||container.canvas.draw((ctx=>{const pos1=p1.getPosition(),pos2=p2.getPosition(),pos3=p3.getPosition(),linksDistance=p1.retina.linksDistance??0;if(getDistance(pos1,pos2)>linksDistance||getDistance(pos3,pos2)>linksDistance||getDistance(pos3,pos1)>linksDistance)return;let colorTriangle=rangeColorToRgb(triangleOptions.color);if(!colorTriangle){const linkColor=void 0!==linksOptions.id?container.particles.linksColors.get(linksOptions.id):container.particles.linksColor;colorTriangle=getLinkColor(p1,p2,linkColor)}colorTriangle&&function drawLinkTriangle(params){const{context,pos1,pos2,pos3,backgroundMask,colorTriangle,opacityTriangle}=params;!function drawTriangle(context,p1,p2,p3){context.beginPath(),context.moveTo(p1.x,p1.y),context.lineTo(p2.x,p2.y),context.lineTo(p3.x,p3.y),context.closePath()}(context,pos1,pos2,pos3),backgroundMask.enable&&(context.globalCompositeOperation=backgroundMask.composite),context.fillStyle=getStyleFromRgb(colorTriangle,opacityTriangle),context.fill()}({context:ctx,pos1,pos2,pos3,backgroundMask:options.backgroundMask,colorTriangle,opacityTriangle})}))},this._drawTriangles=(options,p1,link,p1Links)=>{const p2=link.destination;if(!options.links?.triangles.enable||!p2.options.links?.triangles.enable)return;const vertices=p2.links?.filter((t=>{const linkFreq=this._getLinkFrequency(p2,t.destination);return p2.options.links&&linkFreq<=p2.options.links.frequency&&p1Links.findIndex((l=>l.destination===t.destination))>=0}));if(vertices?.length)for(const vertex of vertices){const p3=vertex.destination;this._getTriangleFrequency(p1,p2,p3)>options.links.triangles.frequency||this._drawLinkTriangle(p1,link,vertex)}},this._getLinkFrequency=(p1,p2)=>setLinkFrequency([p1,p2],this._freqs.links),this._getTriangleFrequency=(p1,p2,p3)=>setLinkFrequency([p1,p2,p3],this._freqs.triangles),this._freqs={links:new Map,triangles:new Map}}drawParticle(context,particle){const{links,options}=particle;if(!links||links.length<=0)return;const p1Links=links.filter((l=>options.links&&this._getLinkFrequency(particle,l.destination)<=options.links.frequency));for(const link of p1Links)this._drawTriangles(options,particle,link,p1Links),link.opacity>0&&(particle.retina.linksWidth??0)>0&&this._drawLinkLine(particle,link)}async init(){this._freqs.links=new Map,this._freqs.triangles=new Map}particleCreated(particle){if(particle.links=[],!particle.options.links)return;const ratio=this.container.retina.pixelRatio,{retina}=particle,{distance,width}=particle.options.links;retina.linksDistance=distance*ratio,retina.linksWidth=width*ratio}particleDestroyed(particle){particle.links=[]}}class LinksPlugin{constructor(){this.id="links"}getPlugin(container){return new LinkInstance(container)}loadOptions(){}needsPlugin(){return!0}}async function loadParticlesLinksInteraction(engine,refresh=!0){await async function loadLinksInteraction(engine,refresh=!0){await engine.addInteractor("particlesLinks",(container=>new Linker(container)),refresh)}(engine,refresh),await async function loadLinksPlugin(engine,refresh=!0){const plugin=new LinksPlugin;await engine.addPlugin(plugin,refresh)}(engine,refresh)}class PolygonDrawerBase{draw(data){const{context,particle,radius}=data,start=this.getCenter(particle,radius),side=this.getSidesData(particle,radius),sideCount=side.count.numerator*side.count.denominator,decimalSides=side.count.numerator/side.count.denominator,interiorAngleDegrees=180*(decimalSides-2)/decimalSides,interiorAngle=Math.PI-Math.PI*interiorAngleDegrees/180;if(context){context.beginPath(),context.translate(start.x,start.y),context.moveTo(0,0);for(let i=0;i<sideCount;i++)context.lineTo(side.length,0),context.translate(side.length,0),context.rotate(interiorAngle)}}getSidesCount(particle){const polygon=particle.shapeData;return Math.round(getRangeValue(polygon?.sides??5))}}class PolygonDrawer extends PolygonDrawerBase{getCenter(particle,radius){return{x:-radius/(particle.sides/3.5),y:-radius/.76}}getSidesData(particle,radius){const sides=particle.sides;return{count:{denominator:1,numerator:sides},length:2.66*radius/(sides/3)}}}class TriangleDrawer extends PolygonDrawerBase{getCenter(particle,radius){return{x:-radius,y:radius/1.66}}getSidesCount(){return 3}getSidesData(particle,radius){return{count:{denominator:2,numerator:3},length:2*radius}}}async function loadPolygonShape(engine,refresh=!0){await async function loadGenericPolygonShape(engine,refresh=!0){await engine.addShape("polygon",new PolygonDrawer,refresh)}(engine,refresh),await async function loadTriangleShape(engine,refresh=!0){await engine.addShape("triangle",new TriangleDrawer,refresh)}(engine,refresh)}class RotateAnimation{constructor(){this.enable=!1,this.speed=0,this.decay=0,this.sync=!1}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.speed&&(this.speed=setRangeValue(data.speed)),void 0!==data.decay&&(this.decay=setRangeValue(data.decay)),void 0!==data.sync&&(this.sync=data.sync))}}class Rotate extends ValueWithRandom{constructor(){super(),this.animation=new RotateAnimation,this.direction="clockwise",this.path=!1,this.value=0}load(data){data&&(super.load(data),void 0!==data.direction&&(this.direction=data.direction),this.animation.load(data.animation),void 0!==data.path&&(this.path=data.path))}}class RotateUpdater{constructor(container){this.container=container}init(particle){const rotateOptions=particle.options.rotate;if(!rotateOptions)return;particle.rotate={enable:rotateOptions.animation.enable,value:getRangeValue(rotateOptions.value)*Math.PI/180},particle.pathRotation=rotateOptions.path;let rotateDirection=rotateOptions.direction;if("random"===rotateDirection){rotateDirection=Math.floor(2*getRandom())>0?"counter-clockwise":"clockwise"}switch(rotateDirection){case"counter-clockwise":case"counterClockwise":particle.rotate.status="decreasing";break;case"clockwise":particle.rotate.status="increasing"}const rotateAnimation=rotateOptions.animation;rotateAnimation.enable&&(particle.rotate.decay=1-getRangeValue(rotateAnimation.decay),particle.rotate.velocity=getRangeValue(rotateAnimation.speed)/360*this.container.retina.reduceFactor,rotateAnimation.sync||(particle.rotate.velocity*=getRandom())),particle.rotation=particle.rotate.value}isEnabled(particle){const rotate=particle.options.rotate;return!!rotate&&(!particle.destroyed&&!particle.spawning&&rotate.animation.enable&&!rotate.path)}loadOptions(options,...sources){options.rotate||(options.rotate=new Rotate);for(const source of sources)options.rotate.load(source?.rotate)}update(particle,delta){this.isEnabled(particle)&&(!function updateRotate(particle,delta){const rotate=particle.rotate,rotateOptions=particle.options.rotate;if(!rotate||!rotateOptions)return;const rotateAnimation=rotateOptions.animation,speed=(rotate.velocity??0)*delta.factor,max=2*Math.PI,decay=rotate.decay??1;rotateAnimation.enable&&("increasing"===rotate.status?(rotate.value+=speed,rotate.value>max&&(rotate.value-=max)):(rotate.value-=speed,rotate.value<0&&(rotate.value+=max)),rotate.velocity&&1!==decay&&(rotate.velocity*=decay))}(particle,delta),particle.rotation=particle.rotate?.value??0)}}const fixFactor=Math.sqrt(2);class SquareDrawer{draw(data){const{context,radius}=data,fixedRadius=radius/fixFactor,fixedDiameter=2*fixedRadius;context.rect(-fixedRadius,-fixedRadius,fixedDiameter,fixedDiameter)}getSidesCount(){return 4}}class StarDrawer{draw(data){const{context,particle,radius}=data,sides=particle.sides,inset=particle.starInset??2;context.moveTo(0,0-radius);for(let i=0;i<sides;i++)context.rotate(Math.PI/sides),context.lineTo(0,0-radius*inset),context.rotate(Math.PI/sides),context.lineTo(0,0-radius)}getSidesCount(particle){const star=particle.shapeData;return Math.round(getRangeValue(star?.sides??5))}particleInit(container,particle){const star=particle.shapeData;particle.starInset=getRangeValue(star?.inset??2)}}function Utils_updateColorValue(delta,colorValue,valueAnimation,max,decrease){if(!colorValue||!valueAnimation.enable||(colorValue.maxLoops??0)>0&&(colorValue.loops??0)>(colorValue.maxLoops??0))return;if(colorValue.time||(colorValue.time=0),(colorValue.delayTime??0)>0&&colorValue.time<(colorValue.delayTime??0)&&(colorValue.time+=delta.value),(colorValue.delayTime??0)>0&&colorValue.time<(colorValue.delayTime??0))return;const offset=randomInRange(valueAnimation.offset),velocity=(colorValue.velocity??0)*delta.factor+3.6*offset,decay=colorValue.decay??1;decrease&&"increasing"!==colorValue.status?(colorValue.value-=velocity,colorValue.value<0&&(colorValue.loops||(colorValue.loops=0),colorValue.loops++,colorValue.status="increasing",colorValue.value+=colorValue.value)):(colorValue.value+=velocity,colorValue.value>max&&(colorValue.loops||(colorValue.loops=0),colorValue.loops++,decrease&&(colorValue.status="decreasing",colorValue.value-=colorValue.value%max))),colorValue.velocity&&1!==decay&&(colorValue.velocity*=decay),colorValue.value>max&&(colorValue.value%=max)}class StrokeColorUpdater{constructor(container){this.container=container}init(particle){const container=this.container,options=particle.options,stroke=itemFromSingleOrMultiple(options.stroke,particle.id,options.reduceDuplicates);particle.strokeWidth=getRangeValue(stroke.width)*container.retina.pixelRatio,particle.strokeOpacity=getRangeValue(stroke.opacity??1),particle.strokeAnimation=stroke.color?.animation;const strokeHslColor=rangeColorToHsl(stroke.color)??particle.getFillColor();strokeHslColor&&(particle.strokeColor=getHslAnimationFromHsl(strokeHslColor,particle.strokeAnimation,container.retina.reduceFactor))}isEnabled(particle){const color=particle.strokeAnimation,{strokeColor}=particle;return!particle.destroyed&&!particle.spawning&&!!color&&(void 0!==strokeColor?.h.value&&strokeColor.h.enable||void 0!==strokeColor?.s.value&&strokeColor.s.enable||void 0!==strokeColor?.l.value&&strokeColor.l.enable)}update(particle,delta){this.isEnabled(particle)&&function updateStrokeColor(particle,delta){if(!particle.strokeColor||!particle.strokeAnimation)return;const{h,s,l}=particle.strokeColor,{h:hAnimation,s:sAnimation,l:lAnimation}=particle.strokeAnimation;h&&Utils_updateColorValue(delta,h,hAnimation,360,!1),s&&Utils_updateColorValue(delta,s,sAnimation,100,!0),l&&Utils_updateColorValue(delta,l,lAnimation,100,!0)}(particle,delta)}}async function loadSlim(engine,refresh=!0){await async function loadParallaxMover(engine,refresh=!0){await engine.addMover("parallax",(()=>new ParallaxMover),refresh)}(engine,!1),await async function loadExternalAttractInteraction(engine,refresh=!0){await engine.addInteractor("externalAttract",(container=>new Attractor(engine,container)),refresh)}(engine,!1),await async function loadExternalBounceInteraction(engine,refresh=!0){await engine.addInteractor("externalBounce",(container=>new Bouncer(container)),refresh)}(engine,!1),await async function loadExternalBubbleInteraction(engine,refresh=!0){await engine.addInteractor("externalBubble",(container=>new Bubbler(container)),refresh)}(engine,!1),await async function loadExternalConnectInteraction(engine,refresh=!0){await engine.addInteractor("externalConnect",(container=>new Connector(container)),refresh)}(engine,!1),await async function loadExternalGrabInteraction(engine,refresh=!0){await engine.addInteractor("externalGrab",(container=>new Grabber(container)),refresh)}(engine,!1),await async function loadExternalPauseInteraction(engine,refresh=!0){await engine.addInteractor("externalPause",(container=>new Pauser(container)),refresh)}(engine,!1),await async function loadExternalPushInteraction(engine,refresh=!0){await engine.addInteractor("externalPush",(container=>new Pusher(container)),refresh)}(engine,!1),await async function loadExternalRemoveInteraction(engine,refresh=!0){await engine.addInteractor("externalRemove",(container=>new Remover(container)),refresh)}(engine,!1),await async function loadExternalRepulseInteraction(engine,refresh=!0){await engine.addInteractor("externalRepulse",(container=>new Repulser(engine,container)),refresh)}(engine,!1),await async function loadExternalSlowInteraction(engine,refresh=!0){await engine.addInteractor("externalSlow",(container=>new Slower(container)),refresh)}(engine,!1),await async function loadParticlesAttractInteraction(engine,refresh=!0){await engine.addInteractor("particlesAttract",(container=>new Attractor_Attractor(container)),refresh)}(engine,!1),await async function loadParticlesCollisionsInteraction(engine,refresh=!0){await engine.addInteractor("particlesCollisions",(container=>new Collider(container)),refresh)}(engine,!1),await loadParticlesLinksInteraction(engine,!1),await async function loadEasingQuadPlugin(){addEasing("ease-in-quad",(value=>value**2)),addEasing("ease-out-quad",(value=>1-(1-value)**2)),addEasing("ease-in-out-quad",(value=>value<.5?2*value**2:1-(-2*value+2)**2/2))}(),await async function loadEmojiShape(engine,refresh=!0){await engine.addShape(validTypes,new EmojiDrawer,refresh)}(engine,!1),await loadImageShape(engine,!1),await async function loadLineShape(engine,refresh=!0){await engine.addShape("line",new LineDrawer,refresh)}(engine,!1),await loadPolygonShape(engine,!1),await async function loadSquareShape(engine,refresh=!0){await engine.addShape(["edge","square"],new SquareDrawer,refresh)}(engine,!1),await async function loadStarShape(engine,refresh=!0){await engine.addShape("star",new StarDrawer,refresh)}(engine,!1),await async function loadLifeUpdater(engine,refresh=!0){await engine.addParticleUpdater("life",(container=>new LifeUpdater(container)),refresh)}(engine,!1),await async function loadRotateUpdater(engine,refresh=!0){await engine.addParticleUpdater("rotate",(container=>new RotateUpdater(container)),refresh)}(engine,!1),await async function loadStrokeColorUpdater(engine,refresh=!0){await engine.addParticleUpdater("strokeColor",(container=>new StrokeColorUpdater(container)),refresh)}(engine,!1),await loadBasic(engine,refresh)}const TextDrawer_validTypes=["text","character","char","multiline-text"];class TextDrawer{constructor(){this._drawLine=(context,line,radius,opacity,index,fill)=>{const pos={x:-(line.length*radius/2),y:radius/2},diameter=2*radius;fill?context.fillText(line,pos.x,pos.y+diameter*index):context.strokeText(line,pos.x,pos.y+diameter*index)}}draw(data){const{context,particle,radius,opacity}=data,character=particle.shapeData;if(!character)return;const textData=character.value;if(void 0===textData)return;void 0===particle.text&&(particle.text=itemFromSingleOrMultiple(textData,particle.randomIndexData));const text=particle.text,style=character.style??"",weight=character.weight??"400",size=2*Math.round(radius),font=character.font??"Verdana",fill=particle.shapeFill,lines=text?.split("\n");if(lines){context.font=`${style} ${weight} ${size}px "${font}"`,context.globalAlpha=opacity;for(let i=0;i<lines.length;i++)this._drawLine(context,lines[i],radius,opacity,i,fill);context.globalAlpha=1}}async init(container){const options=container.actualOptions;if(TextDrawer_validTypes.find((t=>isInArray(t,options.particles.shape.type)))){const shapeOptions=TextDrawer_validTypes.map((t=>options.particles.shape.options[t])).find((t=>!!t)),promises=[];executeOnSingleOrMultiple(shapeOptions,(shape=>{promises.push(loadFont(shape.font,shape.weight))})),await Promise.all(promises)}}particleInit(container,particle){if(!particle.shape||!TextDrawer_validTypes.includes(particle.shape))return;const character=particle.shapeData;if(void 0===character)return;const textData=character.value;void 0!==textData&&(particle.text=itemFromSingleOrMultiple(textData,particle.randomIndexData))}}class TiltAnimation{constructor(){this.enable=!1,this.speed=0,this.decay=0,this.sync=!1}load(data){data&&(void 0!==data.enable&&(this.enable=data.enable),void 0!==data.speed&&(this.speed=setRangeValue(data.speed)),void 0!==data.decay&&(this.decay=setRangeValue(data.decay)),void 0!==data.sync&&(this.sync=data.sync))}}class Tilt extends ValueWithRandom{constructor(){super(),this.animation=new TiltAnimation,this.direction="clockwise",this.enable=!1,this.value=0}load(data){super.load(data),data&&(this.animation.load(data.animation),void 0!==data.direction&&(this.direction=data.direction),void 0!==data.enable&&(this.enable=data.enable))}}class TiltUpdater{constructor(container){this.container=container}getTransformValues(particle){const tilt=particle.tilt?.enable&&particle.tilt;return{b:tilt?Math.cos(tilt.value)*tilt.cosDirection:void 0,c:tilt?Math.sin(tilt.value)*tilt.sinDirection:void 0}}init(particle){const tiltOptions=particle.options.tilt;if(!tiltOptions)return;particle.tilt={enable:tiltOptions.enable,value:getRangeValue(tiltOptions.value)*Math.PI/180,sinDirection:getRandom()>=.5?1:-1,cosDirection:getRandom()>=.5?1:-1};let tiltDirection=tiltOptions.direction;if("random"===tiltDirection){tiltDirection=Math.floor(2*getRandom())>0?"counter-clockwise":"clockwise"}switch(tiltDirection){case"counter-clockwise":case"counterClockwise":particle.tilt.status="decreasing";break;case"clockwise":particle.tilt.status="increasing"}const tiltAnimation=particle.options.tilt?.animation;tiltAnimation?.enable&&(particle.tilt.decay=1-getRangeValue(tiltAnimation.decay),particle.tilt.velocity=getRangeValue(tiltAnimation.speed)/360*this.container.retina.reduceFactor,tiltAnimation.sync||(particle.tilt.velocity*=getRandom()))}isEnabled(particle){const tiltAnimation=particle.options.tilt?.animation;return!particle.destroyed&&!particle.spawning&&!!tiltAnimation?.enable}loadOptions(options,...sources){options.tilt||(options.tilt=new Tilt);for(const source of sources)options.tilt.load(source?.tilt)}update(particle,delta){this.isEnabled(particle)&&function updateTilt(particle,delta){if(!particle.tilt||!particle.options.tilt)return;const tiltAnimation=particle.options.tilt.animation,speed=(particle.tilt.velocity??0)*delta.factor,max=2*Math.PI,decay=particle.tilt.decay??1;tiltAnimation.enable&&("increasing"===particle.tilt.status?(particle.tilt.value+=speed,particle.tilt.value>max&&(particle.tilt.value-=max)):(particle.tilt.value-=speed,particle.tilt.value<0&&(particle.tilt.value+=max)),particle.tilt.velocity&&1!==decay&&(particle.tilt.velocity*=decay))}(particle,delta)}}class TwinkleValues{constructor(){this.enable=!1,this.frequency=.05,this.opacity=1}load(data){data&&(void 0!==data.color&&(this.color=OptionsColor.create(this.color,data.color)),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.frequency&&(this.frequency=data.frequency),void 0!==data.opacity&&(this.opacity=setRangeValue(data.opacity)))}}class Twinkle{constructor(){this.lines=new TwinkleValues,this.particles=new TwinkleValues}load(data){data&&(this.lines.load(data.lines),this.particles.load(data.particles))}}class TwinkleUpdater{getColorStyles(particle,context,radius,opacity){const twinkleOptions=particle.options.twinkle;if(!twinkleOptions)return{};const twinkle=twinkleOptions.particles,twinkling=twinkle.enable&&getRandom()<twinkle.frequency,zIndexOptions=particle.options.zIndex,zOpacityFactor=(1-particle.zIndexFactor)**zIndexOptions.opacityRate,twinklingOpacity=twinkling?getRangeValue(twinkle.opacity)*zOpacityFactor:opacity,twinkleRgb=rangeColorToHsl(twinkle.color),twinkleStyle=twinkleRgb?getStyleFromHsl(twinkleRgb,twinklingOpacity):void 0,res={},needsTwinkle=twinkling&&twinkleStyle;return res.fill=needsTwinkle?twinkleStyle:void 0,res.stroke=needsTwinkle?twinkleStyle:void 0,res}init(){}isEnabled(particle){const twinkleOptions=particle.options.twinkle;return!!twinkleOptions&&twinkleOptions.particles.enable}loadOptions(options,...sources){options.twinkle||(options.twinkle=new Twinkle);for(const source of sources)options.twinkle.load(source?.twinkle)}update(){}}class WobbleSpeed{constructor(){this.angle=50,this.move=10}load(data){data&&(void 0!==data.angle&&(this.angle=setRangeValue(data.angle)),void 0!==data.move&&(this.move=setRangeValue(data.move)))}}class Wobble{constructor(){this.distance=5,this.enable=!1,this.speed=new WobbleSpeed}load(data){if(data&&(void 0!==data.distance&&(this.distance=setRangeValue(data.distance)),void 0!==data.enable&&(this.enable=data.enable),void 0!==data.speed))if(isNumber(data.speed))this.speed.load({angle:data.speed});else{const rangeSpeed=data.speed;void 0!==rangeSpeed.min?this.speed.load({angle:rangeSpeed}):this.speed.load(data.speed)}}}class WobbleUpdater{constructor(container){this.container=container}init(particle){const wobbleOpt=particle.options.wobble;particle.wobble=wobbleOpt?.enable?{angle:getRandom()*Math.PI*2,angleSpeed:getRangeValue(wobbleOpt.speed.angle)/360,moveSpeed:getRangeValue(wobbleOpt.speed.move)/10}:{angle:0,angleSpeed:0,moveSpeed:0},particle.retina.wobbleDistance=getRangeValue(wobbleOpt?.distance??0)*this.container.retina.pixelRatio}isEnabled(particle){return!particle.destroyed&&!particle.spawning&&!!particle.options.wobble?.enable}loadOptions(options,...sources){options.wobble||(options.wobble=new Wobble);for(const source of sources)options.wobble.load(source?.wobble)}update(particle,delta){this.isEnabled(particle)&&function updateWobble(particle,delta){const{wobble:wobbleOptions}=particle.options,{wobble}=particle;if(!wobbleOptions?.enable||!wobble)return;const angleSpeed=wobble.angleSpeed*delta.factor,distance=wobble.moveSpeed*delta.factor*((particle.retina.wobbleDistance??0)*delta.factor)/(1e3/60),max=2*Math.PI,{position}=particle;wobble.angle+=angleSpeed,wobble.angle>max&&(wobble.angle-=max),position.x+=distance*Math.cos(wobble.angle),position.y+=distance*Math.abs(Math.sin(wobble.angle))}(particle,delta)}}async function loadFull(engine,refresh=!0){await async function loadDestroyUpdater(engine,refresh=!0){await engine.addParticleUpdater("destroy",(container=>new DestroyUpdater(engine,container)),refresh)}(engine,!1),await async function loadRollUpdater(engine,refresh=!0){await engine.addParticleUpdater("roll",(()=>new RollUpdater),refresh)}(engine,!1),await async function loadTiltUpdater(engine,refresh=!0){await engine.addParticleUpdater("tilt",(container=>new TiltUpdater(container)),refresh)}(engine,!1),await async function loadTwinkleUpdater(engine,refresh=!0){await engine.addParticleUpdater("twinkle",(()=>new TwinkleUpdater),refresh)}(engine,!1),await async function loadWobbleUpdater(engine,refresh=!0){await engine.addParticleUpdater("wobble",(container=>new WobbleUpdater(container)),refresh)}(engine,!1),await async function loadTextShape(engine,refresh=!0){await engine.addShape(TextDrawer_validTypes,new TextDrawer,refresh)}(engine,!1),await async function loadExternalTrailInteraction(engine,refresh=!0){await engine.addInteractor("externalTrail",(container=>new TrailMaker(container)),refresh)}(engine,!1),await async function loadAbsorbersPlugin(engine,refresh=!0){await engine.addPlugin(new AbsorbersPlugin,refresh)}(engine,!1),await async function loadEmittersPlugin(engine,refresh=!0){engine.emitterShapeManager||(engine.emitterShapeManager=new ShapeManager(engine)),engine.addEmitterShapeGenerator||(engine.addEmitterShapeGenerator=(name,generator)=>{engine.emitterShapeManager?.addShapeGenerator(name,generator)});const plugin=new EmittersPlugin(engine);await engine.addPlugin(plugin,refresh)}(engine,!1),await async function loadEmittersShapeCircle(engine,refresh=!0){const emittersEngine=engine;emittersEngine.addEmitterShapeGenerator&&emittersEngine.addEmitterShapeGenerator("circle",new EmittersCircleShapeGenerator),await emittersEngine.refresh(refresh)}(engine,!1),await async function loadEmittersShapeSquare(engine,refresh=!0){const emittersEngine=engine;emittersEngine.addEmitterShapeGenerator&&emittersEngine.addEmitterShapeGenerator("square",new EmittersSquareShapeGenerator),await emittersEngine.refresh(refresh)}(engine,!1),await loadSlim(engine,refresh)}},"./node_modules/type-detect/type-detect.js":function(module,__unused_webpack_exports,__webpack_require__){module.exports=function(){"use strict";var promiseExists="function"==typeof Promise,globalObject="object"==typeof self?self:__webpack_require__.g,symbolExists="undefined"!=typeof Symbol,mapExists="undefined"!=typeof Map,setExists="undefined"!=typeof Set,weakMapExists="undefined"!=typeof WeakMap,weakSetExists="undefined"!=typeof WeakSet,dataViewExists="undefined"!=typeof DataView,symbolIteratorExists=symbolExists&&void 0!==Symbol.iterator,symbolToStringTagExists=symbolExists&&void 0!==Symbol.toStringTag,setEntriesExists=setExists&&"function"==typeof Set.prototype.entries,mapEntriesExists=mapExists&&"function"==typeof Map.prototype.entries,setIteratorPrototype=setEntriesExists&&Object.getPrototypeOf((new Set).entries()),mapIteratorPrototype=mapEntriesExists&&Object.getPrototypeOf((new Map).entries()),arrayIteratorExists=symbolIteratorExists&&"function"==typeof Array.prototype[Symbol.iterator],arrayIteratorPrototype=arrayIteratorExists&&Object.getPrototypeOf([][Symbol.iterator]()),stringIteratorExists=symbolIteratorExists&&"function"==typeof String.prototype[Symbol.iterator],stringIteratorPrototype=stringIteratorExists&&Object.getPrototypeOf(""[Symbol.iterator]()),toStringLeftSliceLength=8,toStringRightSliceLength=-1;function typeDetect(obj){var typeofObj=typeof obj;if("object"!==typeofObj)return typeofObj;if(null===obj)return"null";if(obj===globalObject)return"global";if(Array.isArray(obj)&&(!1===symbolToStringTagExists||!(Symbol.toStringTag in obj)))return"Array";if("object"==typeof window&&null!==window){if("object"==typeof window.location&&obj===window.location)return"Location";if("object"==typeof window.document&&obj===window.document)return"Document";if("object"==typeof window.navigator){if("object"==typeof window.navigator.mimeTypes&&obj===window.navigator.mimeTypes)return"MimeTypeArray";if("object"==typeof window.navigator.plugins&&obj===window.navigator.plugins)return"PluginArray"}if(("function"==typeof window.HTMLElement||"object"==typeof window.HTMLElement)&&obj instanceof window.HTMLElement){if("BLOCKQUOTE"===obj.tagName)return"HTMLQuoteElement";if("TD"===obj.tagName)return"HTMLTableDataCellElement";if("TH"===obj.tagName)return"HTMLTableHeaderCellElement"}}var stringTag=symbolToStringTagExists&&obj[Symbol.toStringTag];if("string"==typeof stringTag)return stringTag;var objPrototype=Object.getPrototypeOf(obj);return objPrototype===RegExp.prototype?"RegExp":objPrototype===Date.prototype?"Date":promiseExists&&objPrototype===Promise.prototype?"Promise":setExists&&objPrototype===Set.prototype?"Set":mapExists&&objPrototype===Map.prototype?"Map":weakSetExists&&objPrototype===WeakSet.prototype?"WeakSet":weakMapExists&&objPrototype===WeakMap.prototype?"WeakMap":dataViewExists&&objPrototype===DataView.prototype?"DataView":mapExists&&objPrototype===mapIteratorPrototype?"Map Iterator":setExists&&objPrototype===setIteratorPrototype?"Set Iterator":arrayIteratorExists&&objPrototype===arrayIteratorPrototype?"Array Iterator":stringIteratorExists&&objPrototype===stringIteratorPrototype?"String Iterator":null===objPrototype?"Object":Object.prototype.toString.call(obj).slice(toStringLeftSliceLength,toStringRightSliceLength)}return typeDetect}()}}]);